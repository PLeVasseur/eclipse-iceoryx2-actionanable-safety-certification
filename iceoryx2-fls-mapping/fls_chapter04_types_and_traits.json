{
  "chapter": 4,
  "title": "Types and Traits",
  "fls_url": "https://rust-lang.github.io/fls/types-and-traits.html",
  "fls_id": "fls_vgb6ev541b2r",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2024-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Union types now used in FFI layer, raw pointer usage increased for expanded FFI, new StaticVec/StaticString types",
    "key_changes": [
      "Union types introduced (0 -> 42) for C FFI bindings",
      "*mut pointer usage increased significantly for FFI",
      "UnsafeCell usage increased (for lock-free structures)",
      "unsafe impl Send/Sync counts increased",
      "New StaticVec<T, N> and StaticString<N> types replace FixedSize* types"
    ]
  },
  "summary": "FLS Chapter 4 defines types and traits. Types define sets of values and operations. This mapping covers all type categories as defined in the FLS and their usage in iceoryx2.",
  "statistics": {
    "structs": 868,
    "enums": 371,
    "unions": 40,
    "traits": 124,
    "type_aliases": 578,
    "usize_usage": 2787,
    "raw_pointers": 3539,
    "Box_usage": 319,
    "Arc_usage": 58,
    "MaybeUninit": 129,
    "UnsafeCell": 114,
    "ManuallyDrop": 80,
    "repr_C": 393,
    "repr_transparent": 35,
    "ZeroCopySend": 859
  },
  "sections": {
    "types": {
      "fls_section": "4.1",
      "fls_ids": [],
      "description": "Types",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": []
    },
    "type_classification": {
      "fls_section": "4.2",
      "fls_ids": [
        "fls_963gsjp2jas2"
      ],
      "description": "Type Classification",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": []
    },
    "scalar_types": {
      "fls_section": "4.3",
      "fls_ids": [
        "fls_id66vnaqw0zt"
      ],
      "description": "Scalar Types",
      "status": "demonstrated",
      "findings": {
        "usize": 2787,
        "u64": 1521,
        "u8": 1227,
        "bool": 919,
        "float": 52
      },
      "samples": [],
      "subsections": {
        "bool_type": {
          "fls_section": "4.3.1",
          "fls_ids": [
            "fls_tiqp1gxf116z"
          ],
          "description": "Bool Type",
          "status": "demonstrated",
          "findings": {
            "count": 919,
            "description": "Boolean type used extensively for flags, conditions, and state tracking.",
            "patterns": ["Configuration flags", "State indicators", "Test assertions"]
          },
          "samples": []
        },
        "char_type": {
          "fls_section": "4.3.2",
          "fls_ids": [
            "fls_wrvjizrqf3po"
          ],
          "description": "Char Type",
          "status": "limited_use",
          "findings": {
            "count": 20,
            "description": "Char type is minimally used - byte types (u8) preferred for ASCII operations.",
            "rationale": "IPC data uses byte arrays; char is Unicode which adds complexity"
          },
          "samples": []
        },
        "numeric_types": {
          "fls_section": "4.3.3",
          "fls_ids": [
            "fls_qwljwqr07slp"
          ],
          "description": "Numeric Types",
          "status": "demonstrated",
          "findings": {
            "description": "Integer types are extensively used with explicit sizing for safety-critical code.",
            "usize": 2787,
            "u64": 1521,
            "u8": 1227
          },
          "samples": [],
          "subsections": {
            "floating_point_types": {
              "fls_section": "4.3.3.1",
              "fls_ids": [
                "fls_b4xporvr64s"
              ],
              "description": "Floating Point Types",
              "status": "limited_use",
              "findings": {
                "count": 52,
                "description": "Floating point types minimally used for safety-critical determinism.",
                "rationale": "Duration and integer arithmetic preferred"
              },
              "samples": []
            },
            "integer_types": {
              "fls_section": "4.3.3.2",
              "fls_ids": [
                "fls_3qnpv2z7yjil"
              ],
              "description": "Integer Types",
              "status": "demonstrated",
              "findings": {
                "description": "All integer types used with explicit sizing.",
                "unsigned": ["u8", "u16", "u32", "u64", "usize"],
                "signed": ["i8", "i16", "i32", "i64", "isize"],
                "note": "usize most common for indexing and sizes"
              },
              "samples": []
            }
          }
        }
      }
    },
    "sequence_types": {
      "fls_section": "4.4",
      "fls_ids": [
        "fls_fbchw64p6n2x"
      ],
      "description": "Sequence Types",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "subsections": {
        "array_types": {
          "fls_section": "4.4.1",
          "fls_ids": [
            "fls_uj0kpjwyld60"
          ],
          "description": "Array Types",
          "status": "demonstrated",
          "findings": {
            "count": 177,
            "description": "Fixed-size arrays used for buffers, initialization, and const-generic containers.",
            "patterns": ["[u8; N] byte buffers", "[T; N] fixed containers", "StaticVec/StaticString with const N"]
          },
          "samples": []
        },
        "slice_types": {
          "fls_section": "4.4.2",
          "fls_ids": [
            "fls_vpbikb73dw4k"
          ],
          "description": "Slice Types",
          "status": "demonstrated",
          "findings": {
            "description": "Slice types (&[T]) used extensively for dynamic views into arrays and vectors.",
            "patterns": ["&[u8] for byte data", "&[T] for generic slices", "&mut [T] for mutable access"]
          },
          "samples": []
        },
        "str_type": {
          "fls_section": "4.4.3",
          "fls_ids": [
            "fls_4agmmu5al6gt"
          ],
          "description": "Str Type",
          "status": "demonstrated",
          "findings": {
            "description": "String slices (&str) used for string literals and borrowed string data.",
            "patterns": ["&str for string parameters", "&'static str for constants"]
          },
          "samples": []
        },
        "tuple_types": {
          "fls_section": "4.4.4",
          "fls_ids": [
            "fls_4ckl3n2ko3i4"
          ],
          "description": "Tuple Types",
          "status": "demonstrated",
          "findings": {
            "description": "Tuple types used for multiple return values and pattern matching.",
            "patterns": ["Result<(A, B), E>", "Option<(T, U)>", "destructuring in match"]
          },
          "samples": []
        }
      }
    },
    "abstract_data_types": {
      "fls_section": "4.5",
      "fls_ids": [
        "fls_wdec78luqh5b"
      ],
      "description": "Abstract Data Types",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "subsections": {
        "enum_types": {
          "fls_section": "4.5.1",
          "fls_ids": [
            "fls_szibmtfv117b"
          ],
          "description": "Enum Types",
          "status": "demonstrated",
          "findings": {
            "count": 449,
            "description": "Enums extensively used for error types, state machines, and options.",
            "patterns": ["Error enums via enum_gen! macro", "State enums", "Option/Result variants"],
            "repr_c_enums": "FFI enums use #[repr(C)] for C compatibility"
          },
          "samples": []
        },
        "struct_types": {
          "fls_section": "4.5.2",
          "fls_ids": [
            "fls_9ucqbbd0s2yo"
          ],
          "description": "Struct Types",
          "status": "demonstrated",
          "findings": {
            "count": 1192,
            "description": "Structs are the primary data structure type.",
            "patterns": ["Named structs for complex types", "Tuple structs for newtypes", "#[repr(C)] for FFI/IPC"],
            "repr_c": 393,
            "repr_transparent": 35
          },
          "samples": []
        },
        "union_types": {
          "fls_section": "4.5.3",
          "fls_ids": [
            "fls_fmdn7n7s413d"
          ],
          "description": "Union Types",
          "status": "demonstrated",
          "findings": {
            "count": 42,
            "description": "NEW in v0.8.0 - Unions used exclusively for FFI C API discriminated unions.",
            "pattern": "ManuallyDrop<T> wraps variants for explicit lifetime control",
            "location": "iceoryx2-ffi/c crate"
          },
          "samples": []
        }
      }
    },
    "function_types": {
      "fls_section": "4.6",
      "fls_ids": [
        "fls_hbbek3z4wtcs"
      ],
      "description": "Function Types",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "subsections": {
        "closure_types": {
          "fls_section": "4.6.1",
          "fls_ids": [
            "fls_xd2oxlebhs14"
          ],
          "description": "Closure Types",
          "status": "demonstrated",
          "findings": {
            "count": 1638,
            "description": "Closures used for callbacks, iterators, and functional patterns.",
            "traits": ["Fn", "FnMut", "FnOnce"],
            "patterns": ["Iterator combinators", "Builder pattern callbacks", "Test fixtures"]
          },
          "samples": []
        },
        "function_item_types": {
          "fls_section": "4.6.2",
          "fls_ids": [
            "fls_airvr79xkcag"
          ],
          "description": "Function Item Types",
          "status": "demonstrated",
          "findings": {
            "description": "Function items are zero-sized types representing specific functions.",
            "patterns": ["Function as generic parameter", "Function pointer coercion"]
          },
          "samples": []
        }
      }
    },
    "indirection_types": {
      "fls_section": "4.7",
      "fls_ids": [
        "fls_3i4ou0dq64ny"
      ],
      "description": "Indirection Types",
      "status": "demonstrated",
      "findings": {
        "raw_pointers": 3539,
        "Box": 319,
        "Arc": 58,
        "NonNull": 175
      },
      "samples": [],
      "subsections": {
        "function_pointer_types": {
          "fls_section": "4.7.1",
          "fls_ids": [
            "fls_xztr1kebz8bo"
          ],
          "description": "Function Pointer Types",
          "status": "demonstrated",
          "findings": {
            "count": 259,
            "description": "Function pointers used for FFI callbacks and dynamic dispatch.",
            "patterns": ["extern \"C\" fn(...) for C callbacks", "Option<fn(...)> for nullable callbacks"]
          },
          "samples": []
        },
        "raw_pointer_types": {
          "fls_section": "4.7.2",
          "fls_ids": [
            "fls_ppd1xwve3tr7"
          ],
          "description": "Raw Pointer Types",
          "status": "demonstrated",
          "findings": {
            "count": 3435,
            "description": "Raw pointers (*const T, *mut T) heavily used for FFI and shared memory.",
            "const_ptr": "*const T for read-only FFI data",
            "mut_ptr": "*mut T for mutable FFI data and shared memory",
            "NonNull": 175,
            "note": "+2000 from v0.7.0 due to FFI expansion"
          },
          "samples": []
        },
        "reference_types": {
          "fls_section": "4.7.3",
          "fls_ids": [
            "fls_142vncdktbin"
          ],
          "description": "Reference Types",
          "status": "demonstrated",
          "findings": {
            "count": 10622,
            "description": "References are the primary safe pointer type.",
            "shared": "&T for shared/immutable access",
            "mutable": "&mut T for exclusive/mutable access",
            "lifetime_annotations": "Explicit lifetimes for complex borrowing"
          },
          "samples": []
        }
      }
    },
    "trait_types": {
      "fls_section": "4.8",
      "fls_ids": [
        "fls_1ompd93w7c9f"
      ],
      "description": "Trait Types",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "subsections": {
        "impl_trait_types": {
          "fls_section": "4.8.1",
          "fls_ids": [
            "fls_3xqobbu7wfsf"
          ],
          "description": "Impl Trait Types",
          "status": "limited_use",
          "findings": {
            "description": "impl Trait minimally used - explicit types preferred for clarity.",
            "return_position": "Limited use in return types",
            "argument_position": "Rare - generics preferred"
          },
          "samples": []
        },
        "trait_object_types": {
          "fls_section": "4.8.2",
          "fls_ids": [
            "fls_qa98qdi42orq"
          ],
          "description": "Trait Object Types",
          "status": "demonstrated",
          "findings": {
            "count": 318,
            "description": "dyn Trait used for dynamic dispatch when needed.",
            "patterns": ["dyn Log for logger abstraction", "dyn Write for output abstraction", "dyn Error for error handling"],
            "note": "+309 from v0.7.0"
          },
          "samples": []
        }
      }
    },
    "other_types": {
      "fls_section": "4.9",
      "fls_ids": [
        "fls_3pbipk8ki18d"
      ],
      "description": "Other Types",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "subsections": {
        "inferred_types": {
          "fls_section": "4.9.1",
          "fls_ids": [
            "fls_s45k21yn4qur"
          ],
          "description": "Inferred Types",
          "status": "demonstrated",
          "findings": {
            "description": "Type inference used via _ placeholder where types are clear from context.",
            "patterns": ["let x: Vec<_> = ...", "collect::<Vec<_>>()"],
            "note": "Explicit types preferred in public APIs"
          },
          "samples": []
        },
        "type_parameters": {
          "fls_section": "4.9.2",
          "fls_ids": [],
          "description": "Type Parameters",
          "status": "demonstrated",
          "findings": {
            "description": "Generics extensively used for type-safe abstractions.",
            "patterns": ["<T>", "<T: Trait>", "<T, const N: usize>"],
            "const_generics": "Used for StaticVec<T, N>, StaticString<N>"
          },
          "samples": []
        },
        "never_type": {
          "fls_section": "4.9.3",
          "fls_ids": [
            "fls_98lnexk53ru4"
          ],
          "description": "Never Type",
          "status": "not_used",
          "findings": {
            "description": "The never type (!) is not explicitly used in iceoryx2 function signatures.",
            "note": "Implicitly returned by panic!, unreachable!"
          },
          "samples": []
        },
        "parenthesized_types": {
          "fls_section": "4.9.4",
          "fls_ids": [
            "fls_olbj67eyxz2k"
          ],
          "description": "Parenthesized Types",
          "status": "demonstrated",
          "findings": {
            "description": "Parenthesized types used for disambiguation.",
            "patterns": ["&(dyn Trait)", "(Fn(...) -> T)"]
          },
          "samples": []
        }
      }
    },
    "type_aliases": {
      "fls_section": "4.10",
      "fls_ids": [
        "fls_kgvleup5mdhq"
      ],
      "description": "Type Aliases",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/bit_set.rs",
          "line": [
            53
          ],
          "code": "pub type BitSet = details::BitSet<OwningPointer<details::BitsetElement>>;"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/bit_set.rs",
          "line": [
            55
          ],
          "code": "pub type RelocatableBitSet = details::BitSet<RelocatablePointer<details::BitsetElement>>;"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/spsc/index_queue.rs",
          "line": [
            96
          ],
          "code": "pub type IndexQueue = details::IndexQueue<OwningPointer<UnsafeCell<u64>>>;"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/spsc/index_queue.rs",
          "line": [
            97
          ],
          "code": "pub type RelocatableIndexQueue = details::IndexQueue<RelocatablePointer<UnsafeCell<u64>>>;"
        },
        {
          "file": "iceoryx2-pal/posix/src/linux/types.rs",
          "line": [
            19
          ],
          "code": "pub type ulong = crate::internal::ulong;"
        },
        {
          "file": "iceoryx2-pal/posix/src/linux/types.rs",
          "line": [
            34
          ],
          "code": "pub type c_char = core::ffi::c_char;"
        }
      ]
    },
    "representation": {
      "fls_section": "4.11",
      "fls_ids": [
        "fls_7pby13muw48o"
      ],
      "description": "Representation",
      "status": "demonstrated",
      "findings": {
        "repr_C": 393,
        "repr_transparent": 35,
        "repr_align": 59
      },
      "samples": [],
      "subsections": {
        "type_layout": {
          "fls_section": "4.11.1",
          "fls_ids": [
            "fls_g1z6bpyjqxkz"
          ],
          "description": "Type Layout",
          "status": "demonstrated",
          "findings": {
            "description": "Type layout (size, alignment) is critical for shared memory and FFI.",
            "repr_align": 59,
            "patterns": ["#[repr(align(N))] for cache alignment", "mem::size_of for layout queries"]
          },
          "samples": []
        },
        "type_representation": {
          "fls_section": "4.11.2",
          "fls_ids": [
            "fls_ohhsmifo0urd"
          ],
          "description": "Type Representation",
          "status": "demonstrated",
          "findings": {
            "repr_C": 393,
            "repr_transparent": 35,
            "description": "Type representation controlled via #[repr] attributes for FFI and IPC."
          },
          "samples": [],
          "subsections": {
            "enum_type_representation": {
              "fls_section": "4.11.2.1",
              "fls_ids": [
                "fls_xc1hof4qbf6p"
              ],
              "description": "Enum Type Representation",
              "status": "demonstrated",
              "findings": {
                "description": "#[repr(C)] or #[repr(u8/u32)] for FFI enums with stable discriminants."
              },
              "samples": []
            },
            "struct_type_representation": {
              "fls_section": "4.11.2.2",
              "fls_ids": [
                "fls_rjxpof29a3nl"
              ],
              "description": "Struct Type Representation",
              "status": "demonstrated",
              "findings": {
                "repr_C": 393,
                "repr_transparent": 35,
                "description": "#[repr(C)] for FFI/IPC types, #[repr(transparent)] for newtypes."
              },
              "samples": []
            },
            "union_type_representation": {
              "fls_section": "4.11.2.3",
              "fls_ids": [
                "fls_cmq8ogs84ivh"
              ],
              "description": "Union Type Representation",
              "status": "demonstrated",
              "findings": {
                "count": 42,
                "description": "All unions use #[repr(C)] for C API compatibility.",
                "note": "NEW in v0.8.0"
              },
              "samples": []
            }
          }
        }
      }
    },
    "type_model": {
      "fls_section": "4.12",
      "fls_ids": [
        "fls_j02707n615z0"
      ],
      "description": "Type Model",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "subsections": {
        "recursive_types": {
          "fls_section": "4.12.1",
          "fls_ids": [
            "fls_3gapgqys3ceb"
          ],
          "description": "Recursive Types",
          "status": "not_used",
          "findings": {
            "description": "Self-referential types requiring Box indirection are not used in iceoryx2.",
            "rationale": "Shared memory types require known sizes at compile time"
          },
          "samples": []
        },
        "type_unification": {
          "fls_section": "4.12.2",
          "fls_ids": [
            "fls_exe4zodlwfez"
          ],
          "description": "Type Unification",
          "status": "demonstrated",
          "findings": {
            "description": "Type unification occurs during type inference. Explicit types minimize unification complexity."
          },
          "samples": []
        },
        "type_coercion": {
          "fls_section": "4.12.3",
          "fls_ids": [
            "fls_dw33yt5g6m0k"
          ],
          "description": "Type Coercion",
          "status": "demonstrated",
          "findings": {
            "description": "Implicit coercions occur for reference deref, unsizing, and subtyping.",
            "patterns": ["&mut T -> &T", "&T -> *const T", "&[T; N] -> &[T]"]
          },
          "samples": []
        },
        "structural_equality": {
          "fls_section": "4.12.4",
          "fls_ids": [],
          "description": "Structural Equality",
          "status": "demonstrated",
          "findings": {
            "description": "Types with same structure are structurally equal. Used in generic contexts."
          },
          "samples": []
        },
        "interior_mutability": {
          "fls_section": "4.12.5",
          "fls_ids": [
            "fls_omaq7psg83n3"
          ],
          "description": "Interior Mutability",
          "status": "demonstrated",
          "findings": {
            "UnsafeCell": 231,
            "description": "UnsafeCell enables interior mutability for lock-free structures and shared memory.",
            "patterns": ["Lock-free queue internals", "Shared memory data access", "Lazy initialization"]
          },
          "samples": []
        },
        "visible_emptiness": {
          "fls_section": "4.12.6",
          "fls_ids": [],
          "description": "Visible Emptiness",
          "status": "not_used",
          "findings": {
            "description": "Uninhabited types (empty enums) are not used in iceoryx2."
          },
          "samples": []
        },
        "type_inference": {
          "fls_section": "4.12.7",
          "fls_ids": [
            "fls_lv7w7aalpwm5"
          ],
          "description": "Type Inference",
          "status": "demonstrated",
          "findings": {
            "description": "Type inference used for local bindings; explicit types for public APIs.",
            "patterns": ["let x = expr; (inferred)", "fn foo() -> T (explicit)"]
          },
          "samples": []
        }
      }
    },
    "traits": {
      "fls_section": "4.13",
      "fls_ids": [
        "fls_85vx1qfa061i"
      ],
      "description": "Traits",
      "status": "demonstrated",
      "findings": {
        "total_traits": 124,
        "unsafe_traits": 1,
        "ZeroCopySend": 859
      },
      "samples": [
        {
          "file": "iceoryx2-bb/elementary-traits/src/zero_copy_send.rs",
          "line": [
            32
          ],
          "code": "pub unsafe trait ZeroCopySend { }",
          "purpose": "Zero-copy safety marker trait"
        }
      ],
      "subsections": {
        "object_safety": {
          "fls_section": "4.13.1",
          "fls_ids": [
            "fls_4ikc07mfrez5"
          ],
          "description": "Object Safety",
          "status": "demonstrated",
          "findings": {
            "description": "Object-safe traits can be used as trait objects (dyn Trait).",
            "dyn_usage": 318,
            "patterns": ["dyn Log", "dyn Write", "dyn Error"],
            "note": "Object-safe traits avoid Self or associated types in method signatures"
          },
          "samples": []
        }
      }
    },
    "trait_and_lifetime_bounds": {
      "fls_section": "4.14",
      "fls_ids": [
        "fls_jeoas4n6su4"
      ],
      "description": "Trait and Lifetime Bounds",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/posix/src/read_write_mutex.rs",
          "line": [
            320
          ],
          "code": "pub struct ReadWriteMutex<'this, 'handle: 'this, T: Sized + Debug> {"
        },
        {
          "file": "iceoryx2-bb/posix/src/mutex.rs",
          "line": [
            507
          ],
          "code": "pub struct Mutex<'this, 'handle: 'this, T: Sized + Debug> {"
        }
      ],
      "subsections": {
        "lifetimes": {
          "fls_section": "4.14.1",
          "fls_ids": [
            "fls_yqcygq3y6m5j"
          ],
          "description": "Lifetimes",
          "status": "demonstrated",
          "findings": {
            "description": "Explicit lifetimes used for complex borrowing relationships.",
            "patterns": ["'a, 'b generic lifetimes", "'static for global data", "'this, 'handle for mutex guards"],
            "lifetime_bounds": "'handle: 'this for nested lifetimes"
          },
          "samples": []
        },
        "subtyping_and_variance": {
          "fls_section": "4.14.2",
          "fls_ids": [
            "fls_ikfvbeewame7"
          ],
          "description": "Subtyping and Variance",
          "status": "demonstrated",
          "findings": {
            "description": "Lifetime subtyping used implicitly. PhantomData for variance control.",
            "PhantomData": 256,
            "patterns": ["PhantomData<T> for ownership", "PhantomData<*const T> for invariance"]
          },
          "samples": []
        },
        "lifetime_elision": {
          "fls_section": "4.14.3",
          "fls_ids": [
            "fls_l9ebxrlxyawd"
          ],
          "description": "Lifetime Elision",
          "status": "demonstrated",
          "findings": {
            "description": "Lifetime elision applied where rules permit; explicit lifetimes for clarity."
          },
          "samples": [],
          "subsections": {
            "function_lifetime_elision": {
              "fls_section": "4.14.3.1",
              "fls_ids": [],
              "description": "Function Lifetime Elision",
              "status": "demonstrated",
              "findings": {
                "description": "Standard elision rules applied: single input lifetime -> output lifetime."
              },
              "samples": []
            },
            "static_lifetime_elision": {
              "fls_section": "4.14.3.2",
              "fls_ids": [],
              "description": "Static Lifetime Elision",
              "status": "demonstrated",
              "findings": {
                "description": "const and static items have implicit 'static lifetime."
              },
              "samples": []
            },
            "trait_object_lifetime_elision": {
              "fls_section": "4.14.3.3",
              "fls_ids": [],
              "description": "Trait Object Lifetime Elision",
              "status": "demonstrated",
              "findings": {
                "description": "dyn Trait defaults to 'static or enclosing lifetime based on context."
              },
              "samples": []
            },
            "impl_header_lifetime_elision": {
              "fls_section": "4.14.3.4",
              "fls_ids": [],
              "description": "Impl Header Lifetime Elision",
              "status": "demonstrated",
              "findings": {
                "description": "impl<'a> Trait for Type<'a> elides to impl Trait for Type<'_>."
              },
              "samples": []
            }
          }
        }
      }
    }
  },
  "safety_critical_summary": {
    "types_not_used": {
      "never_type": "No explicit ! return types",
      "zero_variant_enums": "No uninhabited enum types",
      "impl_trait_types": "Minimal impl Trait usage",
      "recursive_types": "No self-referential types"
    },
    "types_changed_in_v0_8_0": {
      "union_types": {
        "v0_7_0": 0,
        "v0_8_0": 42,
        "change": "NEW - union types for FFI layer",
        "risk": "MEDIUM - unsafe memory aliasing"
      },
      "raw_pointers": {
        "v0_7_0": "estimated ~1500",
        "v0_8_0": 3539,
        "change": "+2000+ due to FFI expansion",
        "risk": "MEDIUM - requires unsafe for dereference"
      }
    },
    "safety_patterns": {
      "repr_attributes": "#[repr(C)] for FFI stability, #[repr(transparent)] for newtypes",
      "marker_traits": "unsafe impl Send/Sync with careful review (43 total)",
      "interior_mutability": "UnsafeCell usage in lock-free structures (231 uses)",
      "unsized_types": "?Sized bounds for DST-generic APIs",
      "lifetime_bounds": "Explicit lifetime relationships for borrow safety"
    },
    "type_safety_features": {
      "explicit_typing": "Minimal type inference - explicit annotations preferred",
      "enum_discriminants": "Explicit repr for ABI stability",
      "newtype_pattern": "Tuple structs for type-safe wrappers",
      "trait_bounds": "Send + Sync + Copy + Debug common bounds",
      "new_container_types": "StaticVec and StaticString with const generics for no_std support"
    }
  }
}