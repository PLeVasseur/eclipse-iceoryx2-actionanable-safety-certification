{
  "chapter": 5,
  "title": "Patterns",
  "fls_url": "https://rust-lang.github.io/fls/patterns.html",
  "fls_id": "fls_xgqh0ju6bmbn",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2024-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Pattern usage expanded proportionally with codebase growth, path updates for new directory structure",
    "key_changes": [
      "match expressions increased with FFI layer",
      "if let usage expanded",
      "while let usage increased for async-free event processing"
    ]
  },
  "summary": "FLS Chapter 5 defines patterns - constructs that match values satisfying pattern criteria. Patterns are used in let bindings, match expressions, if let, while let, function parameters, and for loops.",
  "statistics": {},
  "sections": {
    "refutability": {
      "fls_section": "5.1 Refutability",
      "fls_ids": [
        "fls_uh76pw6ykd57"
      ],
      "description": "Refutability expresses the ability to match all possible values of a type. Irrefutable patterns always match; refutable patterns may fail to match.",
      "findings": {
        "irrefutable_patterns": "let bindings use irrefutable patterns (identifier, underscore)",
        "refutable_patterns": "match arms and if let use refutable patterns (literals, enums, ranges)"
      }
    },
    "struct_patterns": {
      "fls_section": "5.2 Struct Patterns",
      "fls_ids": [
        "fls_7dbd5t2750ce"
      ],
      "description": "Struct pattern matches enum values, struct values, or union values.",
      "findings": {
        "enum_matching": "Extensive use for Result and Option",
        "struct_destructuring": "Used with custom types",
        "union_matching": "NEW in v0.8.0 - for FFI unions"
      }
    },
    "binding_modes": {
      "fls_section": "5.3 Binding Modes",
      "fls_ids": [
        "fls_qssijtofa9i8"
      ],
      "description": "Binding modes determine how matched values are bound: by value, by reference, or by mutable reference.",
      "findings": {
        "by_value": "Default binding mode - moves or copies value",
        "by_reference": "ref keyword for immutable borrow",
        "by_mutable_reference": "99 ref mut patterns for mutable borrow"
      },
      "samples": [
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_handle_translator.rs",
          "line": [
            358
          ],
          "code": "if let FdHandleEntry::UdsDatagramSocket(ref mut s) = *self.fd2handle[fd as usize].get()"
        },
        {
          "file": "iceoryx2-pal/posix/src/macos/pthread.rs",
          "line": [
            119
          ],
          "code": "if let Some(ref mut v) = *state.get() {"
        },
        {
          "file": "iceoryx2/src/service/builder/publish_subscribe.rs",
          "line": [
            290
          ],
          "code": "MessagingPattern::PublishSubscribe(ref mut v) => v,"
        }
      ]
    },
    "pattern_matching": {
      "fls_section": "5.4 Pattern Matching",
      "fls_ids": [
        "fls_jm6l7b90h6wa"
      ],
      "description": "Pattern matching process involving a pattern and a context value.",
      "findings": {
        "match_expressions": "1663 match expressions (primary pattern matching construct)",
        "if_let": "337 if let expressions for conditional pattern matching",
        "while_let": "70 while let expressions for loop with pattern matching"
      }
    }
  },
  "safety_critical_summary": {
    "pattern_safety_features": {
      "exhaustive_matching": "Match expressions require exhaustive patterns",
      "irrefutable_requirement": "let bindings enforce irrefutable patterns",
      "type_checked": "All pattern types verified at compile time"
    },
    "common_patterns_in_safety_code": {
      "result_handling": "Ok(v)/Err(e) patterns for error propagation",
      "option_handling": "Some(v)/None patterns for nullable values",
      "enum_matching": "Exhaustive enum variant matching"
    },
    "binding_mode_safety": {
      "ref_patterns": "Borrow without ownership transfer",
      "ref_mut_patterns": "99 mutable borrow patterns in pattern context",
      "move_by_default": "Non-Copy types moved by default"
    },
    "version_comparison": {
      "match_expressions": {
        "v0_7_0": "~800",
        "v0_8_0": 1663,
        "change": "+863 (~108% increase)"
      },
      "if_let_expressions": {
        "v0_7_0": "~150",
        "v0_8_0": 337,
        "change": "+187 (~125% increase)"
      },
      "while_let_expressions": {
        "v0_7_0": "~30",
        "v0_8_0": 70,
        "change": "+40 (~133% increase)"
      }
    }
  }
}