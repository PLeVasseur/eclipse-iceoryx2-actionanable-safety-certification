{
  "standard": "MISRA-C",
  "standard_version": "2025",
  "fls_version": "1.0 (2024)",
  "mapping_date": "2025-12-31",
  "methodology": "Semantic embedding similarity + manual verification. High confidence mappings verified against MISRA rationale and FLS content.",
  "statistics": {
    "total_guidelines": 228,
    "mapped": 127,
    "unmapped": 0,
    "not_applicable": 99,
    "rust_prevents": 2,
    "with_fls_references": 216
  },
  "mappings": [
    {
      "guideline_id": "Dir 1.1",
      "guideline_title": "Any implementation-defined behaviour on which the output of the",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust prevents undefined behavior; unsafe requires careful handling"
    },
    {
      "guideline_id": "Dir 1.2",
      "guideline_title": "The use of language extensions should be minimized",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "misra_rust_comment": "previously Rule 1.2",
      "notes": "MISRA ADD-6: previously Rule 1.2"
    },
    {
      "guideline_id": "Dir 2.1",
      "guideline_title": "All source files shall compile without any compilation errors",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "notes": "Automated mapping - requires manual review"
    },
    {
      "guideline_id": "Dir 3.1",
      "guideline_title": "All code shall be traceable to documented requirements",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "notes": "Automated mapping - requires manual review"
    },
    {
      "guideline_id": "Dir 4.1",
      "guideline_title": "Run-time failures shall be minimized",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "misra_rust_comment": "often in the form of panics",
      "notes": "MISRA ADD-6: often in the form of panics"
    },
    {
      "guideline_id": "Dir 4.2",
      "guideline_title": "All usage of assembly language should be documented",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_a3joqzqp1v9d",
        "fls_e0896uk0mdyl",
        "fls_lv19xysy1f7e"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "22",
        "22.1",
        "22.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has asm! macro for inline assembly; always requires unsafe"
    },
    {
      "guideline_id": "Dir 4.3",
      "guideline_title": "Assembly language shall be encapsulated and isolated",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_a3joqzqp1v9d",
        "fls_e0896uk0mdyl",
        "fls_lv19xysy1f7e"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "22",
        "22.1",
        "22.2"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust has asm! macro for inline assembly; always requires unsafe"
    },
    {
      "guideline_id": "Dir 4.4",
      "guideline_title": "Sections of code should not be “commented out”",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_q8l2jza7d9xa"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.5"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust has similar comment syntax plus doc comments"
    },
    {
      "guideline_id": "Dir 4.5",
      "guideline_title": "Identifiers in the same name space with overlapping visibility should",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "“ambiguity” is determined by the project",
      "confidence": "medium",
      "notes": "MISRA ADD-6: “ambiguity” is determined by the project. Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Dir 4.6",
      "guideline_title": "typedefs that indicate size and signedness should be used in place of",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.11.1",
        "4.11"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "all primitive types already fulfil this",
      "confidence": "medium",
      "notes": "MISRA ADD-6: all primitive types already fulfil this. Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has std::mem::size_of"
    },
    {
      "guideline_id": "Dir 4.7",
      "guideline_title": "If a function returns error information, then that error information",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "prefer Option, Result, etc.",
      "confidence": "medium",
      "notes": "MISRA ADD-6: prefer Option, Result, etc.. Similar function semantics with stronger type checking; Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Dir 4.8",
      "guideline_title": "If a pointer to a structure or union is never dereferenced within a",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh",
        "fls_8wnyln2nmg4y"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Core Rust concept for safe memory access, applies to all Rust"
    },
    {
      "guideline_id": "Dir 4.9",
      "guideline_title": "A function should be used in preference to a function-like macro",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.1",
        "6.5.2",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Core Rust concept for safe memory access, applies to all Rust; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Dir 4.10",
      "guideline_title": "Precautions shall be taken in order to prevent the contents of a",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Dir 4.11",
      "guideline_title": "The validity of values passed to library functions shall be checked",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Dir 4.12",
      "guideline_title": "Dynamic memory allocation shall not be used",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs"
    },
    {
      "guideline_id": "Dir 4.13",
      "guideline_title": "Functions which are designed to provide operations on a resource",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_u2mzjgiwbkz0",
        "fls_4jiw35pan7vn",
        "fls_rm4ncoopcdvj"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.6",
        "15.7",
        "15.8"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Dir 4.14",
      "guideline_title": "The validity of values received from external sources shall be checked",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust uses pub visibility and modules instead of linkage; Rust has explicit FFI support with extern blocks; calling extern fn is unsafe"
    },
    {
      "guideline_id": "Dir 4.15",
      "guideline_title": "Evaluation of floating-point expressions shall not lead to the",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_b4xporvr64s",
        "fls_29tlg1vyqay2",
        "fls_1k9mkv7rbezi",
        "fls_nsvzzbldhq53",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.1",
        "2.4.4.2",
        "6.5.5",
        "6.5.7",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "Rust implements IEEE-754",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Rust implements IEEE-754. Rust has similar floating point semantics to C (IEEE 754); Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Dir 5.1",
      "guideline_title": "There shall be no data races between threads",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "not all safe Rust types are race-free",
      "confidence": "medium",
      "notes": "MISRA ADD-6: not all safe Rust types are race-free. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass"
    },
    {
      "guideline_id": "Dir 5.2",
      "guideline_title": "There shall be no deadlocks between threads",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards"
    },
    {
      "guideline_id": "Dir 5.3",
      "guideline_title": "There shall be no dynamic thread creation",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass"
    },
    {
      "guideline_id": "Rule 1.1",
      "guideline_title": "4.2 Compilation and build",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust prevents undefined behavior; unsafe requires careful handling"
    },
    {
      "guideline_id": "Rule 1.2",
      "guideline_title": "Renumbered as Directive 1.2 MISRA C:2025",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_szibmtfv117b",
        "fls_xc1hof4qbf6p",
        "fls_7pby13muw48o",
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "Renumbered moved to Directive 1.2",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Renumbered moved to Directive 1.2. Rust enums are more powerful (algebraic data types); Safe Rust prevents undefined behavior; unsafe requires careful handling"
    },
    {
      "guideline_id": "Rule 1.3",
      "guideline_title": "There shall be no occurrence of undefined or critical unspecified",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust prevents undefined behavior; unsafe requires careful handling"
    },
    {
      "guideline_id": "Rule 1.4",
      "guideline_title": "Emergent language features shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is specific to C versioning",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is specific to C versioning. Safe Rust prevents undefined behavior; unsafe requires careful handling"
    },
    {
      "guideline_id": "Rule 1.5",
      "guideline_title": "Obsolescent language features shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "this applies to deprecated APIs",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this applies to deprecated APIs. Safe Rust prevents undefined behavior; unsafe requires careful handling. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 2.1",
      "guideline_title": "A project shall not contain unreachable code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.9.3"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust compiler warns about unreachable code; has unreachable!() macro"
    },
    {
      "guideline_id": "Rule 2.2",
      "guideline_title": "A project shall not contain dead code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.9.3"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust compiler warns about unreachable code; has unreachable!() macro"
    },
    {
      "guideline_id": "Rule 2.3",
      "guideline_title": "Advisory A project should not contain unused type declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 2.4",
      "guideline_title": "A project should not contain unused tag declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no separate tag name space in Rust",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no separate tag name space in Rust. Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 2.5",
      "guideline_title": "A project should not contain unused macro definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 2.6",
      "guideline_title": "A function should not contain unused label declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_769b4p8v3cwu",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.4.4",
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no goto; uses labeled loops for complex control flow"
    },
    {
      "guideline_id": "Rule 2.7",
      "guideline_title": "A function should not contain unused parameters",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust compiler warns about unreachable code; has unreachable!() macro"
    },
    {
      "guideline_id": "Rule 2.8",
      "guideline_title": "A project should not contain unused object definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust uses pub visibility and modules instead of linkage; Rust compiler warns about unreachable code; has unreachable!() macro"
    },
    {
      "guideline_id": "Rule 3.1",
      "guideline_title": "The character sequences /* and // shall not be used within a",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_q8l2jza7d9xa"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.5"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "nested comments are fully supported",
      "confidence": "medium",
      "notes": "MISRA ADD-6: nested comments are fully supported. Rust has similar comment syntax plus doc comments"
    },
    {
      "guideline_id": "Rule 3.2",
      "guideline_title": "Line-splicing shall not be used in // comments",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_q8l2jza7d9xa"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar comment syntax plus doc comments"
    },
    {
      "guideline_id": "Rule 4.1",
      "guideline_title": "Octal and hexadecimal escape sequences shall be terminated",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar literals with type suffixes"
    },
    {
      "guideline_id": "Rule 4.2",
      "guideline_title": "Trigraphs should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar literals with type suffixes"
    },
    {
      "guideline_id": "Rule 5.1",
      "guideline_title": "External identifiers shall be distinct",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "no character limit, except in extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no character limit, except in extern “C”. Rust has similar scoping rules with explicit shadowing; Rust uses pub visibility and modules instead of linkage. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 5.2",
      "guideline_title": "Identifiers declared in the same scope and name space shall be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "no character limit, but has name spaces",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no character limit, but has name spaces. Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.3",
      "guideline_title": "An identifier declared in an inner scope shall not hide an identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this also applies to macro names",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this also applies to macro names. Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.4",
      "guideline_title": "Macro identifiers shall be distinct",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.5",
      "guideline_title": "Identifiers shall be distinct from macro names",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "macros and functions use different syntax",
      "confidence": "medium",
      "notes": "MISRA ADD-6: macros and functions use different syntax. Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.6",
      "guideline_title": "A typedef name shall be a unique identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.7",
      "guideline_title": "Required A tag name shall be a unique identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no separate tag name space in Rust",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no separate tag name space in Rust. Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.8",
      "guideline_title": "Required Identifiers that define objects or functions with external linkage shall be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.9",
      "guideline_title": "Advisory Identifiers that define objects or functions with internal linkage should",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 5.10",
      "guideline_title": "A reserved identifier or reserved macro name shall not be declared",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "only possible in some cases. Previously Rule 21.2",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only possible in some cases. Previously Rule 21.2. Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 6.1",
      "guideline_title": "Bit-fields shall only be declared with an appropriate type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_abp6tjbz8tpn",
        "fls_ohhsmifo0urd"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.5.6",
        "4.11.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "only provided as a library feature",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only provided as a library feature. Rust has similar struct semantics; Rust has no native bit-field syntax; use bitflags crate or manual bit manipulation"
    },
    {
      "guideline_id": "Rule 6.2",
      "guideline_title": "Single-bit named bit-fields shall not be of a signed type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_ohhsmifo0urd",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "4.11.2",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has similar struct semantics"
    },
    {
      "guideline_id": "Rule 6.3",
      "guideline_title": "A bit-field shall not be declared as a member of a union",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_abp6tjbz8tpn",
        "fls_ohhsmifo0urd",
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_jd1inwz7ulyw",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh",
        "fls_8wnyln2nmg4y"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.5.6",
        "4.11.2",
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.4",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar struct semantics; Rust has no native bit-field syntax; use bitflags crate or manual bit manipulation"
    },
    {
      "guideline_id": "Rule 7.1",
      "guideline_title": "Octal constants shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh",
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2",
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "Rust octals have a distinct prefix from decimals",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Rust octals have a distinct prefix from decimals. Rust has similar literals with type suffixes; Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C"
    },
    {
      "guideline_id": "Rule 7.2",
      "guideline_title": "A “u” or “U” suffix shall be applied to all integer constants that are",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "this is an error by default but can be enabled",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is an error by default but can be enabled. Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has similar literals with type suffixes"
    },
    {
      "guideline_id": "Rule 7.3",
      "guideline_title": "The lowercase character “l” shall not be used in a literal suffix",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce",
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh",
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2",
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch"
    },
    {
      "guideline_id": "Rule 7.4",
      "guideline_title": "A string literal shall not be assigned to an object unless the object’s",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k",
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Safe Rust String/str types prevent buffer overflows and ensure valid UTF-8; unsafe can use raw pointers"
    },
    {
      "guideline_id": "Rule 7.5",
      "guideline_title": "The argument of an integer constant macro shall have an appropriate",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 7.6",
      "guideline_title": "Required The small integer variants of the minimum-width integer constant",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_szibmtfv117b",
        "fls_xc1hof4qbf6p",
        "fls_7pby13muw48o",
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust enums are more powerful (algebraic data types)"
    },
    {
      "guideline_id": "Rule 8.1",
      "guideline_title": "Types shall be explicitly specified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 8.2",
      "guideline_title": "Required Function types shall be in prototype form with named parameters",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 8.3",
      "guideline_title": "All declarations of an object or function shall use the same names and",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "an extern declaration shall have a type compatible with the C declaration",
      "confidence": "medium",
      "notes": "MISRA ADD-6: an extern declaration shall have a type compatible with the C declaration. Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 8.4",
      "guideline_title": "A compatible declaration shall be visible when an object or function",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 8.5",
      "guideline_title": "An external object or function shall be declared once in one and only",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "may affect extern “C” declarations",
      "confidence": "medium",
      "notes": "MISRA ADD-6: may affect extern “C” declarations. Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 8.6",
      "guideline_title": "5.3 Comments",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_q8l2jza7d9xa",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.5",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern “C” declarations",
      "confidence": "medium",
      "notes": "MISRA ADD-6: may affect extern “C” declarations. Rust has similar comment syntax plus doc comments; Similar function semantics with stronger type checking. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 8.7",
      "guideline_title": "Advisory Functions and objects should not be defined with external linkage if they",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "items should not be declared pub if referenced in only one crate",
      "confidence": "medium",
      "notes": "MISRA ADD-6: items should not be declared pub if referenced in only one crate. Similar function semantics with stronger type checking; Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Rule 8.8",
      "guideline_title": "The static storage class specifier shall be used in all declarations of",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.1",
        "15.8",
        "15.8.1",
        "14.2",
        "14.4.3",
        "14.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has ownership-based lifetimes and static/const items"
    },
    {
      "guideline_id": "Rule 8.9",
      "guideline_title": "Advisory An object should be declared at block scope if its identifier only appears",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "17",
        "17.1",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has Mutex<T> and RwLock<T> with RAII guards"
    },
    {
      "guideline_id": "Rule 8.10",
      "guideline_title": "Section 5: Rules",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 8.11",
      "guideline_title": "Advisory When an array with external linkage is declared, its size should be",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8",
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "4.11.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 8.12",
      "guideline_title": "Within an enumerator list, the value of an implicitly-specified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_szibmtfv117b",
        "fls_xc1hof4qbf6p",
        "fls_7pby13muw48o",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust enums are more powerful (algebraic data types); Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 8.13",
      "guideline_title": "A pointer should point to a const-qualified type whenever possible",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 8.14",
      "guideline_title": "The restrict type qualifier shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_142vncdktbin",
        "fls_omaq7psg83n3",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7.3",
        "4.12.5",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust uses mut/immutable references; volatile via std::ptr::read/write_volatile (unsafe); Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 8.15",
      "guideline_title": "All declarations of an object with an explicit alignment specification",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "4.11.1",
        "4.11",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern “C” declarations",
      "confidence": "medium",
      "notes": "MISRA ADD-6: may affect extern “C” declarations. Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 8.16",
      "guideline_title": "The alignment specification of zero should not appear in an object",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.11.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "cannot be explicitly specified. Only ZSTs have this alignment",
      "confidence": "medium",
      "notes": "MISRA ADD-6: cannot be explicitly specified. Only ZSTs have this alignment. Rust has #[repr(align(N))] and std::mem::align_of; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 8.17",
      "guideline_title": "At most one explicit alignment specifier should appear in an object",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.11.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has #[repr(align(N))] and std::mem::align_of; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 8.18",
      "guideline_title": "There shall be no tentative definitions in a header file",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust uses pub visibility and modules instead of linkage; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 8.19",
      "guideline_title": "There should be no external declarations in a source file",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage"
    },
    {
      "guideline_id": "Rule 9.1",
      "guideline_title": "The value of an object with automatic storage duration shall not be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_3xvm61x0t251",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15.1",
        "15.8",
        "15.8.1",
        "15.2",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc but can be bypassed by unsafe",
      "confidence": "medium",
      "notes": "MISRA ADD-6: enforced by rustc but can be bypassed by unsafe. Rust has ownership-based lifetimes and static/const items; Safe Rust requires initialization before use; unsafe can use MaybeUninit"
    },
    {
      "guideline_id": "Rule 9.2",
      "guideline_title": "The initializer for an aggregate or union shall be enclosed in braces",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_jd1inwz7ulyw",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.4",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust requires initialization before use; unsafe can use MaybeUninit; Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Rule 9.3",
      "guideline_title": "Arrays shall not be partially initialized",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m",
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Safe Rust requires initialization before use; unsafe can use MaybeUninit"
    },
    {
      "guideline_id": "Rule 9.4",
      "guideline_title": "An element of an object shall not be initialized more than once",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m",
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA ADD-6: enforced by rustc. Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Safe Rust requires initialization before use; unsafe can use MaybeUninit"
    },
    {
      "guideline_id": "Rule 9.5",
      "guideline_title": "Required Where designated initializers are used to initialize an array object the",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m",
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Safe Rust requires initialization before use; unsafe can use MaybeUninit"
    },
    {
      "guideline_id": "Rule 9.6",
      "guideline_title": "Section 5: Rules",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust requires initialization before use; unsafe can use MaybeUninit"
    },
    {
      "guideline_id": "Rule 9.7",
      "guideline_title": "Atomic objects shall be appropriately initialized before being accessed",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp",
        "fls_vyc9vcuamlph",
        "fls_eiw4by8z75di"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "17.2",
        "17.1"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust requires initialization before use; unsafe can use MaybeUninit; Rust has std::sync::atomic with similar memory ordering. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 10.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's type system prevents implicit type conversions entirely. MISRA's 'essential type model' exists because C has implicit conversions between bool/char/numeric - Rust has none.",
      "guideline_title": "Operands shall not be of an inappropriate essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.7,
          "reason": "About enum discriminant memory layout, not type conversion rules",
          "fls_section": "4.11.2.1"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.67,
          "reason": "About &, |, ^ operators, not essential type mixing",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.65,
          "reason": "About unary negation, not type conversion",
          "fls_section": "6.5.4"
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_title": "Type Representation",
          "score": 0.64,
          "reason": "About memory layout, not conversion legality rules",
          "fls_section": "4.11.2"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.65,
          "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' All numeric conversions require explicit 'as' cast - no implicit type mixing possible.",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: Numeric widening and narrowing are NOT allowed implicitly. Only reference/pointer coercions are implicit. This prevents C's 'usual arithmetic conversions'.",
          "fls_section": "4.12.3"
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.45,
          "reason": "Per FLS: Operands of arithmetic operators must be the SAME type. Compiler error if types don't match. MISRA's essential type mixing cannot occur.",
          "fls_section": "6.5.5"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's char type cannot be used in arithmetic. Explicit cast to u32/i32 required for any numeric operations on character values.",
      "guideline_title": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations",
      "rejected_matches": [
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.59,
          "reason": "About unary operators, not char arithmetic",
          "fls_section": "6.5.4"
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.57,
          "reason": "About +=/-= etc., not char type restrictions",
          "fls_section": "6.5.12"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_wrvjizrqf3po",
          "fls_title": "Char Type",
          "score": 0.59,
          "reason": "Per FLS: Rust's char is a 4-byte Unicode scalar value, NOT a numeric type. Cannot participate in arithmetic without explicit conversion.",
          "fls_section": "4.3.2"
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Arithmetic operands must be numeric types of the same type. char is not a numeric type, so arithmetic on char is a compile error.",
          "fls_section": "6.5.5"
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.56,
          "reason": "Per FLS: Must use explicit 'as u32' or similar to convert char to numeric. Conversion is always explicit and intentional.",
          "fls_section": "6.5.10"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.3",
      "guideline_title": "The value of an expression shall not be assigned to an object with a narrower essential type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's type system prevents implicit narrowing conversions entirely. All numeric type conversions require explicit 'as' casts. The compiler rejects assignments between incompatible types.",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_section": "6.5.10",
          "fls_title": "Type Cast Expressions",
          "score": 0.681,
          "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' Numeric widening/narrowing requires explicit 'as' cast - not implicit."
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_section": "4.12.3",
          "fls_title": "Type Coercion",
          "score": 0.604,
          "reason": "Per FLS: Type coercion list does NOT include numeric widening/narrowing. Only reference/pointer coercions are implicit. This prevents MISRA's narrowing concern."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_lv7w7aalpwm5",
          "fls_section": "4.12.7",
          "fls_title": "Type Inference",
          "score": 0.64,
          "reason": "About how compiler infers types, not about conversion rules between types."
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "fls_section": "7.1",
          "fls_title": "Constants",
          "score": 0.589,
          "reason": "About constant declarations, not type conversion."
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "fls_section": "6.5.2",
          "fls_title": "Dereference Expression",
          "score": 0.587,
          "reason": "About pointer dereferencing, not numeric type conversion."
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.576,
          "reason": "About memory layout, not conversion legality rules."
        }
      ]
    },
    {
      "guideline_id": "Rule 10.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C's 'usual arithmetic conversions' don't exist in Rust. Operands must match exactly or code won't compile.",
      "guideline_title": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.69,
          "reason": "Shows Rust's explicit alternative but rule is about implicit conversions which don't exist",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.63,
          "reason": "Operators have same-type requirement but not the focus of this rule",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.6,
          "reason": "About overflow behavior, not type conversion",
          "fls_section": "6.23"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.66,
          "reason": "Per FLS: Operands must be the SAME type. 'i32 + i64' is a compile error. No implicit 'usual arithmetic conversions' exist in Rust.",
          "fls_section": "6.5.5"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit numeric widening or narrowing. The 'usual arithmetic conversions' from C simply don't exist in Rust.",
          "fls_section": "4.12.3"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust's 'as' casts can perform potentially inappropriate conversions (truncation, sign loss). Clippy lints 'cast_possible_truncation', 'cast_sign_loss' provide additional enforcement.",
      "guideline_title": "The value of an expression should not be cast to an inappropriate essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.61,
          "reason": "About enum layout, not cast appropriateness",
          "fls_section": "4.11.2.1"
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.57,
          "reason": "Unary operator, not type casting",
          "fls_section": "6.5.4"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.7,
          "reason": "Per FLS: Rust's 'as' casts allow numeric conversions including truncation and sign changes. While more restricted than C (no arbitrary pointer casts in safe Rust), numeric casts can still silently truncate. Advisory rule applies.",
          "fls_section": "6.5.10"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no implicit widening. Assignment requires exact type match. If wider arithmetic is needed, explicit cast before the operation is required.",
      "guideline_title": "The value of a composite expression shall not be assigned to an object with wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.56,
          "reason": "About struct initialization, not assignment widening",
          "fls_section": "6.11"
        },
        {
          "fls_id": "fls_3ut3biyra4r9",
          "fls_title": "Assignee Expressions",
          "score": 0.55,
          "reason": "About what can be assigned to, not type widening",
          "fls_section": "6.1.1"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_y4by2i8dl05o",
          "fls_title": "Assignment Expressions",
          "score": 0.58,
          "reason": "Per FLS: Assignment requires types to match exactly. Cannot assign u16 result to u32 variable without explicit cast.",
          "fls_section": "6.5.11"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: No implicit widening coercions. The C pattern of 'u32 x = u16_a + u16_b' (implicit widening) doesn't compile in Rust.",
          "fls_section": "4.12.3"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.45,
          "reason": "Per FLS: Overflow has defined behavior (panic or wrap), not UB. Even if narrow arithmetic overflows, behavior is deterministic.",
          "fls_section": "6.23"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.7",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Similar to 10.6 - Rust's same-type requirement for operators prevents mixing narrow composite expressions with wider operands.",
      "guideline_title": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.6,
          "reason": "Shows explicit alternative, but rule about implicit conversions which don't exist",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.59,
          "reason": "Same-type requirement but not the focus",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.54,
          "reason": "About overflow, not type widening",
          "fls_section": "6.23"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Both operands must be the SAME type. Mixing u16 composite with u32 operand is a compile error.",
          "fls_section": "6.5.5"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit widening. The scenario this rule prevents cannot occur because Rust rejects type mismatches.",
          "fls_section": "4.12.3"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.8",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust allows explicit widening casts after narrow arithmetic. The MISRA concern is partially mitigated by defined overflow behavior, but explicit casts can still mask programmer intent errors.",
      "guideline_title": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.54,
          "reason": "About bitwise operators, not casting composite expressions",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.5,
          "reason": "About type inference, not explicit casting",
          "fls_section": "4.12.2"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.66,
          "reason": "Per FLS: Rust allows explicit widening casts after narrow arithmetic: '(a + b) as u32' is legal. The cast is explicit, making intent clear, but can still mask overflow issues.",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.48,
          "reason": "Per FLS: Overflow has DEFINED behavior (panic in debug, wrap in release) - not UB like C. Mitigates but doesn't eliminate the MISRA concern about implementation-dependent results.",
          "fls_section": "6.23"
        }
      ]
    },
    {
      "guideline_id": "Rule 11.1",
      "guideline_title": "Conversions shall not be performed between a pointer to a function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "medium",
      "notes": "MISRA ADD-6: includes both safe `as` and unsafe `transmute` operations. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 11.2",
      "guideline_title": "Conversions shall not be performed between a pointer to an",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 11.3",
      "guideline_title": "Required A conversion shall not be performed between a pointer to object type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe"
    },
    {
      "guideline_id": "Rule 11.4",
      "guideline_title": "A conversion shall not be performed between a pointer to object and",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe"
    },
    {
      "guideline_id": "Rule 11.5",
      "guideline_title": "A conversion should not be performed from pointer to void into",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 11.6",
      "guideline_title": "A cast shall not be performed between pointer to void and an",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 11.7",
      "guideline_title": "Combined with Rule 11.4 MISRA C:2025",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "merged into Rule 11.4",
      "confidence": "medium",
      "notes": "MISRA ADD-6: merged into Rule 11.4. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 11.8",
      "guideline_title": "Required A conversion shall not remove any const, volatile or _Atomic qualification",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_vyc9vcuamlph",
        "fls_eiw4by8z75di",
        "fls_142vncdktbin",
        "fls_omaq7psg83n3",
        "fls_ppd1xwve3tr7",
        "fls_jep7p27kaqlp",
        "fls_3i4ou0dq64ny",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "17.2",
        "17.1",
        "4.7.3",
        "4.12.5",
        "4.7.2",
        "19",
        "4.7",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has std::sync::atomic with similar memory ordering; Rust uses mut/immutable references; volatile via std::ptr::read/write_volatile (unsafe)"
    },
    {
      "guideline_id": "Rule 11.9",
      "guideline_title": "The macro NULL shall be the only permitted form of integer null",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_szibmtfv117b",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.5.1",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "Rust does not have a null pointer constant",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Rust does not have a null pointer constant. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C"
    },
    {
      "guideline_id": "Rule 11.10",
      "guideline_title": "Required The _Atomic qualifier shall not be applied to the incomplete type void",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_vyc9vcuamlph",
        "fls_eiw4by8z75di",
        "fls_142vncdktbin",
        "fls_omaq7psg83n3",
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "17.2",
        "17.1",
        "4.7.3",
        "4.12.5",
        "4.7",
        "4.7.2",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has std::sync::atomic with similar memory ordering; Rust uses mut/immutable references; volatile via std::ptr::read/write_volatile (unsafe)"
    },
    {
      "guideline_id": "Rule 11.11",
      "guideline_title": "Required Pointers shall not be implicitly compared to NULL",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_szibmtfv117b",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_exe4zodlwfez",
        "fls_lv7w7aalpwm5"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.5.1",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA ADD-6: enforced by rustc. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust uses Option<T> instead of nullable pointers; raw pointers can be null in unsafe"
    },
    {
      "guideline_id": "Rule 12.1",
      "guideline_title": "The precedence of operators within expressions should be made",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 12.2",
      "guideline_title": "The right hand operand of a shift operator shall lie in the range zero",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 12.3",
      "guideline_title": "The comma operator should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 12.4",
      "guideline_title": "Evaluation of constant expressions should not lead to unsigned integer",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw",
        "fls_nrkd5wpi64oo",
        "fls_hv9jtycp0o1y",
        "fls_2ed4axpsy9u0",
        "fls_29tlg1vyqay2",
        "fls_jkab8eevzbte",
        "fls_h0dvogc64tfh",
        "fls_66m4rnbssgig"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "6",
        "6.1",
        "6.5",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2",
        "6.1.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this is either well-defined or will not occur",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is either well-defined or will not occur. Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has well-defined evaluation order in most cases. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 12.5",
      "guideline_title": "The sizeof operator shall not have an operand which is a function",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.11.1",
        "4.11",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has std::mem::size_of"
    },
    {
      "guideline_id": "Rule 12.6",
      "guideline_title": "Structure and union members of atomic objects shall not be directly",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_vyc9vcuamlph",
        "fls_eiw4by8z75di",
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_jd1inwz7ulyw",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh",
        "fls_8wnyln2nmg4y",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "17.2",
        "17.1",
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.4",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar struct semantics; Rust has std::sync::atomic with similar memory ordering"
    },
    {
      "guideline_id": "Rule 13.1",
      "guideline_title": "Initializer lists shall not contain persistent side effects",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "order of evaluation is strict in Rust",
      "confidence": "medium",
      "notes": "MISRA ADD-6: order of evaluation is strict in Rust. Safe Rust requires initialization before use; unsafe can use MaybeUninit; Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 13.2",
      "guideline_title": "Required The value of an expression and its persistent side effects shall be the",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "order of evaluation is strict in Rust",
      "confidence": "medium",
      "notes": "MISRA ADD-6: order of evaluation is strict in Rust. Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 13.3",
      "guideline_title": "A full expression containing an increment (++) or decrement (--)",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 13.4",
      "guideline_title": "Advisory The result of an assignment operator should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 13.5",
      "guideline_title": "Required The right hand operand of a logical && or || operator shall not contain",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 13.6",
      "guideline_title": "The operand of the sizeof operator shall not contain any expression",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw",
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5",
        "4.11.1",
        "4.11"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is not an expression operator in Rust",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is not an expression operator in Rust. Rust has well-defined evaluation order in most cases; Rust has std::mem::size_of"
    },
    {
      "guideline_id": "Rule 14.1",
      "guideline_title": "A loop counter shall not have essentially floating type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_b4xporvr64s",
        "fls_29tlg1vyqay2",
        "fls_1k9mkv7rbezi",
        "fls_nsvzzbldhq53",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.3.3.1",
        "2.4.4.2",
        "6.5.5",
        "6.5.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to while loops only",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to while loops only. Rust has similar floating point semantics to C (IEEE 754); Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Rule 14.2",
      "guideline_title": "Required A for loop shall be well-formed",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Rule 14.3",
      "guideline_title": "Controlling expressions shall not be invariant",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_szibmtfv117b",
        "fls_xc1hof4qbf6p",
        "fls_7pby13muw48o",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "6",
        "6.1",
        "6.5",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust enums are more powerful (algebraic data types); Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 14.4",
      "guideline_title": "The controlling expression of an if statement and the controlling",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA ADD-6: enforced by rustc. Rust has similar control flow with expressions; Rust has well-defined evaluation order in most cases"
    },
    {
      "guideline_id": "Rule 15.1",
      "guideline_title": "The goto statement should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_769b4p8v3cwu",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "14.4.4",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no goto; uses labeled loops for complex control flow; Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Rule 15.2",
      "guideline_title": "The goto statement shall jump to a label declared later in the same",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_769b4p8v3cwu",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "14.4.4",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no goto; uses labeled loops for complex control flow; Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Rule 15.3",
      "guideline_title": "Any label referenced by a goto statement shall be declared in the",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_769b4p8v3cwu",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.1",
        "6.5.2",
        "14.4.4",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Core Rust concept for safe memory access, applies to all Rust; Rust has no goto; uses labeled loops for complex control flow"
    },
    {
      "guideline_id": "Rule 15.4",
      "guideline_title": "There should be no more than one break or goto statement used to",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_769b4p8v3cwu"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has no goto; uses labeled loops for complex control flow"
    },
    {
      "guideline_id": "Rule 15.5",
      "guideline_title": "A function should have a single point of exit at the end",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_769b4p8v3cwu"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16.1",
        "16.2",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "no longer endorsed by MISRA",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no longer endorsed by MISRA. Similar function semantics with stronger type checking; Rust has panic! and abort for abnormal termination"
    },
    {
      "guideline_id": "Rule 15.6",
      "guideline_title": "Required The body of an iteration-statement or a selection-statement shall be a",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_769b4p8v3cwu"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has no goto; uses labeled loops for complex control flow"
    },
    {
      "guideline_id": "Rule 15.7",
      "guideline_title": "All if … else if constructs shall be terminated with an else statement",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_769b4p8v3cwu"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust has similar struct semantics; Rust has similar control flow with expressions"
    },
    {
      "guideline_id": "Rule 16.1",
      "guideline_title": "All switch statements shall be well-formed",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch"
    },
    {
      "guideline_id": "Rule 16.2",
      "guideline_title": "A switch label shall only be used when the most closely-enclosing",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_769b4p8v3cwu",
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has no goto; uses labeled loops for complex control flow"
    },
    {
      "guideline_id": "Rule 16.3",
      "guideline_title": "Every switch-clause shall be appropriately terminated",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch"
    },
    {
      "guideline_id": "Rule 16.4",
      "guideline_title": "Section 5: Rules",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "a corresponding match expression must be complete",
      "confidence": "medium",
      "notes": "MISRA ADD-6: a corresponding match expression must be complete. Rust match is exhaustive and more powerful than C switch"
    },
    {
      "guideline_id": "Rule 16.5",
      "guideline_title": "A default label shall appear as either the first or the last switch label of",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_769b4p8v3cwu",
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "irrefutable pattern causes a subsequent refutable one to be unreachable",
      "confidence": "medium",
      "notes": "MISRA ADD-6: irrefutable pattern causes a subsequent refutable one to be unreachable. Rust has similar control flow with expressions; Rust has no goto; uses labeled loops for complex control flow"
    },
    {
      "guideline_id": "Rule 16.6",
      "guideline_title": "Every switch statement shall have at least two switch-clauses",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch"
    },
    {
      "guideline_id": "Rule 16.7",
      "guideline_title": "A switch-expression shall not have essentially Boolean type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch"
    },
    {
      "guideline_id": "Rule 17.1",
      "guideline_title": "The standard header file <stdarg.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style variadic functions; use generics or extern for FFI; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 17.2",
      "guideline_title": "Functions shall not call themselves, either directly or indirectly",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_3gapgqys3ceb"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.12.1"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust allows recursion; stack overflow is runtime behavior"
    },
    {
      "guideline_id": "Rule 17.3",
      "guideline_title": "A function shall not be declared implicitly",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 17.4",
      "guideline_title": "All exit paths from a function with non-void return type shall have an",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16.1",
        "16.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "the return keyword is not needed to return a value in Rust, only to exit",
      "confidence": "medium",
      "notes": "MISRA ADD-6: the return keyword is not needed to return a value in Rust, only to exit. Similar function semantics with stronger type checking; Rust has panic! and abort for abnormal termination"
    },
    {
      "guideline_id": "Rule 17.5",
      "guideline_title": "The function argument corresponding to a parameter declared to",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 17.6",
      "guideline_title": "Combined with Rule 17.5 MISRA C:2025",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no longer endorsed by MISRA",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no longer endorsed by MISRA. Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 17.7",
      "guideline_title": "The value returned by a function having non-void return type shall be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 17.8",
      "guideline_title": "A function parameter should not be modified",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "this cannot be done accidentally without declaring parameters `mut`",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this cannot be done accidentally without declaring parameters `mut`. Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 17.9",
      "guideline_title": "A function declared with a _Noreturn function specifier shall not return",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "this is expressed with the `!` (Never) type, and enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is expressed with the `!` (Never) type, and enforced by rustc. Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 17.10",
      "guideline_title": "Required A function declared with a _Noreturn function specifier shall have void",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 17.11",
      "guideline_title": "A function that never returns should be declared with a _Noreturn",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "a non-returning function can be declared to return a value type",
      "confidence": "medium",
      "notes": "MISRA ADD-6: a non-returning function can be declared to return a value type. Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 17.12",
      "guideline_title": "Advisory A function identifier should only be used with either a preceding &, or",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 17.13",
      "guideline_title": "A function type shall not be type qualified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI"
    },
    {
      "guideline_id": "Rule 18.1",
      "guideline_title": "A pointer resulting from arithmetic on a pointer operand shall address",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_1k9mkv7rbezi",
        "fls_3qnpv2z7yjil",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "4.3.3.2",
        "6.5.6",
        "6.5.7",
        "4.3",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "medium",
      "notes": "MISRA ADD-6: by unsafe API. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust uses bounds-checked indexing; pointer arithmetic requires unsafe. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.2",
      "guideline_title": "Subtraction between pointers shall only be applied to pointers that",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_1k9mkv7rbezi",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "medium",
      "notes": "MISRA ADD-6: by unsafe API. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust uses bounds-checked indexing; pointer arithmetic requires unsafe. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.3",
      "guideline_title": "The relational operators >, >=, < and <= shall not be applied to",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_1k9mkv7rbezi",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust uses bounds-checked indexing; pointer arithmetic requires unsafe"
    },
    {
      "guideline_id": "Rule 18.4",
      "guideline_title": "The +, -, += and -= operators should not be applied to an expression",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw",
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_1k9mkv7rbezi",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6",
        "6.1",
        "6.5",
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "applies to use of the unsafe API",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to use of the unsafe API. Rust has well-defined evaluation order in most cases; Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.5",
      "guideline_title": "Declarations should contain no more than two levels of pointer",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_1k9mkv7rbezi",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking"
    },
    {
      "guideline_id": "Rule 18.6",
      "guideline_title": "The address of an object with automatic or thread-local storage shall",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_1k9mkv7rbezi",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "17",
        "17.1",
        "17.2",
        "15.1",
        "15.8",
        "15.8.1",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.7",
      "guideline_title": "Flexible array members shall not be declared",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m",
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_1k9mkv7rbezi"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Rust has similar struct semantics"
    },
    {
      "guideline_id": "Rule 18.8",
      "guideline_title": "5.14 Control statement expressions",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw",
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_1k9mkv7rbezi",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5",
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases; Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks"
    },
    {
      "guideline_id": "Rule 18.9",
      "guideline_title": "An object with temporary lifetime shall not undergo array-to-pointer",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_1k9mkv7rbezi"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.1",
        "15.8",
        "15.8.1",
        "6.5.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust performs bounds checking on array access; unsafe can use unchecked access"
    },
    {
      "guideline_id": "Rule 18.10",
      "guideline_title": "Pointers to variably-modified array types shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_xinykul167l",
        "fls_qfsfnql1t7m",
        "fls_1k9mkv7rbezi"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "6.5.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust performs bounds checking on array access; unsafe can use unchecked access"
    },
    {
      "guideline_id": "Rule 19.1",
      "guideline_title": "An object shall not be assigned or copied to an overlapping object",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Safe Rust's borrow checker prevents overlapping mutable references at compile time. FLS 15.3 explicitly states 'no other reference shall refer to a value that overlaps with the referent of the mutable reference'. In unsafe Rust, aliasing mutable references is explicitly UB.",
      "accepted_matches": [
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_section": "15.3",
          "fls_title": "References",
          "score": 0.526,
          "reason": "PRIMARY: Per FLS fls_i1ny0k726a4a: 'While a mutable reference is active, no other reference shall refer to a value that overlaps with the referent of the mutable reference.' Also defines UB: 'It is undefined behavior to access a value through aliasing mutable references from unsafe context.'"
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_section": "15.4",
          "fls_title": "Borrowing",
          "score": 0.492,
          "reason": "Per FLS fls_kxws4zmaahj6: 'Borrowing a field of a union type borrows all remaining fields using the same lifetime.' This treats union fields as overlapping memory."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_94a8v54bufn8",
          "fls_section": "7",
          "fls_title": "Values",
          "score": 0.525,
          "reason": "Chapter-level section too broad. Contains value overlap definition but the enforceable rules are in 15.3 References."
        },
        {
          "fls_id": "fls_9beohh5475s2",
          "fls_section": "6.5.11.2",
          "fls_title": "Destructuring Assignment",
          "score": 0.519,
          "reason": "About tuple destructuring syntax, not memory overlap safety concerns."
        }
      ]
    },
    {
      "guideline_id": "Rule 19.2",
      "guideline_title": "The union keyword should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "Rust unions exist but have strict type restrictions (Copy/ManuallyDrop field types only). Reading any union field requires unsafe context. FLS defines implementation-defined and UB scenarios similar to MISRA's concerns.",
      "accepted_matches": [
        {
          "fls_id": "fls_fmdn7n7s413d",
          "fls_section": "4.5.3",
          "fls_title": "Union Types",
          "score": 0.69,
          "reason": "PRIMARY: Defines union type rules including field type restrictions per FLS fls_ZJG2Q6lJYXhY: 'The type of a union field shall be either: A copy type, or a mutable reference type, or core::mem::ManuallyDrop...'"
        },
        {
          "fls_id": "fls_cmq8ogs84ivh",
          "fls_section": "4.11.2.3",
          "fls_title": "Union Type Representation",
          "score": 0.691,
          "reason": "Defines union memory layout - size is max of all fields, all fields share common storage. Addresses MISRA's padding/alignment/endianness concerns."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_section": "19",
          "fls_title": "Unsafety",
          "score": 0.0,
          "reason": "MANUAL: Per FLS fls_ucghxcnpaq2t: 'Accessing a field of a union, other than to assign to it' is listed as an unsafe operation requiring unsafe context."
        },
        {
          "fls_id": "fls_18k3uajrgq5f",
          "fls_section": "6.13",
          "fls_title": "Field Access Expressions",
          "score": 0.0,
          "reason": "MANUAL: Per FLS fls_kddnnz8uc15b: 'Reading the selected field of a union shall require unsafe context.' This is the enforcement mechanism for MISRA's concern."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "fls_section": "4.11.2.2",
          "fls_title": "Struct Type Representation",
          "score": 0.591,
          "reason": "About struct layout, not union - high similarity due to shared 'representation' terminology."
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_section": "4.11.1",
          "fls_title": "Type Layout",
          "score": 0.561,
          "reason": "General layout section. Union-specific content is in child section 4.11.2.3 which is more specific."
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.554,
          "reason": "Parent section. Child 4.11.2.3 (Union Type Representation) is more specific and already accepted."
        },
        {
          "fls_id": "fls_wrvjizrqf3po",
          "fls_section": "4.3.2",
          "fls_title": "Char Type",
          "score": 0.509,
          "reason": "About char type, not unions. High score likely due to type representation terminology overlap."
        }
      ]
    },
    {
      "guideline_id": "Rule 19.3",
      "guideline_title": "A union member shall not be read unless it has been previously set",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "FLS explicitly defines UB for reading union fields with invalid data (fls_Vani4665hiJY). Reading any union field requires unsafe context. Rust treats union field read-after-different-write as transmute, matching MISRA's type punning concern.",
      "accepted_matches": [
        {
          "fls_id": "fls_fmdn7n7s413d",
          "fls_section": "4.5.3",
          "fls_title": "Union Types",
          "score": 0.662,
          "reason": "PRIMARY: Defines union field type restrictions (Copy/ManuallyDrop) which limit what can be stored and safely reinterpreted."
        },
        {
          "fls_id": "fls_18k3uajrgq5f",
          "fls_section": "6.13",
          "fls_title": "Field Access Expressions",
          "score": 0.0,
          "reason": "MANUAL: CRITICAL - Contains the explicit UB definition per FLS fls_Vani4665hiJY: 'It is undefined behavior reading the selected field of a union type when it contains data that is invalid for the selected field's type.' Also defines transmute equivalence for union field access (fls_t6xmsm2nk1bc)."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_section": "19",
          "fls_title": "Unsafety",
          "score": 0.524,
          "reason": "Per FLS fls_ucghxcnpaq2t: Union field access (except assignment) is an unsafe operation. This forces explicit acknowledgment of the type punning risk."
        },
        {
          "fls_id": "fls_cmq8ogs84ivh",
          "fls_section": "4.11.2.3",
          "fls_title": "Union Type Representation",
          "score": 0.644,
          "reason": "Per FLS: 'All union fields share a common storage.' This is the memory model underlying MISRA's concern about reading unwritten members."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "fls_section": "4.11.2.2",
          "fls_title": "Struct Type Representation",
          "score": 0.587,
          "reason": "About struct layout, not union. High score due to shared 'representation' terminology."
        },
        {
          "fls_id": "fls_8tsynkj2cufj",
          "fls_section": "6.11",
          "fls_title": "Struct Expressions",
          "score": 0.529,
          "reason": "About struct initialization syntax, not union field access."
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_section": "15.3",
          "fls_title": "References",
          "score": 0.524,
          "reason": "About reference aliasing rules, not union type punning. More relevant to Rule 19.1."
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "fls_section": "15.5",
          "fls_title": "Passing Conventions",
          "score": 0.524,
          "reason": "About move/copy semantics during value transfer, not union field access."
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_section": "4.11.1",
          "fls_title": "Type Layout",
          "score": 0.541,
          "reason": "General layout section. Child section 4.11.2.3 is more specific for unions."
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.52,
          "reason": "Parent section. Child 4.11.2.3 already accepted and is more specific."
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "fls_section": "6.5.2",
          "fls_title": "Dereference Expression",
          "score": 0.516,
          "reason": "About pointer dereferencing, not union field access. Different unsafe operation."
        }
      ]
    },
    {
      "guideline_id": "Rule 20.1",
      "guideline_title": "#include directives should only be preceded by preprocessor",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "rules specific to the C preprocessor do not apply to Rust",
      "confidence": "medium",
      "notes": "MISRA ADD-6: rules specific to the C preprocessor do not apply to Rust. Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.2",
      "guideline_title": "The ', \" or \\ characters and the /* or // character sequences shall",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.3",
      "guideline_title": "The #include directive shall be followed by either a <filename> or",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 20.4",
      "guideline_title": "A macro shall not be defined with the same name as a keyword",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "possible with raw identifiers but the compiler prevents visual conflicts",
      "confidence": "medium",
      "notes": "MISRA ADD-6: possible with raw identifiers but the compiler prevents visual conflicts. Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 20.5",
      "guideline_title": "#undef should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.6",
      "guideline_title": "Tokens that look like a preprocessing directive shall not occur within a",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.7",
      "guideline_title": "Expressions resulting from the expansion of macro parameters shall",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "possible to express with procedural macros only, not macro_rules",
      "confidence": "medium",
      "notes": "MISRA ADD-6: possible to express with procedural macros only, not macro_rules. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.8",
      "guideline_title": "The controlling expression of a #if or #elif preprocessing directive",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.9",
      "guideline_title": "Required All identifiers used in the controlling expression of #if or #elif",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has similar scoping rules with explicit shadowing"
    },
    {
      "guideline_id": "Rule 20.10",
      "guideline_title": "The # and ## preprocessor operators should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.11",
      "guideline_title": "Section 5: Rules",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.12",
      "guideline_title": "Required A macro parameter used as an operand to the # or ## operators, which",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.13",
      "guideline_title": "A line whose first token is # shall be a valid preprocessing directive",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.14",
      "guideline_title": "All #else, #elif and #endif preprocessor directives shall reside in the",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 20.15",
      "guideline_title": "5.6 Types",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "previously Rule 21.1",
      "confidence": "medium",
      "notes": "MISRA ADD-6: previously Rule 21.1. Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 21.1",
      "guideline_title": "Renumbered as Rule 20.15 MISRA C:2025",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_szibmtfv117b",
        "fls_xc1hof4qbf6p",
        "fls_7pby13muw48o",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "Renumbered moved to rule 20.15",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Renumbered moved to rule 20.15. Rust enums are more powerful (algebraic data types); Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs"
    },
    {
      "guideline_id": "Rule 21.2",
      "guideline_title": "Renumbered as Rule 5.10 MISRA C:2025",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_szibmtfv117b",
        "fls_xc1hof4qbf6p",
        "fls_7pby13muw48o",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "Renumbered moved to Rule 5.10",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Renumbered moved to Rule 5.10. Rust enums are more powerful (algebraic data types); Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs"
    },
    {
      "guideline_id": "Rule 21.3",
      "guideline_title": "The memory allocation and deallocation functions of <stdlib.h>",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Similar function semantics with stronger type checking. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.4",
      "guideline_title": "The standard header file <setjmp.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Rust has no setjmp/longjmp; uses panic/catch_unwind or Result; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.5",
      "guideline_title": "The standard header file <signal.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Rust has no native signal handling; use platform-specific crates; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.6",
      "guideline_title": "The Standard Library input/output functions shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.7",
      "guideline_title": "The Standard Library functions atof, atoi, atol and atoll of <stdlib.h>",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.8",
      "guideline_title": "The Standard Library termination functions of <stdlib.h> shall not",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.9",
      "guideline_title": "The Standard Library functions bsearch and qsort of <stdlib.h>",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.10",
      "guideline_title": "The Standard Library time and date functions shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.11",
      "guideline_title": "The standard header file <tgmath.h> should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no external interface. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust has no setjmp/longjmp; uses panic/catch_unwind or Result"
    },
    {
      "guideline_id": "Rule 21.12",
      "guideline_title": "The standard header file <fenv.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust has no setjmp/longjmp; uses panic/catch_unwind or Result. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.13",
      "guideline_title": "Any value passed to a function in <ctype.h> shall be representable",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.14",
      "guideline_title": "Required The Standard Library function memcmp shall not be used to compare",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.15",
      "guideline_title": "The pointer arguments to the Standard Library functions memcpy",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.16",
      "guideline_title": "The pointer arguments to the Standard Library function memcmp",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.17",
      "guideline_title": "Use of the string handling functions from <string.h> shall not result",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Safe Rust String/str types prevent buffer overflows and ensure valid UTF-8; unsafe can use raw pointers. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.18",
      "guideline_title": "Mandatory The size_t argument passed to any function in <string.h> shall have an",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k",
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2",
        "4.11.1",
        "4.11",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Safe Rust String/str types prevent buffer overflows and ensure valid UTF-8; unsafe can use raw pointers. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.19",
      "guideline_title": "Mandatory The pointers returned by the Standard Library functions localeconv",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.20",
      "guideline_title": "The pointer returned by the Standard Library functions asctime, ctime",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.21",
      "guideline_title": "The Standard Library function system of <stdlib.h> shall not be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.22",
      "guideline_title": "All operand arguments to any type-generic macros declared in",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "12",
        "12.1",
        "12.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no external interface. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 21.23",
      "guideline_title": "All operand arguments to any multi-argument type-generic macros",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "12",
        "12.1",
        "12.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no external interface. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros"
    },
    {
      "guideline_id": "Rule 21.24",
      "guideline_title": "The random number generator functions of <stdlib.h> shall not be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 21.25",
      "guideline_title": "All memory synchronization operations shall be executed in",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has std::sync::atomic with similar memory ordering"
    },
    {
      "guideline_id": "Rule 21.26",
      "guideline_title": "The Standard Library function mtx_timedlock() shall only be invoked on",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "17",
        "17.1",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.1",
      "guideline_title": "All resources obtained dynamically by means of Standard Library",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_u2mzjgiwbkz0",
        "fls_4jiw35pan7vn",
        "fls_rm4ncoopcdvj",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.6",
        "15.7",
        "15.8",
        "15",
        "15.1",
        "15.2",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to resources acquired through FFI only",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to resources acquired through FFI only. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.2",
      "guideline_title": "A block of memory shall only be freed if it was allocated by means of a",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust has similar control flow with expressions. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.3",
      "guideline_title": "The same file shall not be open for read and write access at the same",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Rust has similar control flow with expressions; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.4",
      "guideline_title": "There shall be no attempt to write to a stream which has been",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust uses std::io and std::fs; different API design. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.5",
      "guideline_title": "Mandatory A pointer to a FILE object shall not be dereferenced",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh",
        "fls_8wnyln2nmg4y",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Core Rust concept for safe memory access, applies to all Rust. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.6",
      "guideline_title": "Mandatory The value of a pointer to a FILE shall not be used after the associated",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.7",
      "guideline_title": "The macro EOF shall only be compared with the unmodified return",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.8",
      "guideline_title": "The value of errno shall be set to zero prior to a call to an errno-",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_dzq9cdz4ibsz",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi",
        "fls_pocsh1neugpc",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16",
        "16.1",
        "16.2",
        "6.5.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.9",
      "guideline_title": "The value of errno shall be tested against zero after calling an errno-",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_dzq9cdz4ibsz",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi",
        "fls_pocsh1neugpc",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16",
        "16.1",
        "16.2",
        "6.5.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.10",
      "guideline_title": "The value of errno shall only be tested when the last function to be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_dzq9cdz4ibsz",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi",
        "fls_pocsh1neugpc",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16",
        "16.1",
        "16.2",
        "6.5.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.11",
      "guideline_title": "A thread that was previously either joined or detached shall not be",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs"
    },
    {
      "guideline_id": "Rule 22.12",
      "guideline_title": "Thread objects, thread synchronization objects, and thread-specific",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.13",
      "guideline_title": "Thread objects, thread synchronization objects and thread-specific",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards"
    },
    {
      "guideline_id": "Rule 22.14",
      "guideline_title": "Thread synchronization objects shall be initialized before being",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to creating synchronization objects before threads that use them",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to creating synchronization objects before threads that use them. Safe Rust requires initialization before use; unsafe can use MaybeUninit; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass"
    },
    {
      "guideline_id": "Rule 22.15",
      "guideline_title": "Thread synchronization objects and thread-specific storage pointers",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to releasing synchronization objects after threads that use them",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to releasing synchronization objects after threads that use them. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass"
    },
    {
      "guideline_id": "Rule 22.16",
      "guideline_title": "Required All mutex objects locked by a thread shall be explicitly unlocked by the",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.17",
      "guideline_title": "No thread shall unlock a mutex or call cnd_wait() or cnd_timedwait() for",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern “C”",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust has similar control flow with expressions. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 22.18",
      "guideline_title": "Non-recursive mutexes shall not be recursively locked",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_hbbek3z4wtcs",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.12.1",
        "4.6",
        "17",
        "17.1",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust allows recursion; stack overflow is runtime behavior; Rust has Mutex<T> and RwLock<T> with RAII guards"
    },
    {
      "guideline_id": "Rule 22.19",
      "guideline_title": "A condition variable shall be associated with at most one mutex object",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has Mutex<T> and RwLock<T> with RAII guards; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs"
    },
    {
      "guideline_id": "Rule 22.20",
      "guideline_title": "Thread-specific storage pointers shall be created before being",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass"
    },
    {
      "guideline_id": "Rule 23.1",
      "guideline_title": "A generic selection should only be expanded from a macro",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic"
    },
    {
      "guideline_id": "Rule 23.2",
      "guideline_title": "A generic selection that is not expanded from a macro shall not",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic"
    },
    {
      "guideline_id": "Rule 23.3",
      "guideline_title": "A generic selection should contain at least one non-default",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.14",
        "5.4.5",
        "5.2",
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust match is exhaustive and more powerful than C switch; Rust uses generics and traits instead of _Generic"
    },
    {
      "guideline_id": "Rule 23.4",
      "guideline_title": "A generic association shall list an appropriate type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust uses generics and traits instead of _Generic"
    },
    {
      "guideline_id": "Rule 23.5",
      "guideline_title": "Section 5: Rules",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust uses generics and traits instead of _Generic"
    },
    {
      "guideline_id": "Rule 23.6",
      "guideline_title": "The controlling expression of a generic selection shall have an",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5",
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases; Rust uses generics and traits instead of _Generic"
    },
    {
      "guideline_id": "Rule 23.7",
      "guideline_title": "Advisory A generic selection that is expanded from a macro should evaluate its",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic"
    },
    {
      "guideline_id": "Rule 23.8",
      "guideline_title": "A default association shall appear as either the first or the last",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.14",
        "5.4.5",
        "5.2",
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust match is exhaustive and more powerful than C switch; Rust uses generics and traits instead of _Generic"
    }
  ]
}