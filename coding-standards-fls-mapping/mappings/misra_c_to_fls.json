{
  "standard": "MISRA-C",
  "standard_version": "2025",
  "fls_version": "1.0 (2024)",
  "mapping_date": "2025-12-31",
  "methodology": "Semantic embedding similarity + manual verification. High confidence mappings verified against MISRA rationale and FLS content.",
  "statistics": {
    "total_guidelines": 211,
    "mapped": 119,
    "unmapped": 0,
    "not_applicable": 91,
    "rust_prevents": 2,
    "with_fls_references": 200
  },
  "mappings": [
    {
      "guideline_id": "Dir 1.1",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust prevents undefined behavior; unsafe requires careful handling",
      "guideline_title": "Any implementation-defined behaviour on which the output of the program depends shall be documented and understood C90 [Annex G.3], C99 [Annex J.3], C11 [Annex J.3]"
    },
    {
      "guideline_id": "Dir 1.2",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "misra_rust_comment": "previously Rule 1.2",
      "notes": "MISRA ADD-6: previously Rule 1.2",
      "guideline_title": "The use of language extensions should be minimized"
    },
    {
      "guideline_id": "Dir 2.1",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "notes": "Automated mapping - requires manual review",
      "guideline_title": "All source files shall compile without any compilation errors"
    },
    {
      "guideline_id": "Dir 3.1",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "notes": "Automated mapping - requires manual review",
      "guideline_title": "All code shall be traceable to documented requirements [DO-178C Section 6.4.4.3.d]"
    },
    {
      "guideline_id": "Dir 4.1",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "misra_rust_comment": "often in the form of panics",
      "notes": "MISRA ADD-6: often in the form of panics",
      "guideline_title": "Run-time failures shall be minimized C90 [Undefined 15, 19, 26, 30-32, 94] C99 [Undefined 15-17, 33, 40, 43-45, 48, 49, 113] C11 [Undefined 17-19, 36, 43, 45a, 46-48, 51, 52, 119]"
    },
    {
      "guideline_id": "Dir 4.2",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_a3joqzqp1v9d",
        "fls_e0896uk0mdyl",
        "fls_lv19xysy1f7e"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "22",
        "22.1",
        "22.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has asm! macro for inline assembly; always requires unsafe",
      "guideline_title": "All usage of assembly language should be documented"
    },
    {
      "guideline_id": "Dir 4.3",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_a3joqzqp1v9d",
        "fls_e0896uk0mdyl",
        "fls_lv19xysy1f7e"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "22",
        "22.1",
        "22.2"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust has asm! macro for inline assembly; always requires unsafe",
      "guideline_title": "Assembly language shall be encapsulated and isolated"
    },
    {
      "guideline_id": "Dir 4.4",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_q8l2jza7d9xa"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.5"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust has similar comment syntax plus doc comments",
      "guideline_title": "Sections of code should not be \u201ccommented out\u201d"
    },
    {
      "guideline_id": "Dir 4.5",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "\u201cambiguity\u201d is determined by the project",
      "confidence": "medium",
      "notes": "MISRA ADD-6: \u201cambiguity\u201d is determined by the project. Rust has similar scoping rules with explicit shadowing",
      "guideline_title": "Identifiers in the same name space with overlapping visibility should be typographically unambiguous"
    },
    {
      "guideline_id": "Dir 4.6",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.11.1",
        "4.11"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "all primitive types already fulfil this",
      "confidence": "medium",
      "notes": "MISRA ADD-6: all primitive types already fulfil this. Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has std::mem::size_of",
      "guideline_title": "typedefs that indicate size and signedness should be used in place of the basic integer types"
    },
    {
      "guideline_id": "Dir 4.7",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "prefer Option, Result, etc.",
      "confidence": "medium",
      "notes": "MISRA ADD-6: prefer Option, Result, etc.. Similar function semantics with stronger type checking; Rust has similar control flow with expressions",
      "guideline_title": "If a function returns error information, then that error information shall be tested"
    },
    {
      "guideline_id": "Dir 4.8",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh",
        "fls_8wnyln2nmg4y"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Core Rust concept for safe memory access, applies to all Rust",
      "guideline_title": "If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden"
    },
    {
      "guideline_id": "Dir 4.9",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.1",
        "6.5.2",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Core Rust concept for safe memory access, applies to all Rust; Similar function semantics with stronger type checking",
      "guideline_title": "A function should be used in preference to a function-like macro where they are interchangeable [Koenig 78\u201381]"
    },
    {
      "guideline_id": "Dir 4.10",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases",
      "guideline_title": "Precautions shall be taken in order to prevent the contents of a header file being included more than once"
    },
    {
      "guideline_id": "Dir 4.11",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking",
      "guideline_title": "The validity of values passed to library functions shall be checked C90 [Undefined 60, 63, 96; Implementation G.3.14(4-6)] C99 [Unspecified 30, 31, 44, 47a, 47b, 48\u201350; Undefined 102, 103, 107, 112, 180, 181, 183, 187, 189; Implementation J.3.12(8\u201311)] C11 [Unspecified 30, 31, 44, 52\u201356; Undefined 108, 109, 113, 118, 191, 192, 194, 199, 201; Implementation J.3.12(8\u201314)]"
    },
    {
      "guideline_id": "Dir 4.12",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs",
      "guideline_title": "Dynamic memory allocation shall not be used"
    },
    {
      "guideline_id": "Dir 4.13",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_u2mzjgiwbkz0",
        "fls_4jiw35pan7vn",
        "fls_rm4ncoopcdvj"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.6",
        "15.7",
        "15.8"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Similar function semantics with stronger type checking",
      "guideline_title": "Functions which are designed to provide operations on a resource should be called in an appropriate sequence"
    },
    {
      "guideline_id": "Dir 4.14",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust uses pub visibility and modules instead of linkage; Rust has explicit FFI support with extern blocks; calling extern fn is unsafe",
      "guideline_title": "The validity of values received from external sources shall be checked C90 [Undefined 15, 19, 26, 30, 31, 32, 94] C99 [Undefined 15, 16, 33, 40, 43\u201345, 48, 49, 113] C11 [Undefined 17, 18, 36, 43, 46\u201348, 51, 52, 119]"
    },
    {
      "guideline_id": "Dir 4.15",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_b4xporvr64s",
        "fls_29tlg1vyqay2",
        "fls_1k9mkv7rbezi",
        "fls_nsvzzbldhq53",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.1",
        "2.4.4.2",
        "6.5.5",
        "6.5.7",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "Rust implements IEEE-754",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Rust implements IEEE-754. Rust has similar floating point semantics to C (IEEE 754); Rust has well-defined evaluation order in most cases",
      "guideline_title": "Evaluation of floating-point expressions shall not lead to the undetected generation of infinities and NaNs C90 [Implementation 20, 22] C99 [Unspecified 30, 46, 47, 47a, 47b, 48, 49; Implementation J.3.6(2), J.3.6(5)] C11 [Unspecified 30, 52, 53, 56, 57; Implementation J.3.6(2), J.3.6(5)]"
    },
    {
      "guideline_id": "Dir 5.1",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "not all safe Rust types are race-free",
      "confidence": "medium",
      "notes": "MISRA ADD-6: not all safe Rust types are race-free. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass",
      "guideline_title": "There shall be no data races between threads C11 [Undefined 5]"
    },
    {
      "guideline_id": "Dir 5.2",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards",
      "guideline_title": "There shall be no deadlocks between threads"
    },
    {
      "guideline_id": "Dir 5.3",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass",
      "guideline_title": "There shall be no dynamic thread creation C11 [Undefined 5, 9, 10, 11]"
    },
    {
      "guideline_id": "Rule 1.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_99b7xi1bkgih",
        "fls_10yukmkhl0ng"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Code must conform to C standard syntax/constraints. Rust: Code must conform to Rust syntax. rustc enforces language rules. Edition system allows controlled language evolution. Similar principle of standard conformance.",
      "guideline_title": "The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation\u2019s translation limits [MISRA Guidelines Table 3], [IEC 61508-7: Table C.1], [ISO 26262-6: Table 1]"
    },
    {
      "guideline_id": "Rule 1.3",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: No undefined/critical unspecified behavior. Rust: Safe Rust has no UB by design. Unsafe Rust can have UB (see Rustonomicon). Miri can detect some UB. Safe Rust completely prevents UB; unsafe requires careful review.",
      "guideline_title": "There shall be no occurrence of undefined or critical unspecified behaviour"
    },
    {
      "guideline_id": "Rule 1.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_9cd746qe40ag"
      ],
      "fls_rationale_type": "rust_alternative",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is specific to C versioning",
      "confidence": "high",
      "notes": "MISRA: Don't use emergent C11 features. Rust: Edition system manages feature availability. #![feature(...)] for nightly features. Stable Rust has well-defined feature set. Different versioning model.",
      "guideline_title": "Emergent language features shall not be used"
    },
    {
      "guideline_id": "Rule 1.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "this applies to deprecated APIs",
      "confidence": "high",
      "notes": "MISRA: Don't use obsolescent C features. Rust: Deprecation via #[deprecated] attribute. No features become 'obsolescent' - they're removed via editions or remain stable. Different evolution model.",
      "guideline_title": "Obsolescent language features shall not be used"
    },
    {
      "guideline_id": "Rule 2.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.9.3"
      ],
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA: No unreachable code. Rust: Compiler warns on unreachable code. #[warn(unreachable_code)] default. Some unreachable paths kept for safety (match exhaustiveness). Same principle applies.",
      "guideline_title": "A project shall not contain unreachable code [IEC 61508-7 Section C.5.9], [DO-178C Section 6.4.4.3.c]"
    },
    {
      "guideline_id": "Rule 2.2",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.9.3"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: No dead code (code without effect). Rust: #[warn(unused)] family of lints. Compiler detects unused variables, results, etc. Same principle of avoiding effectless code.",
      "guideline_title": "A project shall not contain dead code [IEC 61508-7 Section C.5.10], [ISO 26262-6 Section 9.4.5], [DO-178C Section 6.4.4.3.c]"
    },
    {
      "guideline_id": "Rule 2.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: No unused type declarations. Rust: #[warn(dead_code)] for unused types. Compiler warns on unused structs/enums/type aliases. Same principle.",
      "guideline_title": "A project should not contain unused type declarations"
    },
    {
      "guideline_id": "Rule 2.4",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no separate tag name space in Rust",
      "confidence": "high",
      "notes": "MISRA: No unused tag declarations. Rust: No separate tag namespace. Struct/enum names are type names. #[warn(dead_code)] covers unused types. C-specific concern.",
      "guideline_title": "A project should not contain unused tag declarations"
    },
    {
      "guideline_id": "Rule 2.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: No unused macro declarations. Rust: #[warn(unused_macros)] for macro_rules! macros. Proc-macros harder to detect. Same principle applies.",
      "guideline_title": "A project should not contain unused macro definitions"
    },
    {
      "guideline_id": "Rule 2.6",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.4.4",
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: No unused labels. Rust: #[warn(unused_labels)] for loop labels. Compiler warns on unused 'label: loop. Same principle.",
      "guideline_title": "A function should not contain unused label declarations"
    },
    {
      "guideline_id": "Rule 2.7",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: No unused function parameters. Rust: #[warn(unused_variables)] warns on unused params. Prefix with _ to silence (fn foo(_unused: i32)). Same principle.",
      "guideline_title": "A function should not contain unused parameters"
    },
    {
      "guideline_id": "Rule 2.8",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "4.9.3"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: No unused objects. Rust: #[warn(unused_variables)] for local variables, #[warn(dead_code)] for statics/constants. Same principle of avoiding unused declarations.",
      "guideline_title": "A project should not contain unused object definitions"
    },
    {
      "guideline_id": "Rule 3.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_q8l2jza7d9xa"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.5"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "nested comments are fully supported",
      "confidence": "high",
      "notes": "MISRA: /* and // shall not appear in comments. Rust: Same syntax. Nested /* */ comments allowed in Rust (different from C). // within /* */ is fine. Nesting concerns differ but principle applies.",
      "guideline_title": "The character sequences /* and // shall not be used within a comment"
    },
    {
      "guideline_id": "Rule 3.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Line splicing in // comments prohibited. Rust: No line splicing (backslash-newline). Different lexical model. The C issue doesn't exist in Rust.",
      "guideline_title": "Line-splicing shall not be used in // comments"
    },
    {
      "guideline_id": "Rule 4.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_2i089jvv8j5g"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Only use standard escape sequences. Rust: Similar escape sequences (\\n, \\t, etc). Unicode escapes \\u{...} for any codepoint. \\x for hex bytes. Same principle of defined escapes.",
      "guideline_title": "Octal and hexadecimal escape sequences shall be terminated C90 [Implementation G.3.4(5)], C99 [Implementation J.3.4(7, 8)], C11 [Implementation J.3.4(7, 8)]"
    },
    {
      "guideline_id": "Rule 4.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Trigraphs shall not be used. Rust: No trigraphs. Never had them. The C compatibility issue doesn't exist in Rust.",
      "guideline_title": "Trigraphs should not be used"
    },
    {
      "guideline_id": "Rule 5.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "no character limit, except in extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA: External identifiers must be distinct. Rust: All identifiers in same namespace must be distinct. No length limits on significance. Unicode identifiers supported. Similar uniqueness principle.",
      "guideline_title": "External identifiers shall be distinct C90 [Undefined 7], C99 [Unspecified 7; Undefined 28], C11 [Unspecified 8; Undefined 31]"
    },
    {
      "guideline_id": "Rule 5.2",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "no character limit, but has name spaces",
      "confidence": "high",
      "notes": "MISRA: Identifiers in same scope must be distinct. Rust: Enforced by compiler. Shadowing is explicit and intentional. No significance length limits.",
      "guideline_title": "Identifiers declared in the same scope and name space shall be distinct C90 [Undefined 7], C99 [Undefined 28], C11 [Undefined 31]"
    },
    {
      "guideline_id": "Rule 5.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this also applies to macro names",
      "confidence": "high",
      "notes": "MISRA: Inner scope identifier shouldn't hide outer. Rust: Shadowing is intentional and explicit (let x = ...; let x = ...;). #[warn(unused_variables)] helps catch accidental shadowing.",
      "guideline_title": "An identifier declared in an inner scope shall not hide an identifier declared in an outer scope"
    },
    {
      "guideline_id": "Rule 5.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "macros and functions use different syntax",
      "confidence": "high",
      "notes": "MISRA: Identifiers distinct from macro names. Rust: Macros invoked with ! suffix (println!). No confusion possible between foo and foo!. Different namespace model.",
      "guideline_title": "Identifiers shall be distinct from macro names C90 [Undefined 7], C99 [Unspecified 7; Undefined 28], C11 [Unspecified 8; Undefined 31]"
    },
    {
      "guideline_id": "Rule 5.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: typedef names must be unique. Rust: type aliases create new names in type namespace. Compiler enforces uniqueness. No separate typedef namespace.",
      "guideline_title": "A typedef name shall be a unique identifier"
    },
    {
      "guideline_id": "Rule 5.8",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_21vnag69kbwe"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: External objects/functions with same identifier should have identical definition. Rust: Enforced by type system and linker. Different modules can have same names (namespaced). FFI requires consistent signatures.",
      "guideline_title": "Identifiers that define objects or functions with external linkage shall be unique"
    },
    {
      "guideline_id": "Rule 5.10",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "only possible in some cases. Previously Rule 21.2",
      "confidence": "high",
      "notes": "MISRA: Reserved identifiers not to be defined/undefined. Rust: _ is special (discard), self/Self are keywords. No macro system pollution of reserved names. Different reserved identifier model.",
      "guideline_title": "A reserved identifier or reserved macro name shall not be declared C90 [Undefined 57, 58, 64, 71] C99 [Undefined 93, 100, 101, 104, 108, 116, 118, 130] C11 [Undefined 99, 106, 107, 110, 114, 122, 126, 138]"
    },
    {
      "guideline_id": "Rule 6.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.5.6",
        "4.11.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "only provided as a library feature",
      "confidence": "high",
      "notes": "MISRA: Bit-fields only on appropriate integer types. Rust: No native bit-fields. Use crates like bitflags or bitfield. Manual bit manipulation with explicit masks. Different model entirely.",
      "guideline_title": "Bit-fields shall only be declared with an appropriate type C90 [Undefined 38; Implementation G.3.5(2)] C99 [Implementation J.3.9(1, 2)] C11 [Implementation J.3.9(1, 2)]"
    },
    {
      "guideline_id": "Rule 6.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "4.11.2",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Single-bit bit-fields should be unsigned. Rust: No native bit-fields. Use bool for single bits, or bitflags crate patterns. No signed single-bit issue.",
      "guideline_title": "Single-bit named bit-fields shall not be of a signed type"
    },
    {
      "guideline_id": "Rule 6.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.5.6",
        "4.11.2",
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.4",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Bit-field widths must fit in base type. Rust: No native bit-fields. Crate implementations validate at compile time. Different model.",
      "guideline_title": "A bit-field shall not be declared as a member of a union C90 [Implementation 30] C99 [Implementation J.3.9(4) C11 [Implementation J.3.9(5)]"
    },
    {
      "guideline_id": "Rule 7.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_2ed4axpsy9u0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2",
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "Rust octals have a distinct prefix from decimals",
      "confidence": "high",
      "notes": "MISRA: Octal constants should not be used. Rust: 0o prefix for octal (explicit, not 0 prefix). Less confusing than C's 0-prefix octal. Advisory rule applies similarly.",
      "guideline_title": "Octal constants shall not be used [Koenig 9]"
    },
    {
      "guideline_id": "Rule 7.2",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_2ed4axpsy9u0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "this is an error by default but can be enabled",
      "confidence": "high",
      "notes": "MISRA: u/U suffix for unsigned constants. Rust: Type suffixes (1u32, 42usize). Type inference often sufficient. Explicit typing when needed for clarity.",
      "guideline_title": "A \u201cu\u201d or \u201cU\u201d suffix shall be applied to all integer constants that are represented in an unsigned type"
    },
    {
      "guideline_id": "Rule 7.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_2ed4axpsy9u0"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2",
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Use L suffix for long constants. Rust: Use appropriate suffix (i64, u64). No implicit long promotion. Type always explicit or inferred, never ambiguous.",
      "guideline_title": "The lowercase character \u201cl\u201d shall not be used in a literal suffix"
    },
    {
      "guideline_id": "Rule 7.4",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_boyhlu5srp6u"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: String literals should be const-qualified pointer targets. Rust: String literals are &'static str (immutable). b\"...\" are &'static [u8]. Immutability by default.",
      "guideline_title": "A string literal shall not be assigned to an object unless the object\u2019s type is \u201cpointer to const-qualified char\u201d C90 [Undefined 12], C99 [Unspecified 14; Undefined 30], C11 [Unspecified 15; Undefined 33]"
    },
    {
      "guideline_id": "Rule 7.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Integer constant expression conversion safety. Rust: No implicit integer conversions. as casts are explicit. Compiler warns on lossy casts with clippy::cast_lossless.",
      "guideline_title": "The argument of an integer constant macro shall have an appropriate form C99 [Undefined 137], C11 [Undefined 145]"
    },
    {
      "guideline_id": "Rule 8.1",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Types must be explicitly stated. Rust: Type inference, but types are always known at compile time. Type annotations required for function signatures. No implicit int or undeclared types.",
      "guideline_title": "Types shall be explicitly specified"
    },
    {
      "guideline_id": "Rule 8.3",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "an extern declaration shall have a type compatible with the C declaration",
      "confidence": "high",
      "notes": "MISRA: Compatible declarations for same function/object. Rust: Compiler enforces consistent signatures. No forward declarations needed. Single definition per item (except trait impls).",
      "guideline_title": "All declarations of an object or function shall use the same names and type qualifiers C90 [Undefined 10], C99 [Undefined 14], C11 [Undefined 15], [Koenig 59\u201362]"
    },
    {
      "guideline_id": "Rule 8.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Compatible declaration visible when function/object defined. Rust: No separate declaration/definition. pub items visible from declaring module. No header file model.",
      "guideline_title": "A compatible declaration shall be visible when an object or function with external linkage is defined C90 [Undefined 24], C99 [Undefined 39], C11 [Undefined 41]"
    },
    {
      "guideline_id": "Rule 8.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "high",
      "notes": "MISRA: External object/function declared once per file. Rust: Items declared once. use statements bring into scope. No multiple extern declarations needed.",
      "guideline_title": "An external object or function shall be declared once in one and only one file [Koenig 66]"
    },
    {
      "guideline_id": "Rule 8.6",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "high",
      "notes": "MISRA: External linkage identifiers defined once. Rust: Linker enforces one definition. #[no_mangle] for C ABI symbols. Duplicate definitions are link errors.",
      "guideline_title": "An identifier with external linkage shall have exactly one external definition C90 [Undefined 44], C99 [Undefined 78], C11 [Undefined 84], [Koenig 55, 63\u201365]"
    },
    {
      "guideline_id": "Rule 8.7",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "items should not be declared pub if referenced in only one crate",
      "confidence": "high",
      "notes": "MISRA: Functions/objects not accessed externally should be file-scope. Rust: Default private visibility. pub(crate), pub(super), pub for increasing visibility. Principle of minimal visibility applies.",
      "guideline_title": "Functions and objects should not be defined with external linkage if they are referenced in only one translation unit [Koenig 56, 57]"
    },
    {
      "guideline_id": "Rule 8.8",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.1",
        "15.8",
        "15.8.1",
        "14.2",
        "14.4.3",
        "14.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: static storage class specifier required for internal linkage. Rust: No static keyword for linkage. Visibility via pub/private. Item location determines linkage.",
      "guideline_title": "The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage"
    },
    {
      "guideline_id": "Rule 8.9",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "17",
        "17.1",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: Objects with single-function use should be block scope. Rust: let bindings are block-scoped by default. Constants can be local to functions. Same principle of minimal scope.",
      "guideline_title": "An object should be declared at block scope if its identifier only appears in a single function"
    },
    {
      "guideline_id": "Rule 8.10",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: inline function defined in file that uses it. Rust: #[inline] is a hint to compiler. Generics monomorphized at use site. LTO can inline across crates. Different inlining model.",
      "guideline_title": "An inline function shall be declared with the static storage class C99 [Unspecified 20; Undefined 67], C11 [Unspecified 21; Undefined 70]"
    },
    {
      "guideline_id": "Rule 8.11",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "4.11.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: extern array dimensions should be explicit. Rust: No extern array declarations like C. FFI uses pointers (*const T) or slices. Array sizes always explicit in type.",
      "guideline_title": "When an array with external linkage is declared, its size should be explicitly specified"
    },
    {
      "guideline_id": "Rule 8.12",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Enum values must be explicit if not all implicit. Rust: Enum variants can have explicit discriminants. #[repr(C/u8/etc)] for layout control. Different enum model.",
      "guideline_title": "Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique"
    },
    {
      "guideline_id": "Rule 8.13",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_v5x85lt5ulva"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA: Pointer to non-modified object should be const. Rust: &T vs &mut T distinction. Immutable references by default. Compiler enforces const-correctness through borrowing rules.",
      "guideline_title": "A pointer should point to a const-qualified type whenever possible"
    },
    {
      "guideline_id": "Rule 8.14",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7.3",
        "4.12.5",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: restrict qualifier should not be used. Rust: No restrict keyword. Noalias optimization hints via LLVM for &mut. Aliasing rules enforced by borrow checker, not annotations.",
      "guideline_title": "The restrict type qualifier shall not be used C99 [Undefined 65, 66], C11 [Undefined 68, 69]"
    },
    {
      "guideline_id": "Rule 8.16",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.11.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "cannot be explicitly specified. Only ZSTs have this alignment",
      "confidence": "high",
      "notes": "MISRA: _Atomic and const qualifiers on same object restrictions. Rust: No _Atomic qualifier. AtomicU32 etc are types, not qualifiers. Const atomics possible but limited utility.",
      "guideline_title": "The alignment specification of zero should not appear in an object declaration"
    },
    {
      "guideline_id": "Rule 8.17",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_g1z6bpyjqxkz",
        "fls_7pby13muw48o",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.11.1",
        "4.11",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has #[repr(align(N))] and std::mem::align_of; Similar function semantics with stronger type checking",
      "guideline_title": "At most one explicit alignment specifier should appear in an object declaration"
    },
    {
      "guideline_id": "Rule 8.18",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "14.2",
        "14.4.3",
        "14.7",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust uses pub visibility and modules instead of linkage; Similar function semantics with stronger type checking",
      "guideline_title": "There shall be no tentative definitions in a header file C90 [Undefined 44], C99 [Undefined 78], C11 [Undefined 84], [Koenig 55, 63\u201365]"
    },
    {
      "guideline_id": "Rule 8.19",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jdknpu3kf865",
        "fls_m0z7omni9hp0",
        "fls_9gprp17h6t1q",
        "fls_uloyjbaso8pz",
        "fls_yztwtek0y34v",
        "fls_tmoh3y9oyqsy",
        "fls_pgp7ezcc9lh8",
        "fls_svkx6szhr472",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "21",
        "21.1",
        "21.2",
        "13.2.6",
        "15.1",
        "15.8",
        "15.8.1"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage",
      "guideline_title": "There should be no external declarations in a source file"
    },
    {
      "guideline_id": "Rule 9.1",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_94a8v54bufn8"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "15.1",
        "15.8",
        "15.8.1",
        "15.2",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc but can be bypassed by unsafe",
      "confidence": "high",
      "notes": "MISRA: Initialize objects before use. Rust: Compiler enforces initialization before use. Uninitialized variables are compile-time errors. MaybeUninit<T> requires unsafe for explicit uninitialized memory. Safe Rust completely prevents this issue.",
      "guideline_title": "The value of an object with automatic storage duration shall not be read before it has been set C90 [Undefined 41], C99 [Undefined 10, 17], C11 [Undefined 11, 19, 21]"
    },
    {
      "guideline_id": "Rule 9.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_a14slch83hzn",
        "fls_3xvm61x0t251"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.4",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Use braces for aggregate initializers. Rust: Struct/array initialization always uses explicit syntax (Struct { field: val }, [a, b, c]). No C-style implicit initialization. Different syntax entirely.",
      "guideline_title": "The initializer for an aggregate or union shall be enclosed in braces C90 [Undefined 42], C99 [Undefined 76, 77], C11 [Undefined 82, 83]"
    },
    {
      "guideline_id": "Rule 9.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_xinykul167l"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Don't partially initialize arrays. Rust: Array literals must specify all elements: [1, 2, 3] or use [val; N] for repeated values. Partial initialization is not possible syntactically.",
      "guideline_title": "Arrays shall not be partially initialized"
    },
    {
      "guideline_id": "Rule 9.4",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_a14slch83hzn"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "high",
      "notes": "MISRA: Don't initialize an element twice. Rust: Compiler error if same field initialized twice in struct literal. Duplicate array indices not possible with Rust syntax.",
      "guideline_title": "An element of an object shall not be initialized more than once"
    },
    {
      "guideline_id": "Rule 9.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: With designated initializers, array size must be explicit. Rust: No designated initializers for arrays. Array size always explicit [T; N] or inferred from literal length. Different initialization model.",
      "guideline_title": "Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly"
    },
    {
      "guideline_id": "Rule 9.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Chained designator restrictions. Rust: No designated/chained initializers. Struct field initialization is explicit. Nested structs initialized via nested struct literals.",
      "guideline_title": "An initializer using chained designators shall not contain initializers without designators"
    },
    {
      "guideline_id": "Rule 9.7",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_vyc9vcuamlph",
        "fls_3xvm61x0t251"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "17.2",
        "17.1"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Initialize atomics properly before access. Rust: Atomic types (AtomicUsize, etc.) created via ::new(). No uninitialized atomics in safe Rust. Unsafe Rust with MaybeUninit requires explicit initialization.",
      "guideline_title": "Atomic objects shall be appropriately initialized before being accessed C11 [Undefined 5]"
    },
    {
      "guideline_id": "Rule 10.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's type system prevents implicit type conversions entirely. MISRA's 'essential type model' exists because C has implicit conversions between bool/char/numeric - Rust has none.",
      "guideline_title": "Operands shall not be of an inappropriate essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.7,
          "reason": "About enum discriminant memory layout, not type conversion rules",
          "fls_section": "4.11.2.1"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.67,
          "reason": "About &, |, ^ operators, not essential type mixing",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.65,
          "reason": "About unary negation, not type conversion",
          "fls_section": "6.5.4"
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_title": "Type Representation",
          "score": 0.64,
          "reason": "About memory layout, not conversion legality rules",
          "fls_section": "4.11.2"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.65,
          "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' All numeric conversions require explicit 'as' cast - no implicit type mixing possible.",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: Numeric widening and narrowing are NOT allowed implicitly. Only reference/pointer coercions are implicit. This prevents C's 'usual arithmetic conversions'.",
          "fls_section": "4.12.3"
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.45,
          "reason": "Per FLS: Operands of arithmetic operators must be the SAME type. Compiler error if types don't match. MISRA's essential type mixing cannot occur.",
          "fls_section": "6.5.5"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's char type cannot be used in arithmetic. Explicit cast to u32/i32 required for any numeric operations on character values.",
      "guideline_title": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations",
      "rejected_matches": [
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.59,
          "reason": "About unary operators, not char arithmetic",
          "fls_section": "6.5.4"
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.57,
          "reason": "About +=/-= etc., not char type restrictions",
          "fls_section": "6.5.12"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_wrvjizrqf3po",
          "fls_title": "Char Type",
          "score": 0.59,
          "reason": "Per FLS: Rust's char is a 4-byte Unicode scalar value, NOT a numeric type. Cannot participate in arithmetic without explicit conversion.",
          "fls_section": "4.3.2"
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Arithmetic operands must be numeric types of the same type. char is not a numeric type, so arithmetic on char is a compile error.",
          "fls_section": "6.5.5"
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.56,
          "reason": "Per FLS: Must use explicit 'as u32' or similar to convert char to numeric. Conversion is always explicit and intentional.",
          "fls_section": "6.5.10"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C's 'usual arithmetic conversions' don't exist in Rust. Operands must match exactly or code won't compile.",
      "guideline_title": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.69,
          "reason": "Shows Rust's explicit alternative but rule is about implicit conversions which don't exist",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.63,
          "reason": "Operators have same-type requirement but not the focus of this rule",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.6,
          "reason": "About overflow behavior, not type conversion",
          "fls_section": "6.23"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.66,
          "reason": "Per FLS: Operands must be the SAME type. 'i32 + i64' is a compile error. No implicit 'usual arithmetic conversions' exist in Rust.",
          "fls_section": "6.5.5"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit numeric widening or narrowing. The 'usual arithmetic conversions' from C simply don't exist in Rust.",
          "fls_section": "4.12.3"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust's 'as' casts can perform potentially inappropriate conversions (truncation, sign loss). Clippy lints 'cast_possible_truncation', 'cast_sign_loss' provide additional enforcement.",
      "guideline_title": "The value of an expression should not be cast to an inappropriate essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.61,
          "reason": "About enum layout, not cast appropriateness",
          "fls_section": "4.11.2.1"
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.57,
          "reason": "Unary operator, not type casting",
          "fls_section": "6.5.4"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.7,
          "reason": "Per FLS: Rust's 'as' casts allow numeric conversions including truncation and sign changes. While more restricted than C (no arbitrary pointer casts in safe Rust), numeric casts can still silently truncate. Advisory rule applies.",
          "fls_section": "6.5.10"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no implicit widening. Assignment requires exact type match. If wider arithmetic is needed, explicit cast before the operation is required.",
      "guideline_title": "The value of a composite expression shall not be assigned to an object with wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.56,
          "reason": "About struct initialization, not assignment widening",
          "fls_section": "6.11"
        },
        {
          "fls_id": "fls_3ut3biyra4r9",
          "fls_title": "Assignee Expressions",
          "score": 0.55,
          "reason": "About what can be assigned to, not type widening",
          "fls_section": "6.1.1"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_y4by2i8dl05o",
          "fls_title": "Assignment Expressions",
          "score": 0.58,
          "reason": "Per FLS: Assignment requires types to match exactly. Cannot assign u16 result to u32 variable without explicit cast.",
          "fls_section": "6.5.11"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: No implicit widening coercions. The C pattern of 'u32 x = u16_a + u16_b' (implicit widening) doesn't compile in Rust.",
          "fls_section": "4.12.3"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.45,
          "reason": "Per FLS: Overflow has defined behavior (panic or wrap), not UB. Even if narrow arithmetic overflows, behavior is deterministic.",
          "fls_section": "6.23"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.7",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Similar to 10.6 - Rust's same-type requirement for operators prevents mixing narrow composite expressions with wider operands.",
      "guideline_title": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.6,
          "reason": "Shows explicit alternative, but rule about implicit conversions which don't exist",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.59,
          "reason": "Same-type requirement but not the focus",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.54,
          "reason": "About overflow, not type widening",
          "fls_section": "6.23"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Both operands must be the SAME type. Mixing u16 composite with u32 operand is a compile error.",
          "fls_section": "6.5.5"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit widening. The scenario this rule prevents cannot occur because Rust rejects type mismatches.",
          "fls_section": "4.12.3"
        }
      ]
    },
    {
      "guideline_id": "Rule 10.8",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust allows explicit widening casts after narrow arithmetic. The MISRA concern is partially mitigated by defined overflow behavior, but explicit casts can still mask programmer intent errors.",
      "guideline_title": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.54,
          "reason": "About bitwise operators, not casting composite expressions",
          "fls_section": "6.5.6"
        },
        {
          "fls_id": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.5,
          "reason": "About type inference, not explicit casting",
          "fls_section": "4.12.2"
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.66,
          "reason": "Per FLS: Rust allows explicit widening casts after narrow arithmetic: '(a + b) as u32' is legal. The cast is explicit, making intent clear, but can still mask overflow issues.",
          "fls_section": "6.5.10"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.48,
          "reason": "Per FLS: Overflow has DEFINED behavior (panic in debug, wrap in release) - not UB like C. Mitigates but doesn't eliminate the MISRA concern about implementation-dependent results.",
          "fls_section": "6.23"
        }
      ]
    },
    {
      "guideline_id": "Rule 11.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_xztr1kebz8bo",
        "fls_hbbek3z4wtcs",
        "fls_airvr79xkcag",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_jep7p27kaqlp",
        "fls_ppd1xwve3tr7",
        "fls_3i4ou0dq64ny"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "MISRA: Prevent conversions between function pointers and other types. Rust: Function item types are distinct from function pointer types. Coercion fn item -> fn ptr is allowed. Arbitrary conversions require unsafe transmute. Safe Rust prevents the UB this rule addresses; unsafe Rust requires explicit unsafe block.",
      "guideline_title": "Conversions shall not be performed between a pointer to a function and any other type C90 [Undefined 24, 27\u201329], C99 [Undefined 21, 23, 39, 41], C11 [Undefined 24, 26, 41, 44]"
    },
    {
      "guideline_id": "Rule 11.2",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ppd1xwve3tr7",
        "fls_1qhsun1vyarz",
        "fls_jep7p27kaqlp",
        "fls_ohhsmifo0urd"
      ],
      "fls_rationale_type": "rust_alternative",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Prevent conversions to/from pointers to incomplete types. Rust: No 'incomplete types' in C sense. Opaque types handled via private fields or extern types. Raw pointers can point to unsized types (*const T where T: ?Sized). Safe Rust handles this through the type system; unsafe requires explicit blocks.",
      "guideline_title": "Conversions shall not be performed between a pointer to an incomplete type and any other type C90 [Undefined 29], C99 [Undefined 21, 22, 41], C11 [Undefined 24, 25, 44]"
    },
    {
      "guideline_id": "Rule 11.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_ppd1xwve3tr7",
        "fls_1qhsun1vyarz",
        "fls_dw33yt5g6m0k",
        "fls_jep7p27kaqlp",
        "fls_ohhsmifo0urd",
        "fls_g1z6bpyjqxkz"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Prevent pointer-to-object type conversions (alignment/aliasing UB). Rust: Pointer casts via 'as' are allowed but dereferencing requires unsafe. Miri can detect UB. Safe Rust's references have stricter aliasing rules via borrow checker. Unsafe Rust allows raw pointer casts but UB on misaligned/aliased access.",
      "guideline_title": "A conversion shall not be performed between a pointer to object type and a pointer to a different object type C90 [Undefined 20], C99 [Undefined 22, 34], C11 [Undefined 25, 37]"
    },
    {
      "guideline_id": "Rule 11.4",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_1qhsun1vyarz",
        "fls_ppd1xwve3tr7",
        "fls_3qnpv2z7yjil",
        "fls_jep7p27kaqlp",
        "fls_ohhsmifo0urd",
        "fls_g1z6bpyjqxkz"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Prevent pointer<->integer conversions (alignment UB). Rust: pointer as usize and usize as *const T allowed but dereferencing requires unsafe. Safe Rust cannot create invalid pointers from integers. Common in FFI/embedded for memory-mapped registers. Note: Rule 11.7 was combined into this rule in MISRA C:2025.",
      "guideline_title": "A conversion shall not be performed between a pointer to object and an arithmetic type C90 [Undefined 20, 29; Implementation G.3.7(2)] C99 [Undefined 21, 34, 41; Implementation J.3.7(1)] C11 [Undefined 24, 37, 44; Implementation J.3.7(1)]"
    },
    {
      "guideline_id": "Rule 11.6",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_1qhsun1vyarz",
        "fls_3qnpv2z7yjil",
        "fls_ppd1xwve3tr7",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "rust_alternative",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA: Prevent void*<->arithmetic conversions. Rust: No void* equivalent; *const () or *mut () used instead. Casting *const () as usize works. Safe Rust prevents creating arbitrary pointers. Unsafe needed for dereference.",
      "guideline_title": "A cast shall not be performed between pointer to void and an arithmetic type C90 [Undefined 29; Implementation G.3.7(2)] C99 [Undefined 21, 41; Implementation J.3.7(1)] C11 [Undefined 24, 44; Implementation J.3.7(1)]"
    },
    {
      "guideline_id": "Rule 11.9",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.5.1",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "Rust does not have a null pointer constant",
      "confidence": "high",
      "notes": "MISRA: Use NULL macro for null pointer constants. Rust: No NULL macro. Option<T> or Option<NonNull<T>> for nullable pointers. Raw pointers use std::ptr::null() or std::ptr::null_mut(). The C concept of integer 0 as null pointer doesn't exist in Rust.",
      "guideline_title": "The macro NULL shall be the only permitted form of integer null pointer constant"
    },
    {
      "guideline_id": "Rule 11.10",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "17.2",
        "17.1",
        "4.7.3",
        "4.12.5",
        "4.7",
        "4.7.2",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: _Atomic void is problematic in C. Rust: No _Atomic qualifier. Atomics via std::sync::atomic types (AtomicUsize, AtomicPtr<T>, etc.). No concept of 'atomic void'. AtomicPtr<T> requires sized T.",
      "guideline_title": "The _Atomic qualifier shall not be applied to the incomplete type void"
    },
    {
      "guideline_id": "Rule 11.11",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_nsvzzbldhq53",
        "fls_tiqp1gxf116z"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.5.1",
        "6.5.10",
        "4.12.3",
        "4.12.2",
        "4.12.7"
      ],
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "high",
      "notes": "MISRA: Don't implicitly compare pointers to NULL. Rust: Pointers are not implicitly convertible to bool. Must use explicit is_null() or pattern matching with Option. Comparison operators on raw pointers compare addresses, not nullness. Safe Rust typically uses Option<NonNull<T>> instead of nullable pointers.",
      "guideline_title": "Pointers shall not be implicitly compared to NULL"
    },
    {
      "guideline_id": "Rule 12.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_kw25194gpael"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "Per FLS Expression Precedence (fls_kw25194gpael): Rust has explicit precedence rules. Some operators REQUIRE parentheses (comparisons, ranges) preventing chaining errors. However, the advisory guidance to use parentheses for clarity still applies - Rust's precedence (e.g., bitwise vs boolean) can still confuse programmers. Clippy lint 'precedence' helps catch non-obvious cases.",
      "guideline_title": "The precedence of operators within expressions should be made explicit"
    },
    {
      "guideline_id": "Rule 12.2",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_abp6tjbz8tpn",
        "fls_ZfIBiJMf8qE1"
      ],
      "fls_rationale_type": "rust_alternative",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "Per FLS Bit Expressions (fls_abp6tjbz8tpn) and Arithmetic Overflow (fls_ZfIBiJMf8qE1): Shift by >= bit width causes defined behavior (panic in debug, masks shift amount in release - not UB like C). However, this is still likely a bug. Rust provides checked_shl/checked_shr methods for explicit handling. Clippy's 'suspicious_arithmetic_impl' can help catch issues.",
      "guideline_title": "The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand"
    },
    {
      "guideline_id": "Rule 12.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no comma operator. Commas in Rust are syntactic separators (function args, tuple elements) not expression operators. The C comma operator's behavior (evaluate left, discard, return right) doesn't exist. FLS Expression Precedence table shows no comma operator. This MISRA rule is inherently satisfied.",
      "guideline_title": "The comma operator should not be used"
    },
    {
      "guideline_id": "Rule 12.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_66m4rnbssgig",
        "fls_ZfIBiJMf8qE1"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "6",
        "6.1",
        "6.5",
        "2.4",
        "2.4.4",
        "2.4.4.1",
        "2.4.4.2",
        "2.4.7",
        "6.2",
        "6.1.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this is either well-defined or will not occur",
      "confidence": "high",
      "notes": "Per FLS Constant Expressions (fls_66m4rnbssgig): 'It is a static error if a constant expression panics' - this means overflow in const context is a COMPILE ERROR. Per FLS Arithmetic Overflow (fls_ZfIBiJMf8qE1): Constant expressions always panic on overflow. Unlike C where wrap-around silently produces unexpected values at compile time, Rust fails compilation.",
      "guideline_title": "Evaluation of constant expressions should not lead to unsigned integer wrap-around"
    },
    {
      "guideline_id": "Rule 12.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_xinykul167l"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.11.1",
        "4.11",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C's array-to-pointer decay causes sizeof(param) to return pointer size not array size. Per FLS Array Types (fls_uj0kpjwyld60): Rust arrays [T; N] have compile-time known size. Slices &[T] are explicitly different types. std::mem::size_of::<[T; N]>() returns correct array size. Function params taking arrays use slices or references with explicit semantics - no decay confusion.",
      "guideline_title": "The sizeof operator shall not have an operand which is a function parameter declared as array of type"
    },
    {
      "guideline_id": "Rule 12.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "17.2",
        "17.1",
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.4",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per FLS Atomics (fls_vyc9vcuamlph): Rust atomic types (AtomicU32, etc.) are opaque wrapper types - there is no way to directly access the underlying value. All access MUST go through methods like load()/store() with explicit Ordering. Unlike C11's _Atomic qualifier, Rust's design makes non-atomic access to atomic data impossible. The type system enforces atomic access patterns.",
      "guideline_title": "Structure and union members of atomic objects shall not be directly accessed"
    },
    {
      "guideline_id": "Rule 13.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_8tsynkj2cufj"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "recommended",
      "misra_rust_comment": "order of evaluation is strict in Rust",
      "confidence": "high",
      "notes": "Per FLS Initialization (fls_3xvm61x0t251) and Struct Expressions (fls_8tsynkj2cufj): Rust struct/array initializers can contain expressions with side effects. Evaluation order of struct field initializers is specified (lexical order), but side effects in initializers can still lead to confusing code. This advisory guidance applies to Rust for code clarity.",
      "guideline_title": "Initializer lists shall not contain persistent side effects"
    },
    {
      "guideline_id": "Rule 13.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_290jmzfh7x4e"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no ++ or -- operators. Increment/decrement must be done via compound assignment (x += 1) or explicit assignment (x = x + 1). Per FLS Compound Assignment (fls_290jmzfh7x4e): These return unit type (), so cannot be embedded in larger expressions. The C problem of 'i++ + ++i' undefined behavior cannot occur in Rust.",
      "guideline_title": "A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator"
    },
    {
      "guideline_id": "Rule 13.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per FLS Assignment Expressions (fls_y4by2i8dl05o): 'The type of an assignment expression is the unit type.' Per FLS Compound Assignment (fls_290jmzfh7x4e): Same - returns unit. This means assignment results CANNOT be used in Rust. 'if (x = 5)' is a compile error. Chained 'a = b = c' is impossible. The language design prevents this class of errors.",
      "guideline_title": "The result of an assignment operator should not be used"
    },
    {
      "guideline_id": "Rule 13.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_lstusiu2c8lu"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "Per FLS Lazy Boolean Expressions (fls_lstusiu2c8lu): Short-circuit evaluation is well-defined - right operand may not execute. FLS explicitly shows 'false && panic!()' as valid where panic doesn't execute. Rust does NOT prohibit side effects in operands. This MISRA guidance applies: side effects in conditionally-evaluated code can be confusing. Clippy lint 'short_circuit_statement' helps.",
      "guideline_title": "The right hand operand of a logical && or || operator shall not contain persistent side effects"
    },
    {
      "guideline_id": "Rule 13.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_g1z6bpyjqxkz"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6",
        "6.1",
        "6.5",
        "4.11.1",
        "4.11"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is not an expression operator in Rust",
      "confidence": "high",
      "notes": "Per FLS Type Layout (fls_g1z6bpyjqxkz): Rust's std::mem::size_of::<T>() takes a TYPE parameter, not an expression. There is no way to pass an expression with side effects. Unlike C's sizeof(expr) which may or may not evaluate expr (VLA-dependent), Rust's size_of is purely compile-time type-based. The C problem cannot occur.",
      "guideline_title": "The operand of the sizeof operator shall not contain any expression which has potential side effects"
    },
    {
      "guideline_id": "Rule 14.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_rr908hgunja7"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.3.3.1",
        "2.4.4.2",
        "6.5.5",
        "6.5.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to while loops only",
      "confidence": "high",
      "notes": "Per FLS For Loops (fls_onfyolkcbeh3): Rust's for loops are iterator-based, not counter-based. Subject expression must implement IntoIterator. Standard floating-point ranges (0.0..10.0) do NOT implement Iterator. There is no traditional 'for(i=0; i<n; i++)' construct. While you could manually implement a float-yielding iterator, the idiomatic and standard patterns prevent floating-point loop counters.",
      "guideline_title": "A loop counter shall not have essentially floating type"
    },
    {
      "guideline_id": "Rule 14.3",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_mkut7gut49gi",
        "fls_5jjm1kt43axd",
        "fls_sf4qnd43z2wc"
      ],
      "fls_rationale_type": "rust_alternative",
      "fls_sections": [
        "4.5.1",
        "4.11.2.1",
        "4.11",
        "6",
        "6.1",
        "6.5",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Per FLS Infinite Loops (fls_sf4qnd43z2wc): Rust has explicit 'loop' keyword for intentional infinite loops, making 'while true' unnecessary. Compiler warns about dead code and unreachable branches. However, invariant conditions are not a compile error per FLS. Clippy's 'while_true' lint catches 'while true' suggesting 'loop' instead. Rust's design makes invariant loops more intentional.",
      "guideline_title": "Controlling expressions shall not be invariant"
    },
    {
      "guideline_id": "Rule 14.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_mkut7gut49gi",
        "fls_5jjm1kt43axd"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "high",
      "notes": "Per FLS If Expressions (fls_mkut7gut49gi): 'The type of the subject expression shall be type bool'. Per FLS While Loops (fls_5jjm1kt43axd): 'The type of an iteration expression shall be type bool'. This is a strict compile-time requirement. No implicit conversion from integers/pointers to bool exists. 'if (ptr)' or 'while (x)' are compile errors in Rust.",
      "guideline_title": "The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type"
    },
    {
      "guideline_id": "Rule 15.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "14.4.4",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Avoid goto. Rust: No goto keyword. Use loop/break/continue with labels ('label: loop { break 'label; }). Structured control flow enforced by language design.",
      "guideline_title": "The goto statement should not be used"
    },
    {
      "guideline_id": "Rule 15.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "14.4.4",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: goto must jump forward only. Rust: No goto. Labeled breaks can only exit enclosing loops, not jump arbitrarily. The rule's concern doesn't apply.",
      "guideline_title": "The goto statement shall jump to a label declared later in the same function"
    },
    {
      "guideline_id": "Rule 15.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.1",
        "6.5.2",
        "14.4.4",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: goto labels must be in same/enclosing block. Rust: No goto. Loop labels have block scope rules but only for break/continue, not arbitrary jumps.",
      "guideline_title": "Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement"
    },
    {
      "guideline_id": "Rule 15.4",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_sf4qnd43z2wc",
        "fls_jr4tpuyksr75"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: Limit break/goto in loops. Rust: Advisory applies - single break per loop is clearer. Early returns and ? operator are idiomatic alternatives. Labeled breaks available for complex control flow.",
      "guideline_title": "There should be no more than one break or goto statement used to terminate any iteration statement"
    },
    {
      "guideline_id": "Rule 15.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_sf4qnd43z2wc"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16.1",
        "16.2",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "no longer endorsed by MISRA",
      "confidence": "high",
      "notes": "MISRA: Single exit point (disapplied). Rust: Early returns are idiomatic. ? operator encourages multiple exit points. Single exit not considered Rust best practice. Rule is disapplied in MISRA C:2025.",
      "guideline_title": "A function should have a single point of exit at the end [IEC 61508-3 Table B.9], [ISO 26262-6 Table 8]"
    },
    {
      "guideline_id": "Rule 15.6",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Braces required for if/loop bodies. Rust: Braces mandatory. No braceless if/while/for. Syntax enforces this - 'if cond { body }' always requires braces.",
      "guideline_title": "The body of an iteration-statement or a selection-statement shall be a compound-statement [Koenig 24]"
    },
    {
      "guideline_id": "Rule 15.7",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_sjwrlwvpulp",
        "fls_e5td0fa92fay"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4"
      ],
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA: if-else-if chains need final else. Rust: Advisory applies. match expressions must be exhaustive (compiler enforced). if-else-if chains benefit from final else for clarity.",
      "guideline_title": "All if \u2026 else if constructs shall be terminated with an else statement"
    },
    {
      "guideline_id": "Rule 16.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per FLS Match Expressions (fls_e5td0fa92fay): Rust has no switch statement. The match expression has strict syntactic rules enforced at compile time. The 'malformed switch' problems in C (labels in wrong places, unstructured flow) cannot occur because match arms are syntactically constrained to pattern => expression structure.",
      "guideline_title": "All switch statements shall be well-formed"
    },
    {
      "guideline_id": "Rule 16.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per FLS Match Expressions (fls_e5td0fa92fay): Rust has no case/default labels that can be placed arbitrarily. Match arms are syntactic constructs within the match expression only. There is no equivalent to Duff's Device or goto-into-switch patterns. The problem this rule addresses cannot exist in Rust.",
      "guideline_title": "A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement"
    },
    {
      "guideline_id": "Rule 16.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per FLS Match Expressions (fls_e5td0fa92fay): Fall-through is IMPOSSIBLE in Rust match. Each arm evaluates its expression and terminates the match. There is no break statement needed because there is no fall-through mechanism. The C bug of forgetting break cannot occur. This is enforced by Rust's fundamental design.",
      "guideline_title": "Every switch-clause shall be appropriately terminated"
    },
    {
      "guideline_id": "Rule 16.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "a corresponding match expression must be complete",
      "confidence": "high",
      "notes": "Per FLS Match Expressions (fls_e5td0fa92fay), legality rule fls_e02um1gb89d0: 'The patterns of all match arms taken together shall exhaustively match the subject expression's type.' This is a COMPILE ERROR if not satisfied. Superior to MISRA's default requirement - Rust enforces complete coverage at compile time, not just defensive default handling at runtime.",
      "guideline_title": "Every switch statement shall have a default label"
    },
    {
      "guideline_id": "Rule 16.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_e5td0fa92fay"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "14.4.4",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "irrefutable pattern causes a subsequent refutable one to be unreachable",
      "confidence": "high",
      "notes": "Per FLS Match Expressions (fls_e5td0fa92fay): Match arms are evaluated in declaration order. The wildcard pattern '_' (Rust's equivalent to default) should typically be last to avoid shadowing other patterns. Rust's compiler warns about unreachable patterns if '_' comes before more specific patterns. The guidance to put catch-all patterns last applies.",
      "guideline_title": "A default label shall appear as either the first or the last switch label of a switch statement"
    },
    {
      "guideline_id": "Rule 16.6",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_e5td0fa92fay"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per FLS Match Expressions (fls_e5td0fa92fay): Rust allows single-arm match expressions, which may indicate a programming error (should use if-let instead). Clippy lint 'single_match' suggests converting single-arm matches to if-let. The MISRA guidance about single-clause switches being suspicious applies to Rust's single-arm matches.",
      "guideline_title": "Every switch statement shall have at least two switch-clauses"
    },
    {
      "guideline_id": "Rule 16.7",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_e5td0fa92fay",
        "fls_tiqp1gxf116z"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "5.4.5",
        "5.2",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per FLS Bool Type (fls_tiqp1gxf116z) and Match Expressions: Matching on bool is syntactically valid in Rust and would require 'true =>' and 'false =>' arms. However, if-else is more idiomatic and readable for boolean decisions. Clippy lint 'match_bool' suggests converting match on bool to if-else. This MISRA guidance applies.",
      "guideline_title": "A switch-expression shall not have essentially Boolean type"
    },
    {
      "guideline_id": "Rule 17.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Don't use <stdarg.h> variadics. Rust: No C-style variadics in safe Rust. Variadic functions only possible in extern \"C\" FFI context. Rust uses macros (println!), tuples, or slices for variable args. The UB associated with va_list doesn't exist in Rust's model.",
      "guideline_title": "The standard header file <stdarg.h> shall not be used C90 [Undefined 45, 70\u201376] C99 [Undefined 81, 128\u2013135] C11 [Undefined 87, 136\u2013143]"
    },
    {
      "guideline_id": "Rule 17.2",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_xa4nbfas01cj",
        "fls_zJOAmSr3Dbqk"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.12.1"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Avoid recursion (stack overflow risk). Rust: Same concern - recursion can overflow stack. No tail call optimization guaranteed. Iterative solutions or trampolines preferred for deep recursion. #[recursion_limit] for compile-time recursion (macros/types).",
      "guideline_title": "Functions shall not call themselves, either directly or indirectly"
    },
    {
      "guideline_id": "Rule 17.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Functions must be declared before use. Rust: All functions must be declared. No implicit declarations. Name resolution requires items to be in scope. The C issue of calling undeclared functions doesn't exist in Rust.",
      "guideline_title": "A function shall not be declared implicitly C90 [Undefined 6, 22, 23]"
    },
    {
      "guideline_id": "Rule 17.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_vpbikb73dw4k",
        "fls_uj0kpjwyld60"
      ],
      "fls_rationale_type": "rust_alternative",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Array parameters should have matching dimensions. Rust: No array-to-pointer decay. Functions take &[T] slices (with length) or [T; N] arrays (fixed size). Type system enforces correct sizing. Note: Rule 17.6 was combined into this rule.",
      "guideline_title": "The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements C99 [Undefined 71], C11 [Undefined 77]"
    },
    {
      "guideline_id": "Rule 17.8",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_v5x85lt5ulva",
        "fls_svkx6szhr472"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "this cannot be done accidentally without declaring parameters `mut`",
      "confidence": "high",
      "notes": "MISRA: Don't modify function parameters. Rust: Parameters are immutable by default. Must explicitly use 'mut' to allow modification. Shadowing (let param = ...) is idiomatic alternative. The rule's intent aligns with Rust's default immutability.",
      "guideline_title": "A function parameter should not be modified"
    },
    {
      "guideline_id": "Rule 17.9",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_zJOAmSr3Dbqk",
        "fls_98lnexk53ru4",
        "fls_sf4qnd43z2wc"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "this is expressed with the `!` (Never) type, and enforced by rustc",
      "confidence": "high",
      "notes": "MISRA: _Noreturn functions must not return. Rust: Functions returning ! (never type) must diverge (panic!, loop, abort). Compiler enforces this. fn foo() -> ! must not return normally.",
      "guideline_title": "A function declared with a _Noreturn function specifier shall not return to its caller C11 [Undefined 71]"
    },
    {
      "guideline_id": "Rule 17.10",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_98lnexk53ru4"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: _Noreturn functions should have void return. Rust: -> ! is the return type for diverging functions. No separate attribute needed. Type system handles this directly. The C issue of _Noreturn with non-void return doesn't apply.",
      "guideline_title": "A function declared with a _Noreturn function specifier shall have void return type"
    },
    {
      "guideline_id": "Rule 17.12",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Function names should use & or () to clarify intent. Rust: Function items and function pointers are distinct types. No implicit conversion to pointer. Taking address explicit: let f: fn() = func; or let f = func as fn(). No ambiguity possible.",
      "guideline_title": "A function identifier should only be used with either a preceding &, or with a parenthesized parameter list"
    },
    {
      "guideline_id": "Rule 17.13",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_xztr1kebz8bo",
        "fls_hbbek3z4wtcs"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Don't type-qualify function types (const fn_ptr is UB in C). Rust: No type qualifiers on function types. const fn is a different concept (compile-time evaluation). fn() type cannot be 'const' or 'volatile' qualified. The C UB doesn't exist.",
      "guideline_title": "A function type shall not be type qualified C90 [Undefined *], C99 [Undefined 63], C11 [Undefined 66]"
    },
    {
      "guideline_id": "Rule 18.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_xinykul167l",
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_5cm4gkt55hjh",
        "fls_ppd1xwve3tr7",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "4.3.3.2",
        "6.5.6",
        "6.5.7",
        "4.3",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "high",
      "notes": "MISRA: Pointer arithmetic must stay within array bounds. Rust: Safe indexing panics on out-of-bounds (runtime check). Slices carry length info. Raw pointer arithmetic requires unsafe and has no bounds checking. Safe Rust prevents the UB via bounds checks; unsafe Rust must ensure validity manually.",
      "guideline_title": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand C90 [Undefined 30], C99 [Undefined 43, 44, 46, 59], C11 [Undefined 46, 47, 49, 62]"
    },
    {
      "guideline_id": "Rule 18.2",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_ppd1xwve3tr7",
        "fls_jep7p27kaqlp",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "high",
      "notes": "MISRA: Pointer subtraction only valid within same array. Rust: Raw pointer offset_from() requires both pointers to same allocation, returns isize. Safe Rust uses slice operations which handle this correctly. Unsafe pointer subtraction has same UB as C if pointers from different allocations.",
      "guideline_title": "Subtraction between pointers shall only be applied to pointers that address elements of the same array C90 [Undefined 31], C99 [Undefined 45], C11 [Undefined 48]"
    },
    {
      "guideline_id": "Rule 18.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_nsvzzbldhq53",
        "fls_ppd1xwve3tr7",
        "fls_jep7p27kaqlp"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Pointer comparison only valid within same object. Rust: Raw pointer comparison (<, >) compares addresses but result is unspecified if not same allocation (not UB, just unspecified). Safe Rust references/slices don't have arbitrary comparison - use slice indices instead.",
      "guideline_title": "The relational operators >, >=, < and <= shall not be applied to expressions of pointer type except where they point into the same object C90 [Undefined 33], C99 [Undefined 50], C11 [Undefined 53]"
    },
    {
      "guideline_id": "Rule 18.4",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_xinykul167l",
        "fls_vpbikb73dw4k",
        "fls_ppd1xwve3tr7",
        "fls_5cm4gkt55hjh"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6",
        "6.1",
        "6.5",
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "applies to use of the unsafe API",
      "confidence": "high",
      "notes": "MISRA: Prefer array indexing over pointer arithmetic. Rust: Same principle applies - slice[i] preferred over raw pointer math. Rust idiom strongly favors iterators and indexing over manual pointer manipulation. Advisory rule applies equally to Rust.",
      "guideline_title": "The +, -, += and -= operators should not be applied to an expression of pointer type"
    },
    {
      "guideline_id": "Rule 18.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_3i4ou0dq64ny"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "14.2",
        "14.4.3",
        "14.7",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA: Limit pointer nesting to 2 levels for readability. Rust: Same principle - deeply nested Box<Box<Box<T>>> or ***ptr is hard to understand. Type aliases and newtype wrappers preferred. Advisory guideline for code clarity.",
      "guideline_title": "Declarations should contain no more than two levels of pointer nesting"
    },
    {
      "guideline_id": "Rule 18.6",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "rust_prevents",
      "fls_ids": [
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_svkx6szhr472",
        "fls_jep7p27kaqlp",
        "fls_u2mzjgiwbkz0"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "17",
        "17.1",
        "17.2",
        "15.1",
        "15.8",
        "15.8.1",
        "4.4.1",
        "4.4.2",
        "6.5.5",
        "6.8.1",
        "6.8.2"
      ],
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA: Don't let pointers outlive their pointees. Rust: Borrow checker enforces this at compile time for references. Lifetimes prevent dangling references. Raw pointers can dangle but creating/using them requires unsafe. This is a core Rust safety guarantee.",
      "guideline_title": "The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist C90 [Undefined 9, 26], C99 [Undefined 8, 9, 40], C11 [Undefined 9, 10, 43]"
    },
    {
      "guideline_id": "Rule 18.7",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Don't use C99 flexible array members. Rust: No flexible array members. Fixed-size arrays [T; N] or dynamically-sized slices [T]/Vec<T> used instead. DSTs (dynamically-sized types) exist but are different concept. The C feature doesn't exist in Rust.",
      "guideline_title": "Flexible array members shall not be declared C99 [Undefined 59], C11 [Undefined 62]"
    },
    {
      "guideline_id": "Rule 18.8",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "6.5.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Don't use C99 VLAs (stack-allocated variable-size arrays). Rust: No VLAs - array sizes must be const. Vec<T> for dynamic sizing (heap). Const generics allow some compile-time size flexibility. Stack allocation is always fixed-size in Rust.",
      "guideline_title": "Variable-length arrays shall not be used C99 [Unspecified 21; Undefined 69, 70], C11 [Unspecified 22; Undefined 16, 75, 76]"
    },
    {
      "guideline_id": "Rule 18.9",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_u2mzjgiwbkz0"
      ],
      "fls_rationale_type": "rust_prevents",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "15.1",
        "15.8",
        "15.8.1",
        "6.5.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Don't convert temporary arrays to pointers. Rust: Temporaries have defined lifetimes. Borrow checker prevents references to temporaries from escaping. The specific C issue (compound literal lifetime) doesn't exist in Rust's model.",
      "guideline_title": "An object with temporary lifetime shall not undergo array-to-pointer conversion C99 [Undefined 8, 35], C11 [Undefined 9]"
    },
    {
      "guideline_id": "Rule 18.10",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_uj0kpjwyld60"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.4.1",
        "4.4.2",
        "6.8.1",
        "6.8.2",
        "6.5.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA: Don't use pointers to VLA types. Rust: No VLAs, so no pointers to VLAs. Array types [T; N] require const N. Slices &[T] are the Rust equivalent for runtime-sized views, with safe bounds checking.",
      "guideline_title": "Pointers to variably-modified array types shall not be used C99 [Undefined 69, 70], C11 [Undefined 75, 76]"
    },
    {
      "guideline_id": "Rule 19.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3qnpv2z7yjil",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_id66vnaqw0zt",
        "fls_fmdn7n7s413d",
        "fls_cmq8ogs84ivh",
        "fls_jep7p27kaqlp",
        "fls_ucghxcnpaq2t"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.3.3.2",
        "6.5.5",
        "6.5.6",
        "6.5.7",
        "4.3",
        "4.5.3",
        "4.11.2.3",
        "19",
        "19.-2.7"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust unions require unsafe to read; safe Rust should use enums for tagged unions. Only applicable in unsafe Rust",
      "guideline_title": "An object shall not be assigned or copied to an overlapping object C90 [Undefined 34, 55], C99 [Undefined 51, 94], C11 [Undefined 54, 100]"
    },
    {
      "guideline_id": "Rule 19.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_9ucqbbd0s2yo",
        "fls_rjxpof29a3nl",
        "fls_7pby13muw48o",
        "fls_g1z6bpyjqxkz",
        "fls_jep7p27kaqlp",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_jd1inwz7ulyw",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh",
        "fls_8wnyln2nmg4y",
        "fls_fmdn7n7s413d",
        "fls_cmq8ogs84ivh"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.5.2",
        "4.11.2.2",
        "4.11",
        "4.11.1",
        "19",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.4",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4",
        "4.5.3",
        "4.11.2.3"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has similar struct semantics; Unsafe operations only exist in unsafe Rust by definition",
      "guideline_title": "A union member shall not be read unless it has been previously set C99 [Unspecified 10], C11 [Unspecified 11]"
    },
    {
      "guideline_id": "Rule 20.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "rules specific to the C preprocessor do not apply to Rust",
      "confidence": "medium",
      "notes": "MISRA ADD-6: rules specific to the C preprocessor do not apply to Rust. Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "#include directives should only be preceded by preprocessor directives or comments C90 [Undefined 56], C99 [Undefined 96, 97], C11 [Undefined 102, 103]"
    },
    {
      "guideline_id": "Rule 20.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name C90 [Undefined 14], C99 [Undefined 31], C11 [Undefined 34]"
    },
    {
      "guideline_id": "Rule 20.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing",
      "guideline_title": "The #include directive shall be followed by either a <filename> or \"filename\" sequence C90 [Undefined 48], C99 [Undefined 85], C11 [Undefined 91]"
    },
    {
      "guideline_id": "Rule 20.4",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "possible with raw identifiers but the compiler prevents visual conflicts",
      "confidence": "medium",
      "notes": "MISRA ADD-6: possible with raw identifiers but the compiler prevents visual conflicts. Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing",
      "guideline_title": "A macro shall not be defined with the same name as a keyword C90 [Undefined 56], C99 [Undefined 98], C11 [Undefined 104]"
    },
    {
      "guideline_id": "Rule 20.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "#undef should not be used"
    },
    {
      "guideline_id": "Rule 20.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "Tokens that look like a preprocessing directive shall not occur within a macro argument C90 [Undefined 50], C99 [Undefined 87], C11 [Undefined 93]"
    },
    {
      "guideline_id": "Rule 20.7",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "advisory",
      "misra_rust_comment": "possible to express with procedural macros only, not macro_rules",
      "confidence": "medium",
      "notes": "MISRA ADD-6: possible to express with procedural macros only, not macro_rules. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "Expressions resulting from the expansion of macro parameters shall be appropriately delimited [Koenig 78\u201381]"
    },
    {
      "guideline_id": "Rule 20.8",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1"
    },
    {
      "guideline_id": "Rule 20.9",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_21vnag69kbwe",
        "fls_izl8iuhoz9e0",
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_ydmnb7qnmzzq",
        "fls_jdknpu3kf865",
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "2.3",
        "14.4",
        "14.4.1",
        "14.4.3",
        "14.8",
        "14.2",
        "6",
        "6.1",
        "6.5"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has similar scoping rules with explicit shadowing",
      "guideline_title": "All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define\u2018d before evaluation"
    },
    {
      "guideline_id": "Rule 20.10",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "The # and ## preprocessor operators should not be used C90 [Unspecified 12; Undefined 51, 52] C99 [Unspecified 25; Undefined 3, 88, 89] C11 [Unspecified 26; Undefined 3, 94, 95]"
    },
    {
      "guideline_id": "Rule 20.11",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "A macro parameter immediately following a # operator shall not immediately be followed by a ## operator C90 [Unspecified 12], C99 [Unspecified 25], C11 [Unspecified 26]"
    },
    {
      "guideline_id": "Rule 20.12",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators"
    },
    {
      "guideline_id": "Rule 20.13",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "A line whose first token is # shall be a valid preprocessing directive"
    },
    {
      "guideline_id": "Rule 20.14",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has similar control flow with expressions; Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related"
    },
    {
      "guideline_id": "Rule 20.15",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "previously Rule 21.1",
      "confidence": "medium",
      "notes": "MISRA ADD-6: previously Rule 21.1. Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "#define and #undef shall not be used on a reserved identifier or reserved macro name C90 [Undefined 54, 57, 58, 62, 71] C99 [Undefined 93, 100, 101, 104, 108, 116, 118, 130] C11 [Undefined 99, 106, 107, 110, 114, 122, 126, 138]"
    },
    {
      "guideline_id": "Rule 21.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Similar function semantics with stronger type checking. Only applicable in unsafe Rust",
      "guideline_title": "The memory allocation and deallocation functions of <stdlib.h> shall not be used C90 [Unspecified 19; Undefined 9, 91, 92; Implementation G.3.14(28)] C99 [Unspecified 39, 40; Undefined 8, 9, 168\u2013171; Implementation J.3.12(35)] C11 [Unspecified 42, 43; Undefined 9, 10, 177\u2013181; Implementation J.3.12(37)]"
    },
    {
      "guideline_id": "Rule 21.4",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Rust has no setjmp/longjmp; uses panic/catch_unwind or Result; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust",
      "guideline_title": "The standard header file <setjmp.h> shall not be used C90 [Unspecified 14; Undefined 64\u201367] C99 [Unspecified 32; Undefined 118\u2013121, 173] C11 [Unspecified 35; Undefined 124\u2013127, 183] [Koenig 74]"
    },
    {
      "guideline_id": "Rule 21.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Rust has no native signal handling; use platform-specific crates; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust",
      "guideline_title": "The standard header file <signal.h> shall not be used C90 [Undefined 67\u201369; Implementation 48\u201352] C99 [Undefined 122\u2013127; Implementation J.3.12(12)] C11 [Undefined 128\u2013135, 185; Implementation J.3.12(14)] [Koenig 74]"
    },
    {
      "guideline_id": "Rule 21.6",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library input/output functions shall not be used C90 [Unspecified 2\u20135, 16\u201318; Undefined 77\u201389; Implementation G.3.14(12-27)] C99 [Unspecified 3\u20136, 34\u201337; Undefined 138\u2013166, 186; Implementation J.3.12(14\u201332)] C11 [Unspecified 4\u20137, 37-40; Undefined 146\u2013175, 198; Implementation J.3.12(16\u201334)]"
    },
    {
      "guideline_id": "Rule 21.7",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library functions atof, atoi, atol and atoll of <stdlib.h> shall not be used C90 [Undefined 90], C99 [Undefined 113], C11 [Undefined 119]"
    },
    {
      "guideline_id": "Rule 21.8",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library termination functions of <stdlib.h> shall not be used C90 [Undefined 93; Implementation G.3.14(29-30)] C99 [Undefined 172; Implementation J.3.12(36\u201337)] C11 [Undefined 182, 185; Implementation J.3.12(38-39)]"
    },
    {
      "guideline_id": "Rule 21.9",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library functions bsearch and qsort of <stdlib.h> shall not be used C90 [Unspecified 20, 21] C99 [Unspecified 41, 42; Undefined 176\u2013178] C11 [Unspecified 46, 47; Undefined 187\u2013189]"
    },
    {
      "guideline_id": "Rule 21.10",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library time and date functions shall not be used C90 [Unspecified 22; Undefined 80, 97; Implementation G.3.14(34,35)] C99 [Unspecified 43, 44; Undefined 146, 154, 182; Implementation J.3.12(39\u201342)] C11 [Unspecified 48, 49; Undefined 154, 162, 193, 197; Implementation J.3.12(41-45)]"
    },
    {
      "guideline_id": "Rule 21.11",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no external interface. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust has no setjmp/longjmp; uses panic/catch_unwind or Result",
      "guideline_title": "The standard header file <tgmath.h> should not be used C99 [Undefined 184, 185], C11 [Undefined 195, 196]"
    },
    {
      "guideline_id": "Rule 21.12",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust has no setjmp/longjmp; uses panic/catch_unwind or Result. Only applicable in unsafe Rust",
      "guideline_title": "The standard header file <fenv.h> shall not be used C99 [Unspecified 27, 28; Undefined 109\u2013112; Implementation J.3.6(8)] C11 [Unspecified 27, 28; Undefined 115\u2013118; Implementation J.3.6(9)]"
    },
    {
      "guideline_id": "Rule 21.13",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust",
      "guideline_title": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF C90 [Undefined 63], C99 [Undefined 107], C11 [Undefined 113]"
    },
    {
      "guideline_id": "Rule 21.14",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library function memcmp shall not be used to compare null terminated strings"
    },
    {
      "guideline_id": "Rule 21.15",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust",
      "guideline_title": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types"
    },
    {
      "guideline_id": "Rule 21.16",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust",
      "guideline_title": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type C99 [Unspecified 9], C11 [Unspecified 10]"
    },
    {
      "guideline_id": "Rule 21.17",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Safe Rust String/str types prevent buffer overflows and ensure valid UTF-8; unsafe can use raw pointers. Only applicable in unsafe Rust",
      "guideline_title": "Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters C90 [Undefined 96], C99 [Undefined 103, 180], C11 [Undefined 109, 191]"
    },
    {
      "guideline_id": "Rule 21.19",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust",
      "guideline_title": "The pointers returned by the Standard Library functions localeconv, getenv, setlocale or strerror shall only be used as if they have pointer to const-qualified type C90 [Undefined], C99 [Undefined 114, 115, 174], C11 [Undefined 120, 121, 184]"
    },
    {
      "guideline_id": "Rule 21.20",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust",
      "guideline_title": "The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function"
    },
    {
      "guideline_id": "Rule 21.21",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library function system of <stdlib.h> shall not be used C90 [Implementation G.3.14(29-32)] C99 [Undefined 175; Implementation J.3.2(11), J.3.12(38)] C11 [Undefined 186; Implementation J.3.2(12), J.3.12(40)]"
    },
    {
      "guideline_id": "Rule 21.22",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "12",
        "12.1",
        "12.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no external interface. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "All operand arguments to any type-generic macros declared in <tgmath.h> shall have an appropriate essential type C99 [Undefined 184], C11 [Undefined 195]"
    },
    {
      "guideline_id": "Rule 21.23",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "12",
        "12.1",
        "12.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no external interface. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros",
      "guideline_title": "All operand arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type"
    },
    {
      "guideline_id": "Rule 21.24",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "The random number generator functions of <stdlib.h> shall not be used"
    },
    {
      "guideline_id": "Rule 21.25",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has std::sync::atomic with similar memory ordering",
      "guideline_title": "All memory synchronization operations shall be executed in sequentially consistent order C11 [Undefined 5]"
    },
    {
      "guideline_id": "Rule 21.26",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_4agmmu5al6gt",
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh",
        "fls_vpbikb73dw4k"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "17",
        "17.1",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "4.4.3",
        "2.4.6",
        "2.4.6.1",
        "2.4.6.2",
        "4.4.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust",
      "guideline_title": "The Standard Library function mtx_timedlock() shall only be invoked on mutex objects of appropriate mutex type C11 [Undefined 196b]"
    },
    {
      "guideline_id": "Rule 22.1",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_u2mzjgiwbkz0",
        "fls_4jiw35pan7vn",
        "fls_rm4ncoopcdvj",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15.6",
        "15.7",
        "15.8",
        "15",
        "15.1",
        "15.2",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to resources acquired through FFI only",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to resources acquired through FFI only. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust",
      "guideline_title": "All resources obtained dynamically by means of Standard Library functions shall be explicitly released"
    },
    {
      "guideline_id": "Rule 22.2",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust has similar control flow with expressions. Only applicable in unsafe Rust",
      "guideline_title": "A block of memory shall only be freed if it was allocated by means of a Standard Library function C90 [Undefined 92], C99 [Undefined 169], C11 [Undefined 179]"
    },
    {
      "guideline_id": "Rule 22.3",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Rust has similar control flow with expressions; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust",
      "guideline_title": "The same file shall not be open for read and write access at the same time on different streams C90 [Implementation G.3.14(20)], C99 [Implementation J.3.12(22)], C11 [Implementation J.3.12(24)]"
    },
    {
      "guideline_id": "Rule 22.4",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust uses std::io and std::fs; different API design. Only applicable in unsafe Rust",
      "guideline_title": "There shall be no attempt to write to a stream which has been opened as read-only"
    },
    {
      "guideline_id": "Rule 22.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh",
        "fls_8wnyln2nmg4y",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "19.-2.1",
        "19.-2.2",
        "19.-2.3",
        "19.-2.5",
        "19.-2.6",
        "19.-2.7",
        "19.-2.8",
        "19.-2.9",
        "19.-2.10",
        "6.4.4",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Core Rust concept for safe memory access, applies to all Rust. Only applicable in unsafe Rust",
      "guideline_title": "A pointer to a FILE object shall not be dereferenced"
    },
    {
      "guideline_id": "Rule 22.6",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust",
      "guideline_title": "The value of a pointer to a FILE shall not be used after the associated stream has been closed C99 [Undefined 140], C11 [Undefined 148]"
    },
    {
      "guideline_id": "Rule 22.7",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros. Only applicable in unsafe Rust",
      "guideline_title": "The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF"
    },
    {
      "guideline_id": "Rule 22.8",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_dzq9cdz4ibsz",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi",
        "fls_pocsh1neugpc",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16",
        "16.1",
        "16.2",
        "6.5.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust",
      "guideline_title": "The value of errno shall be set to zero prior to a call to an errno- setting-function"
    },
    {
      "guideline_id": "Rule 22.9",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_dzq9cdz4ibsz",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi",
        "fls_pocsh1neugpc",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16",
        "16.1",
        "16.2",
        "6.5.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust",
      "guideline_title": "The value of errno shall be tested against zero after calling an errno- setting-function"
    },
    {
      "guideline_id": "Rule 22.10",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_dzq9cdz4ibsz",
        "fls_k02nt1m5fq1z",
        "fls_hi1iz0gbnksi",
        "fls_pocsh1neugpc",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "16",
        "16.1",
        "16.2",
        "6.5.3",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17",
        "17.1",
        "17.2"
      ],
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust",
      "guideline_title": "The value of errno shall only be tested when the last function to be called was an errno-setting-function"
    },
    {
      "guideline_id": "Rule 22.11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs",
      "guideline_title": "A thread that was previously either joined or detached shall not be subsequently joined nor detached C11 [Undefined 196d]"
    },
    {
      "guideline_id": "Rule 22.12",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust",
      "guideline_title": "Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions C11 [Undefined 5, 9, 10, 11, 196f]"
    },
    {
      "guideline_id": "Rule 22.13",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards",
      "guideline_title": "Thread objects, thread synchronization objects and thread-specific storage pointers shall have appropriate storage duration C11 [Undefined 9, 10, 11]"
    },
    {
      "guideline_id": "Rule 22.14",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3xvm61x0t251",
        "fls_svkx6szhr472",
        "fls_8wnyln2nmg4y",
        "fls_jep7p27kaqlp",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "15.2",
        "15.1",
        "6.4.4",
        "19",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to creating synchronization objects before threads that use them",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to creating synchronization objects before threads that use them. Safe Rust requires initialization before use; unsafe can use MaybeUninit; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass",
      "guideline_title": "Thread synchronization objects shall be initialized before being accessed C11 [Undefined 9]"
    },
    {
      "guideline_id": "Rule 22.15",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to releasing synchronization objects after threads that use them",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to releasing synchronization objects after threads that use them. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass",
      "guideline_title": "Thread synchronization objects and thread-specific storage pointers shall not be destroyed until after all threads accessing them have terminated C11 [Undefined 9, 10, 11, 196f]"
    },
    {
      "guideline_id": "Rule 22.16",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust",
      "guideline_title": "All mutex objects locked by a thread shall be explicitly unlocked by the same thread C11 [Undefined 196c]"
    },
    {
      "guideline_id": "Rule 22.17",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_hbbek3z4wtcs",
        "fls_xztr1kebz8bo",
        "fls_airvr79xkcag",
        "fls_77scxuomlbgs",
        "fls_lnpyb285qdiy",
        "fls_jm6l7b90h6wa",
        "fls_sf4qnd43z2wc",
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.6",
        "4.6.1",
        "4.6.2",
        "15.5",
        "14.4.7",
        "6.9",
        "6.10",
        "6.11",
        "6.12",
        "6.13",
        "6.14",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only accessible through unsafe extern \u201cC\u201d. Similar function semantics with stronger type checking; Rust has similar control flow with expressions. Only applicable in unsafe Rust",
      "guideline_title": "No thread shall unlock a mutex or call cnd_wait() or cnd_timedwait() for a mutex it has not locked before C11 [Undefined 196c]"
    },
    {
      "guideline_id": "Rule 22.18",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_hbbek3z4wtcs",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "4.12.1",
        "4.6",
        "17",
        "17.1",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust allows recursion; stack overflow is runtime behavior; Rust has Mutex<T> and RwLock<T> with RAII guards",
      "guideline_title": "Non-recursive mutexes shall not be recursively locked C11 [Undefined 196a, 196c]"
    },
    {
      "guideline_id": "Rule 22.19",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_ids": [
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2",
        "fls_vyc9vcuamlph"
      ],
      "fls_rationale_type": "direct_mapping",
      "fls_sections": [
        "17",
        "17.1",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9",
        "17.2"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has Mutex<T> and RwLock<T> with RAII guards; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs",
      "guideline_title": "A condition variable shall be associated with at most one mutex object"
    },
    {
      "guideline_id": "Rule 22.20",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "fls_ids": [
        "fls_3i4ou0dq64ny",
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_5cm4gkt55hjh",
        "fls_qztk0bkju9u",
        "fls_jep7p27kaqlp",
        "fls_jd1inwz7ulyw",
        "fls_3v733mnewssy",
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph",
        "fls_ronnwodjjjsh",
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_5eima0pd31c0",
        "fls_afafmafz4hf2"
      ],
      "fls_rationale_type": "partial_mapping",
      "fls_sections": [
        "4.7",
        "4.7.2",
        "4.7.3",
        "15.3",
        "15.4",
        "6.5.2",
        "6.5.1",
        "19",
        "19.-2.4",
        "17",
        "17.1",
        "17.2",
        "15",
        "15.1",
        "15.2",
        "15.6",
        "15.7",
        "15.8",
        "15.8.1",
        "15.9"
      ],
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass",
      "guideline_title": "Thread-specific storage pointers shall be created before being accessed C11 [Undefined 9, 10, 11, 196e, 196f]"
    },
    {
      "guideline_id": "Rule 23.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic",
      "guideline_title": "A generic selection should only be expanded from a macro"
    },
    {
      "guideline_id": "Rule 23.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic",
      "guideline_title": "A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression"
    },
    {
      "guideline_id": "Rule 23.3",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.14",
        "5.4.5",
        "5.2",
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust match is exhaustive and more powerful than C switch; Rust uses generics and traits instead of _Generic",
      "guideline_title": "A generic selection should contain at least one non-default association"
    },
    {
      "guideline_id": "Rule 23.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust uses generics and traits instead of _Generic",
      "guideline_title": "A generic association shall list an appropriate type"
    },
    {
      "guideline_id": "Rule 23.5",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust uses generics and traits instead of _Generic",
      "guideline_title": "A generic selection should not depend on implicit pointer type conversion"
    },
    {
      "guideline_id": "Rule 23.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_ckvjj4tt1hh2",
        "fls_isyftqu120l",
        "fls_izdv9i4spokw",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6",
        "6.1",
        "6.5",
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has well-defined evaluation order in most cases; Rust uses generics and traits instead of _Generic",
      "guideline_title": "The controlling expression of a generic selection shall have an essential type that matches its standard type"
    },
    {
      "guideline_id": "Rule 23.7",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic",
      "guideline_title": "A generic selection that is expanded from a macro should evaluate its argument only once"
    },
    {
      "guideline_id": "Rule 23.8",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_ids": [
        "fls_e5td0fa92fay",
        "fls_fyskeih6twyb",
        "fls_7dbd5t2750ce",
        "fls_y2k5paj8m8ug",
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm"
      ],
      "fls_rationale_type": "no_equivalent",
      "fls_sections": [
        "6.14",
        "5.4.5",
        "5.2",
        "12",
        "12.1",
        "12.3"
      ],
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust match is exhaustive and more powerful than C switch; Rust uses generics and traits instead of _Generic",
      "guideline_title": "A default association shall appear as either the first or the last association of a generic selection"
    }
  ]
}