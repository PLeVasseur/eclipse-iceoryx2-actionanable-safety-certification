{
  "standard": "MISRA-C",
  "standard_version": "2025",
  "fls_version": "1.0 (2024)",
  "mapping_date": "2025-12-31",
  "methodology": "Semantic embedding similarity + manual verification. High confidence mappings verified against MISRA rationale and FLS content.",
  "statistics": {
    "total_guidelines": 223,
    "mapped": 196,
    "unmapped": 27,
    "not_applicable": 95,
    "rust_prevents": 2,
    "preserved_high_confidence": 14,
    "avg_matches_per_guideline": 8.9,
    "matches_by_category": {
      "section": 699,
      "general": 18,
      "legality_rules": 1044,
      "implementation_requirements": 5,
      "dynamic_semantics": 137,
      "undefined_behavior": 31
    },
    "thresholds": {
      "section": 0.5,
      "paragraph": 0.55
    }
  },
  "mappings": [
    {
      "guideline_id": "Dir 1.1",
      "guideline_title": "Any implementation-defined behaviour on which the output of the program depends shall be documented and understood C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.-2.2",
          "fls_title": "ABI",
          "score": 0.64,
          "reason": "Section-level similarity match (score: 0.64)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.631,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_dv1qish8svc",
          "category": -1,
          "fls_section": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "score": 0.624,
          "reason": "Per FLS: 'This document is made available for contribution and review, and ca...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.-2.5",
          "fls_title": "Assembly Instructions",
          "score": 0.622,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_8kqo952gjhaf",
          "category": -2,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.614,
          "reason": "Per FLS: 'Unsafety is the presence of [unsafe operation]s and [unsafe trait i...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "category": 0,
          "fls_section": "1.-1.3",
          "fls_title": "Extent",
          "score": 0.614,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_99b7xi1bkgih",
          "category": 0,
          "fls_section": "1.-5.2",
          "fls_title": "Conformity",
          "score": 0.608,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_pl0fyjcwslqm",
          "category": -5,
          "fls_section": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "score": 0.586,
          "reason": "Per FLS: 'A tool that conforms to this document shall produce for the executi...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_nnmx2qsu14ft",
          "category": -5,
          "fls_section": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "score": 0.585,
          "reason": "Per FLS: 'The external effect of the execution of a Rust program is defined i...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_x7ct9k82fpgn",
          "category": -2,
          "fls_section": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "score": 0.578,
          "reason": "Per FLS: 'extern \"C\" - The default ABI of C code, referred to as extern C ABI.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_z2kzyin8dyr7",
          "category": -2,
          "fls_section": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "score": 0.574,
          "reason": "Per FLS: 'A function with an ABI but without a specified ABI kind has implici...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.571,
          "reason": "Per FLS: 'A variadic part indicates the presence of C-like optional parameters.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_jd1inwz7ulyw",
          "category": -2,
          "fls_section": "19.-2.4",
          "fls_title": "Unsafety",
          "score": 0.57,
          "reason": "Per FLS: 'Dereferencing a value of a raw pointer type.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_r2aoetnwhjkf",
          "category": -2,
          "fls_section": "fls_j9l8wn6wgm06",
          "fls_title": "Registers",
          "score": 0.567,
          "reason": "Per FLS: '- ARM - r6 - Internally used by LLVM as a base pointer for [functio...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_8s1vddh8vdhy",
          "category": -2,
          "fls_section": "fls_ohhsmifo0urd",
          "fls_title": "Type Representation",
          "score": 0.564,
          "reason": "Per FLS: 'C representation lays out a type such that the type is interoperabl...' (similarity: 0.56)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 1.2",
      "guideline_title": "The use of language extensions should be minimized",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dv1qish8svc",
          "category": -1,
          "fls_section": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "score": 0.712,
          "reason": "Per FLS: 'This document is made available for contribution and review, and ca...' (similarity: 0.71)"
        },
        {
          "fls_id": "fls_9cd746qe40ag",
          "category": 0,
          "fls_section": "1.-1.6",
          "fls_title": "Versioning",
          "score": 0.59,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_xscgklvg1wd2",
          "category": 0,
          "fls_section": "1.-1.4",
          "fls_title": "Structure",
          "score": 0.583,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.-2.2",
          "fls_title": "ABI",
          "score": 0.572,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_sph1a3sapinh",
          "category": -1,
          "fls_section": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "score": 0.557,
          "reason": "Per FLS: 'The language-defined libraries that a conforming tool is required t...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "category": 0,
          "fls_section": "1.-1.3",
          "fls_title": "Extent",
          "score": 0.546,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_ckvjj4tt1hh2",
          "category": 0,
          "fls_section": "6.-2.1",
          "fls_title": "Expressions",
          "score": 0.542,
          "reason": "Section-level similarity match (score: 0.54)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "previously Rule 1.2",
      "confidence": "medium",
      "notes": "MISRA ADD-6: previously Rule 1.2"
    },
    {
      "guideline_id": "Dir 2.1",
      "guideline_title": "All source files shall compile without any compilation errors",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_a0u9nnaf6drz",
          "category": -2,
          "fls_section": "fls_u1afezy1ye99",
          "fls_title": "Conditional Compilation",
          "score": 0.569,
          "reason": "Per FLS: 'Conditional compilation is the process of compiling conditionally-c...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_9cd746qe40ag",
          "category": 0,
          "fls_section": "1.-1.6",
          "fls_title": "Versioning",
          "score": 0.554,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_9stc6nul6vq9",
          "category": -2,
          "fls_section": "fls_u1afezy1ye99",
          "fls_title": "Conditional Compilation",
          "score": 0.551,
          "reason": "Per FLS: 'Conditionally-compiled source code is source code that may or may n...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_u1afezy1ye99",
          "category": 0,
          "fls_section": "18.-2.6",
          "fls_title": "Conditional Compilation",
          "score": 0.542,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_hdwwrsyunir",
          "category": 0,
          "fls_section": "18",
          "fls_title": "Program Structure and Compilation",
          "score": 0.533,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_s35hob3i7lr",
          "category": 0,
          "fls_section": "18.-2.1",
          "fls_title": "Source Files",
          "score": 0.524,
          "reason": "Section-level similarity match (score: 0.52)"
        },
        {
          "fls_id": "fls_99b7xi1bkgih",
          "category": 0,
          "fls_section": "1.-5.2",
          "fls_title": "Conformity",
          "score": 0.507,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 3.1",
      "guideline_title": "All code shall be traceable to documented requirements",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "No high-confidence FLS matches found"
    },
    {
      "guideline_id": "Dir 4.1",
      "guideline_title": "Run-time failures shall be minimized C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "6.-1.2",
          "fls_title": "Arithmetic Overflow",
          "score": 0.598,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_FxLnXeGT2n9u",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.593,
          "reason": "Per FLS: 'If unsigned integer division is performed and the right operand is ...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_Q9dhNiICGIfr",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.593,
          "reason": "Per FLS: 'If unsigned integer division is performed and the right operand is ...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.592,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_b46nyamfqxdu",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.584,
          "reason": "Per FLS: 'The evaluation of a constant expression that results in arithmetic ...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_section": "6.-2.17",
          "fls_title": "Error Propagation Expression",
          "score": 0.582,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_Vy0DyZqfy7Iv",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.578,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_Et5gp1I7VqBX",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.571,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.571,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_R48VKcEIbfXC",
          "category": -3,
          "fls_section": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.569,
          "reason": "Per FLS: 'Evaluation of the expression may result in a panic. #.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_NcLf4o1dpniS",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.563,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_4nnqz4etisgw",
          "category": -3,
          "fls_section": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.556,
          "reason": "Per FLS: 'If the [type]s of both [operand]s are [integer type]s or [floating-...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_albbLSTYtmyq",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.554,
          "reason": "Per FLS: 'If two's complement division is performed and the right operand is ...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_kN0HnldvDXSg",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.553,
          "reason": "Per FLS: 'If two's complement division is performed and the right operand is ...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.-2.1",
          "fls_title": "Values",
          "score": 0.542,
          "reason": "Section-level similarity match (score: 0.54)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "often in the form of panics",
      "confidence": "medium",
      "notes": "MISRA ADD-6: often in the form of panics"
    },
    {
      "guideline_id": "Dir 4.2",
      "guideline_title": "All usage of assembly language should be documented",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.-2.5",
          "fls_title": "Assembly Instructions",
          "score": 0.614,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_caqznttql5p8",
          "category": -2,
          "fls_section": "fls_6momhvgx4w21",
          "fls_title": "Directive Support",
          "score": 0.582,
          "reason": "Per FLS: 'The common [assembly directive]s are as follows: #.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_helnk2iz8qhp",
          "category": -2,
          "fls_section": "fls_z1il3w9nulzy",
          "fls_title": "Inline Assembly",
          "score": 0.58,
          "reason": "Per FLS: 'Inline assembly is available on the following architectures:' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_4jr7eg6e0g4w",
          "category": -2,
          "fls_section": "fls_e0896uk0mdyl",
          "fls_title": "Assembly Instructions",
          "score": 0.576,
          "reason": "Per FLS: 'An assembly instruction is a string literal that represents a low-l...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_pnoh31rvu9a6",
          "category": -2,
          "fls_section": "fls_z1il3w9nulzy",
          "fls_title": "Inline Assembly",
          "score": 0.573,
          "reason": "Per FLS: 'x86 and x86-64' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_leamdp1r3hez",
          "category": -2,
          "fls_section": "fls_z1il3w9nulzy",
          "fls_title": "Inline Assembly",
          "score": 0.571,
          "reason": "Per FLS: 'Inline assembly is hand-written assembly code that is integrated in...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_h8549stij7pj",
          "category": -2,
          "fls_section": "fls_ylli0ortyegk",
          "fls_title": "Assembly Options",
          "score": 0.569,
          "reason": "Per FLS: '[Assembly option]s att_syntax and raw shall appear only in GlobalAs...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_ylli0ortyegk",
          "category": 0,
          "fls_section": "22.-2.9",
          "fls_title": "Assembly Options",
          "score": 0.569,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_ihjhpy4osl53",
          "category": -2,
          "fls_section": "fls_e0896uk0mdyl",
          "fls_title": "Assembly Instructions",
          "score": 0.564,
          "reason": "Per FLS: 'An assembly instruction shall use the syntax of format strings as d...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_2hdsgqko25l5",
          "category": -2,
          "fls_section": "fls_6momhvgx4w21",
          "fls_title": "Directive Support",
          "score": 0.561,
          "reason": "Per FLS: 'The following [assembly directive]s are relevant on x86 targets. #.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_3fg60jblx0xb",
          "category": -2,
          "fls_section": "fls_z1il3w9nulzy",
          "fls_title": "Inline Assembly",
          "score": 0.559,
          "reason": "Per FLS: 'Inline assembly is written as an assembly code block that is wrappe...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_6momhvgx4w21",
          "category": 0,
          "fls_section": "22.-2.7",
          "fls_title": "Directive Support",
          "score": 0.559,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_2n9el98anp8c",
          "category": -2,
          "fls_section": "fls_z1il3w9nulzy",
          "fls_title": "Inline Assembly",
          "score": 0.551,
          "reason": "Per FLS: 'RISC-V' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_hejgghwzblf",
          "category": 0,
          "fls_section": "22.-2.4",
          "fls_title": "Register Arguments",
          "score": 0.519,
          "reason": "Section-level similarity match (score: 0.52)"
        },
        {
          "fls_id": "fls_hdwwrsyunir",
          "category": 0,
          "fls_section": "18",
          "fls_title": "Program Structure and Compilation",
          "score": 0.515,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 4.3",
      "guideline_title": "Assembly language shall be encapsulated and isolated",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_z1il3w9nulzy",
          "category": 0,
          "fls_section": "22.1",
          "fls_title": "Inline Assembly",
          "score": 0.588,
          "reason": "Parent section covering Rust's structured inline assembly approach. All assembly in Rust must go through the macro-based system defined here."
        },
        {
          "fls_id": "fls_ecteot716j8j",
          "category": -2,
          "fls_section": "22.8",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": null,
          "reason": "Per FLS: 'Assembly code blocks are embedded within Rust source code using macros core::arch::asm, core::arch::global_asm, and core::arch::naked_asm.' This directly addresses MISRA's encapsulation requirement - Rust mandates macro encapsulation."
        },
        {
          "fls_id": "fls_4lb6yh12w1cv",
          "category": -2,
          "fls_section": "22.8",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": 0.62,
          "reason": "Per FLS: 'Invoking macro core::arch::asm causes the related assembly code block to be integrated into the generated assembly of the function where the macro invocation took place.' Assembly is isolated to specific macro invocations."
        },
        {
          "fls_id": "fls_qezwyridmjob",
          "category": 0,
          "fls_section": "22.8",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": 0.533,
          "reason": "Section describing the macro-based encapsulation mechanism for inline assembly."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.5",
          "score": 0.691,
          "reason": "High similarity due to 'assembly' keyword but covers instruction syntax details, not encapsulation requirements."
        },
        {
          "fls_id": "fls_ylli0ortyegk",
          "category": 0,
          "fls_section": "22.6",
          "score": 0.662,
          "reason": "About assembly options like att_syntax, not encapsulation."
        },
        {
          "fls_id": "fls_6momhvgx4w21",
          "category": 0,
          "fls_section": "22.7",
          "score": 0.656,
          "reason": "About assembler directives (.byte, .align), not Rust encapsulation requirements."
        },
        {
          "fls_id": "fls_hejgghwzblf",
          "category": 0,
          "fls_section": "22.4",
          "score": 0.58,
          "reason": "Register handling implementation details, not encapsulation."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "confidence": "high",
      "notes": "Rust enforces MISRA Dir 4.3 by design: all inline assembly must use the core::arch::{asm, global_asm, naked_asm} macros. There is no way to write raw assembly without macro encapsulation. This satisfies MISRA's goal of encapsulation and isolation."
    },
    {
      "guideline_id": "Dir 4.4",
      "guideline_title": "Sections of code should not be \u201ccommented out\u201d",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_32ncjvj2kn7z",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.556,
          "reason": "Per FLS: '[Inner block doc]s and [inner line doc]s shall apply to an enclosin...' (similarity: 0.56)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 4.5",
      "guideline_title": "Identifiers in the same name space with overlapping visibility should be typographically unambiguous",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_jpecw46eh061",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.679,
          "reason": "Per FLS: 'A pure identifier shall follow the specification in Unicode Standar...' (similarity: 0.68)"
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.672,
          "reason": "Per FLS: 'Two [identifier]s are considered the same if they consist of the sa...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_irwcldiotei2",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.654,
          "reason": "Per FLS: 'A pure identifier shall be restricted to characters in category Asc...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.-2.3",
          "fls_title": "Identifiers",
          "score": 0.626,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_vde7gev5rz4q",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.598,
          "reason": "Per FLS: '[Identifier]s are normalized using Normalization Form C as defined ...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_ypa86oqxhn9u",
          "category": 0,
          "fls_section": "2.-2.15",
          "fls_title": "Character Literals",
          "score": 0.542,
          "reason": "Section-level similarity match (score: 0.54)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "\u201cambiguity\u201d is determined by the project",
      "confidence": "medium",
      "notes": "MISRA ADD-6: \u201cambiguity\u201d is determined by the project"
    },
    {
      "guideline_id": "Dir 4.6",
      "guideline_title": "typedefs that indicate size and signedness should be used in place of the basic integer types",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "all primitive types already fulfil this",
      "confidence": "high",
      "notes": "Rust primitive types (i8, u16, i32, etc.) already encode size and signedness in the type name. No typedefs needed for this purpose. Per ADD-6: 'all primitive types already fulfil this'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.7",
      "guideline_title": "If a function returns error information, then that error information shall be tested",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ab4vhq4nwn7f",
          "category": -2,
          "fls_section": "fls_pocsh1neugpc",
          "fls_title": "Error Propagation Expression",
          "score": 0.553,
          "reason": "Per FLS: 'The type of an error propagation expression is associated type core...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_dv2j1fvvnk1t",
          "category": 0,
          "fls_section": "13.-2.44",
          "fls_title": "Attribute ``test``",
          "score": 0.527,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_section": "6.-2.17",
          "fls_title": "Error Propagation Expression",
          "score": 0.512,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "prefer Option, Result, etc.",
      "confidence": "medium",
      "notes": "MISRA ADD-6: prefer Option, Result, etc."
    },
    {
      "guideline_id": "Dir 4.8",
      "guideline_title": "If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's module system and visibility controls replace C's incomplete type pattern for information hiding. Use `pub(crate)` or private modules instead.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.9",
      "guideline_title": "A function should be used in preference to a function-like macro where they are interchangeable",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_2d6bqnpy6tvs",
          "category": 0,
          "fls_section": "20.-2.6",
          "fls_title": "Function-like Macros",
          "score": 0.643,
          "reason": "Section-level similarity match (score: 0.64)"
        },
        {
          "fls_id": "fls_ojr30lf6jfx0",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.628,
          "reason": "Per FLS: 'The macro implementation function of a function-like macro shall be...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_lfmb22bfnrye",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.594,
          "reason": "Per FLS: 'A function-like macro is invoked using a macro invocation.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_utd3zqczix",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.593,
          "reason": "Per FLS: 'A function-like macro is a procedural macro that consumes a stream ...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_ypio6boj3pwf",
          "category": 0,
          "fls_section": "13.-2.5",
          "fls_title": "Attribute ``inline``",
          "score": 0.59,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_vtzuplb1p3s",
          "category": -2,
          "fls_section": "fls_wn1i6hzg2ff7",
          "fls_title": "Procedural Macros",
          "score": 0.584,
          "reason": "Per FLS: 'A macro implementation function is the function that encapsulates t...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_ofzql79i9if",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.583,
          "reason": "Per FLS: 'It shall lack [function qualifier]s,' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_j1wsyzip2qb3",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.577,
          "reason": "Per FLS: 'It shall lack [generic parameter]s,' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_417hvhvj2554",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.576,
          "reason": "Per FLS: 'Macro expansion of [function-like macro]s proceeds as follows: #.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_wn1i6hzg2ff7",
          "category": 0,
          "fls_section": "20.-2.5",
          "fls_title": "Procedural Macros",
          "score": 0.571,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_fbgal48cgj44",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.555,
          "reason": "Per FLS: 'The sole parameter of the macro implementation function captures th...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_wjldgtio5o75",
          "category": 0,
          "fls_section": "20.-2.10",
          "fls_title": "Macro Expansion",
          "score": 0.551,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_Sd6rUmpEb355",
          "category": 0,
          "fls_section": "13.-2.9",
          "fls_title": "Attribute ``naked``",
          "score": 0.524,
          "reason": "Section-level similarity match (score: 0.52)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 4.10",
      "guideline_title": "Precautions shall be taken in order to prevent the contents of a header file being included more than once",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's module system prevents duplicate inclusion inherently. No header guards needed - each module is compiled once. `mod` declarations handle inclusion.",
      "accepted_matches": [],
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.11",
      "guideline_title": "The validity of values passed to library functions shall be checked C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_emcNJzl2tHSA",
          "category": -2,
          "fls_section": "fls_wsfw8xF3vniL",
          "fls_title": "Structural Equality",
          "score": 0.614,
          "reason": "Per FLS: 'Bool, char, [function pointer type]s, [integer type]s, str, and [ra...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.605,
          "reason": "Per FLS: 'A variadic part indicates the presence of C-like optional parameters.' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_ZFQhOxO3jpby",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.596,
          "reason": "Per FLS: 'If there are any remaining [floating-point type variable]s that hav...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_sxnnkzmuvexa",
          "category": -2,
          "fls_section": "fls_ld0ize96cm6m",
          "fls_title": "Preludes",
          "score": 0.593,
          "reason": "Per FLS: '[Floating-point type]s f32 and f64.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_8kqo952gjhaf",
          "category": -2,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.577,
          "reason": "Per FLS: 'Unsafety is the presence of [unsafe operation]s and [unsafe trait i...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.568,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_fobs8ebt7dhc",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.566,
          "reason": "Per FLS: '[Struct expression]s,' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_z2kzyin8dyr7",
          "category": -2,
          "fls_section": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "score": 0.565,
          "reason": "Per FLS: 'A function with an ABI but without a specified ABI kind has implici...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.565,
          "reason": "Per FLS: 'It is a validity invariant for a value of a function pointer type t...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_niky8lbkvej9",
          "category": -2,
          "fls_section": "fls_dv2j1fvvnk1t",
          "fls_title": "Attribute ``test``",
          "score": 0.557,
          "reason": "Per FLS: 'A testing function that returns core::result::Result<(), E> passes ...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_Gr1ixJ9vFjUm",
          "category": -1,
          "fls_section": "fls_8gPCPVc99pXJ",
          "fls_title": "Call Conformance",
          "score": 0.554,
          "reason": "Per FLS: 'The type of a matched argument operand and the type of the correspo...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_29tlg1vyqay2",
          "category": 0,
          "fls_section": "2.-2.14",
          "fls_title": "Float Literals",
          "score": 0.549,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.544,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.-2.2",
          "fls_title": "ABI",
          "score": 0.537,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_wrvjizrqf3po",
          "category": 0,
          "fls_section": "4.-2.4",
          "fls_title": "Char Type",
          "score": 0.532,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 4.12",
      "guideline_title": "Dynamic memory allocation shall not be used",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "No high-confidence FLS matches found"
    },
    {
      "guideline_id": "Dir 4.13",
      "guideline_title": "Functions which are designed to provide operations on a resource should be called in an appropriate sequence",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.-2.3",
          "fls_title": "Statics",
          "score": 0.618,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.612,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.-2.5",
          "fls_title": "Assembly Instructions",
          "score": 0.611,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.-2.2",
          "fls_title": "ABI",
          "score": 0.606,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_dv1qish8svc",
          "category": -1,
          "fls_section": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "score": 0.59,
          "reason": "Per FLS: 'This document is made available for contribution and review, and ca...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.581,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_98vyqh9bzigx",
          "category": -3,
          "fls_section": "fls_qezwyridmjob",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": 0.557,
          "reason": "Per FLS: 'The evaluation of a macro invocation to macro core::arch::asm or ma...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_eeocxst9vafn",
          "category": -3,
          "fls_section": "fls_xdvdl2ssnhlo",
          "fls_title": "Statics",
          "score": 0.55,
          "reason": "Per FLS: 'All [path]s that refer to a static refer to the same memory location.' (similarity: 0.55)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 4.14",
      "guideline_title": "The validity of values received from external sources shall be checked C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8kqo952gjhaf",
          "category": -2,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.565,
          "reason": "Per FLS: 'Unsafety is the presence of [unsafe operation]s and [unsafe trait i...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.535,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.-2.1",
          "fls_title": "Values",
          "score": 0.523,
          "reason": "Section-level similarity match (score: 0.52)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 4.15",
      "guideline_title": "Evaluation of floating-point expressions shall not lead to the undetected generation of infinities and NaNs C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_nuFAwLHOdQBx",
          "category": -3,
          "fls_section": "fls_b4xporvr64s",
          "fls_title": "Floating Point Types",
          "score": 0.626,
          "reason": "Per FLS: 'Operations on values of [floating point type]s may not preserve the...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_29tlg1vyqay2",
          "category": 0,
          "fls_section": "2.-2.14",
          "fls_title": "Float Literals",
          "score": 0.615,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_JP8YSbxSN0Ym",
          "category": -2,
          "fls_section": "fls_2krxnq8q9ef1",
          "fls_title": "Literal Patterns",
          "score": 0.597,
          "reason": "Per FLS: 'A numeric literal pattern's numeric literal value shall not be a IE...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_cx86k8yfjhht",
          "category": -3,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.583,
          "reason": "Per FLS: 'Produces f32::INFINITY or f64::INFINITY of the same sign as the val...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_sxnnkzmuvexa",
          "category": -2,
          "fls_section": "fls_ld0ize96cm6m",
          "fls_title": "Preludes",
          "score": 0.574,
          "reason": "Per FLS: '[Floating-point type]s f32 and f64.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "6.-1.2",
          "fls_title": "Arithmetic Overflow",
          "score": 0.565,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_b46nyamfqxdu",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.56,
          "reason": "Per FLS: 'The evaluation of a constant expression that results in arithmetic ...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_2etd73f8jg2n",
          "category": -3,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.557,
          "reason": "Per FLS: 'Produces f32::INFINITY of the same sign as the value of the operand...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_Et5gp1I7VqBX",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.555,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_b4xporvr64s",
          "category": 0,
          "fls_section": "4.-2.5",
          "fls_title": "Floating Point Types",
          "score": 0.54,
          "reason": "Section-level similarity match (score: 0.54)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "Rust implements IEEE-754",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Rust implements IEEE-754"
    },
    {
      "guideline_id": "Dir 5.1",
      "guideline_title": "There shall be no data races between threads C11 [Undefined 5]",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_section": "17.1",
          "fls_title": "Concurrency",
          "score": 0.734,
          "reason": "Parent section defining Rust's concurrency model, which is designed to prevent data races."
        },
        {
          "fls_id": "fls_tx4b8r6i93n4",
          "category": -2,
          "fls_section": "17.1",
          "fls_title": "Concurrency",
          "score": 0.684,
          "reason": "Per FLS: 'A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization...' This matches MISRA's definition."
        },
        {
          "fls_id": "fls_isypweqewe78",
          "category": -4,
          "fls_section": "17.1",
          "fls_title": "Concurrency",
          "score": 0.675,
          "reason": "Per FLS: 'It is undefined behavior if two or more threads engage in a data race.' Rust explicitly classifies data races as UB."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_section": "17.2",
          "fls_title": "Send and Sync",
          "score": 0.541,
          "reason": "Section describing Rust's compile-time mechanism for preventing data races via Send and Sync traits."
        },
        {
          "fls_id": "fls_n5l17mlglq11",
          "category": -2,
          "fls_section": "17.2",
          "fls_title": "Send and Sync",
          "score": null,
          "reason": "Per FLS: 'The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.' This is Rust's primary compile-time data race prevention mechanism."
        },
        {
          "fls_id": "fls_zgemofbs5q2x",
          "category": -2,
          "fls_section": "17.2",
          "fls_title": "Send and Sync",
          "score": null,
          "reason": "Per FLS: 'A sync type shall have values that are allowed to be shared across multiple threads at any given time without incurring data races.'"
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.3",
          "fls_title": "Atomics",
          "score": 0.566,
          "reason": "Rust's atomic types provide safe concurrent access, addressing MISRA's recommendation for atomic synchronization."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.1",
          "score": 0.562,
          "reason": "General unsafety section. While unsafe code can cause data races, this section is not specifically about data race prevention."
        },
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.3",
          "score": 0.501,
          "reason": "About static storage duration, not data race prevention mechanisms."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "confidence": "high",
      "notes": "Rust provides strong data race prevention via the Send/Sync trait system, but per MISRA ADD-6: 'not all safe Rust types are race-free'. Safe Rust prevents memory-level data races but logical races (e.g., with atomics) are still possible. In unsafe Rust, the programmer must manually ensure data race freedom."
    },
    {
      "guideline_id": "Dir 5.2",
      "guideline_title": "There shall be no deadlocks between threads",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_section": "17.-1.1",
          "fls_title": "Concurrency",
          "score": 0.552,
          "reason": "Section-level similarity match (score: 0.55)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Dir 5.3",
      "guideline_title": "There shall be no dynamic thread creation C11",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_n6q7bksyn1m",
          "category": -3,
          "fls_section": "fls_k02nt1m5fq1z",
          "fls_title": "Panic",
          "score": 0.557,
          "reason": "Per FLS: 'Control flow halts the execution of the current thread. #.' (similarity: 0.56)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 1.1",
      "guideline_title": "The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation\u2019s translation limits",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_7tm19jxtffc8",
          "category": -1,
          "fls_section": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "score": 0.632,
          "reason": "Per FLS: 'The violations that a conforming tool is required to detect, and th...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_99b7xi1bkgih",
          "category": 0,
          "fls_section": "1.-5.2",
          "fls_title": "Conformity",
          "score": 0.619,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "category": 0,
          "fls_section": "1.-1.3",
          "fls_title": "Extent",
          "score": 0.618,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_GZmxrO61eiJ1",
          "category": -5,
          "fls_section": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "score": 0.604,
          "reason": "Per FLS: 'Reject programs that contain errors whose detection is required by ...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_dBKu9jgx3OyH",
          "category": -5,
          "fls_section": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "score": 0.604,
          "reason": "Per FLS: 'Correctly translate legal programs written in Rust,' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_lkdm0mdghppv",
          "category": -5,
          "fls_section": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "score": 0.601,
          "reason": "Per FLS: 'A tool that conforms to this document shall support each capability...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_dv1qish8svc",
          "category": -1,
          "fls_section": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "score": 0.586,
          "reason": "Per FLS: 'This document is made available for contribution and review, and ca...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_ihjhpy4osl53",
          "category": -2,
          "fls_section": "fls_e0896uk0mdyl",
          "fls_title": "Assembly Instructions",
          "score": 0.584,
          "reason": "Per FLS: 'An assembly instruction shall use the syntax of format strings as d...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_jk7scu5xs17z",
          "category": -1,
          "fls_section": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "score": 0.577,
          "reason": "Per FLS: 'The effect of translating and executing such a program;' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_sph1a3sapinh",
          "category": -1,
          "fls_section": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "score": 0.577,
          "reason": "Per FLS: 'The language-defined libraries that a conforming tool is required t...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_emcNJzl2tHSA",
          "category": -2,
          "fls_section": "fls_wsfw8xF3vniL",
          "fls_title": "Structural Equality",
          "score": 0.574,
          "reason": "Per FLS: 'Bool, char, [function pointer type]s, [integer type]s, str, and [ra...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.-2.2",
          "fls_title": "ABI",
          "score": 0.574,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_p090c5oTnElW",
          "category": 0,
          "fls_section": "2.-2.10",
          "fls_title": "Simple C String Literals",
          "score": 0.567,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.-2.5",
          "fls_title": "Assembly Instructions",
          "score": 0.565,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_188ib65a1z36",
          "category": -2,
          "fls_section": "fls_ylli0ortyegk",
          "fls_title": "Assembly Options",
          "score": 0.563,
          "reason": "Per FLS: '- ARM - Condition flags C, N, V, Z in register CPSR Condition flags...' (similarity: 0.56)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 1.3",
      "guideline_title": "There shall be no occurrence of undefined or critical unspecified behaviour",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_70qjvaqoz007",
          "category": -4,
          "fls_section": "fls_xscgklvg1wd2",
          "fls_title": "Structure",
          "score": 0.618,
          "reason": "Per FLS: 'Situations that result in unbounded errors.' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.598,
          "reason": "Per FLS: 'It is a validity invariant for a value of a function pointer type t...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.596,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is eithe...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_ovn9czwnwxue",
          "category": -2,
          "fls_section": "19.-2.2",
          "fls_title": "Unsafety",
          "score": 0.588,
          "reason": "Per FLS: 'An unsafe operation is an operation that may result in undefined be...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.583,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_ch2lvm50olqd",
          "category": -2,
          "fls_section": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "score": 0.571,
          "reason": "Per FLS: 'When a variable lacks a value or its value has been passed <passing...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_8kqo952gjhaf",
          "category": -2,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.565,
          "reason": "Per FLS: 'Unsafety is the presence of [unsafe operation]s and [unsafe trait i...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_jd1inwz7ulyw",
          "category": -2,
          "fls_section": "19.-2.4",
          "fls_title": "Unsafety",
          "score": 0.563,
          "reason": "Per FLS: 'Dereferencing a value of a raw pointer type.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_4wDpAHhnWZAB",
          "category": -2,
          "fls_section": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "score": 0.559,
          "reason": "Per FLS: '[Call expression]s and [method call expression]s if the return type...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_pexi5jazthq6",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.555,
          "reason": "Per FLS: 'If the program context over-constrains the type, then this is consi...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.553,
          "reason": "Per FLS: 'A variadic part indicates the presence of C-like optional parameters.' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.534,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.51,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 1.4",
      "guideline_title": "Emergent language features shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is specific to C versioning",
      "confidence": "high",
      "notes": "Per ADD-6: 'this is specific to C versioning'. Rust editions (2015, 2018, 2021) provide a different, more structured approach to language evolution.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 1.5",
      "guideline_title": "Obsolescent language features shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_dv1qish8svc",
          "category": -1,
          "fls_section": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "score": 0.672,
          "reason": "Per FLS: 'This document is made available for contribution and review, and ca...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_9cd746qe40ag",
          "category": 0,
          "fls_section": "1.-1.6",
          "fls_title": "Versioning",
          "score": 0.566,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.-2.2",
          "fls_title": "ABI",
          "score": 0.539,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_xscgklvg1wd2",
          "category": 0,
          "fls_section": "1.-1.4",
          "fls_title": "Structure",
          "score": 0.536,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "category": 0,
          "fls_section": "1.-1.3",
          "fls_title": "Extent",
          "score": 0.532,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_fo1c7pg2mw1",
          "category": 0,
          "fls_section": "1.-1.2",
          "fls_title": "Scope",
          "score": 0.514,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "this applies to deprecated APIs",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this applies to deprecated APIs. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 2.1",
      "guideline_title": "A project shall not contain unreachable code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "No high-confidence FLS matches found"
    },
    {
      "guideline_id": "Rule 2.2",
      "guideline_title": "A project shall not contain dead code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "No high-confidence FLS matches found"
    },
    {
      "guideline_id": "Rule 2.3",
      "guideline_title": "A project should not contain unused type declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_Tx4Sx4Qy8y2d",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.551,
          "reason": "Per FLS: 'If there are any remaining [global type variable]s that have not be...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_s45k21yn4qur",
          "category": 0,
          "fls_section": "4.-2.21",
          "fls_title": "Inferred Types",
          "score": 0.524,
          "reason": "Section-level similarity match (score: 0.52)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 2.4",
      "guideline_title": "A project should not contain unused tag declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no separate tag name space in Rust",
      "confidence": "high",
      "notes": "Per ADD-6: 'no separate tag name space in Rust'. Rust has no struct/enum/union tag namespace - type names are directly in the type namespace.",
      "accepted_matches": [],
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 2.5",
      "guideline_title": "A project should not contain unused macro definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_qxjy0f758x5s",
          "category": 0,
          "fls_section": "13.-2.32",
          "fls_title": "Attribute ``macro_use``",
          "score": 0.538,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_xlfo7di0gsqz",
          "category": 0,
          "fls_section": "20.-1.1",
          "fls_title": "Hygiene",
          "score": 0.511,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 2.6",
      "guideline_title": "A function should not contain unused label declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ijbt4tgnl95n",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.588,
          "reason": "Per FLS: 'A function shall not specify a self parameter unless it is an assoc...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_ofzql79i9if",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.576,
          "reason": "Per FLS: 'It shall lack [function qualifier]s,' (similarity: 0.58)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 2.7",
      "guideline_title": "A function should not contain unused parameters",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ijbt4tgnl95n",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.661,
          "reason": "Per FLS: 'A function shall not specify a self parameter unless it is an assoc...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_lxzinvqveuqh",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.656,
          "reason": "Per FLS: 'The pattern of a function parameter shall be an irrefutable pattern.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_byqjs5fvy2bj",
          "category": -2,
          "fls_section": "fls_vhpwge5123cm",
          "fls_title": "Generic Parameters",
          "score": 0.654,
          "reason": "Per FLS: 'As a value of any expression within a function body.' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_icdzs1mjh0n4",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.631,
          "reason": "Per FLS: 'A variadic function shall specify one of the following [ABI]s:' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_prbwj1pmng6k",
          "category": -2,
          "fls_section": "fls_vhpwge5123cm",
          "fls_title": "Generic Parameters",
          "score": 0.626,
          "reason": "Per FLS: 'As a constant argument of any type used within a function body.' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_yfm0jh62oaxr",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.612,
          "reason": "Per FLS: 'A function shall have a function body unless it is an associated tr...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_PGDKWK7nPvgw",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.603,
          "reason": "Per FLS: 'The [binding]s of all [pattern]s of all [function parameter]s of a ...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_PGtp39f6gJwU",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.599,
          "reason": "Per FLS: 'If the function parameter is a self parameter without a TypeSpecifi...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.594,
          "reason": "Per FLS: 'A variadic part indicates the presence of C-like optional parameters.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_AAYJDCNMJgTq",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.591,
          "reason": "Per FLS: 'The type of a function parameter is determined as follows:' (similarity: 0.59)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 2.8",
      "guideline_title": "A project should not contain unused object definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "No high-confidence FLS matches found"
    },
    {
      "guideline_id": "Rule 3.1",
      "guideline_title": "The character sequences /* and // shall not be used within a comment",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_6fxcs17n4kw",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.626,
          "reason": "Per FLS: 'Character 0x0D (carriage return) shall not appear in a comment.' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_w7d0skpov1is",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.609,
          "reason": "Per FLS: '[Outer block doc]s and [outer line doc]s shall apply to a subsequen...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_32ncjvj2kn7z",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.605,
          "reason": "Per FLS: '[Inner block doc]s and [inner line doc]s shall apply to an enclosin...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_q8l2jza7d9xa",
          "category": 0,
          "fls_section": "2.-2.20",
          "fls_title": "Comments",
          "score": 0.597,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_uze7l7cxonk1",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.575,
          "reason": "Per FLS: '[Block comment]s, [inner block doc]s, and [outer block doc]s shall ...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_8luyomzppck",
          "category": -2,
          "fls_section": "fls_xgqh0ju6bmbn",
          "fls_title": "Patterns",
          "score": 0.572,
          "reason": "Per FLS: 'Any two [pattern-without-alternation]s that are or-ed using charact...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_m7gt3wfbtm81",
          "category": -2,
          "fls_section": "fls_fgnllgz5k3e6",
          "fls_title": "Lexical Elements, Separators, and Punctuation",
          "score": 0.565,
          "reason": "Per FLS: '- /= - Slash equals -' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_gy23lwlqw2mc",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.565,
          "reason": "Per FLS: '[Line comment]s, [inner line doc]s, and [outer line doc]s shall ext...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_ok0zvo9vcmzo",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.562,
          "reason": "Per FLS: '[Inner block doc]s and [inner line doc]s are equivalent to attribut...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_nWtKuPi8Fw6v",
          "category": -2,
          "fls_section": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "score": 0.553,
          "reason": "Per FLS: '[Outer block doc]s and [outer line doc]s are equivalent to attribut...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_fgnllgz5k3e6",
          "category": 0,
          "fls_section": "2.-2.2",
          "fls_title": "Lexical Elements, Separators, and Punctuation",
          "score": 0.501,
          "reason": "Section-level similarity match (score: 0.50)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "nested comments are fully supported",
      "confidence": "medium",
      "notes": "MISRA ADD-6: nested comments are fully supported"
    },
    {
      "guideline_id": "Rule 3.2",
      "guideline_title": "Line-splicing shall not be used in // comments",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust does not support line-splicing with backslash. Line continuation in strings uses string concatenation or raw strings. No equivalent concern.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 4.1",
      "guideline_title": "Octal and hexadecimal escape sequences shall be terminated C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust escape sequences are well-defined and don't have C's ambiguous octal parsing. Unicode escapes (\\u{...}) are delimited. No termination ambiguity.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 4.2",
      "guideline_title": "Trigraphs should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no trigraphs. Raw string literals (r#\"...\"#) provide the functionality trigraphs were designed for in restricted character sets.",
      "accepted_matches": [],
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.1",
      "guideline_title": "External identifiers shall be distinct C90 [Undefined 7], C99 [Unspecified 7; Undefined 28], C11 [Unspecified 8; Undefined 31]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": 0.675,
          "reason": "Parent section defining Rust's identifier rules."
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "category": -2,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": 0.651,
          "reason": "Per FLS: 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization.' Rust considers the full identifier sequence, not a truncated prefix as C may."
        },
        {
          "fls_id": "fls_vde7gev5rz4q",
          "category": -2,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": 0.579,
          "reason": "Per FLS: 'Identifiers are normalized using Normalization Form C...' Unicode normalization ensures consistent identifier comparison."
        },
        {
          "fls_id": "fls_op0lp1i065di",
          "category": -2,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": null,
          "reason": "Per FLS: 'Names of items within external blocks' shall be ASCII. This restricts external/FFI identifiers."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.496,
          "reason": "FFI context where C ABI applies. Per MISRA ADD-6: identifier distinctness matters in extern \"C\" contexts where the C linker may truncate."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_p090c5oTnElW",
          "category": 0,
          "fls_section": "2.7",
          "score": 0.534,
          "reason": "About C string literals, not identifier distinctness."
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.5",
          "score": 0.516,
          "reason": "About assembly instructions, not identifiers."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "confidence": "high",
      "notes": "Per MISRA ADD-6: 'no character limit, except in extern \"C\"'. In pure Rust, identifiers are always fully distinct with no truncation. In extern \"C\" contexts, the C linker's rules apply, which may have character limits. Safe Rust has no extern \"C\" items, hence not_applicable for safe Rust."
    },
    {
      "guideline_id": "Rule 5.2",
      "guideline_title": "Identifiers declared in the same scope and name space shall be distinct C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.656,
          "reason": "Per FLS: 'Two [identifier]s are considered the same if they consist of the sa...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.-2.3",
          "fls_title": "Identifiers",
          "score": 0.615,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_irwcldiotei2",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.576,
          "reason": "Per FLS: 'A pure identifier shall be restricted to characters in category Asc...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_jpecw46eh061",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.558,
          "reason": "Per FLS: 'A pure identifier shall follow the specification in Unicode Standar...' (similarity: 0.56)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "no character limit, but has name spaces",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no character limit, but has name spaces"
    },
    {
      "guideline_id": "Rule 5.3",
      "guideline_title": "An identifier declared in an inner scope shall not hide an identifier declared in an outer scope",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_lnpyb285qdiy",
          "category": 0,
          "fls_section": "14.-2.11",
          "fls_title": "Scope Hierarchy",
          "score": 0.605,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_ydmnb7qnmzzq",
          "category": 0,
          "fls_section": "14.-2.15",
          "fls_title": "Shadowing",
          "score": 0.594,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_34usianesmf6",
          "category": -2,
          "fls_section": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "score": 0.569,
          "reason": "Per FLS: 'The declaration of an implementation introduces a generic parameter...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.-2.3",
          "fls_title": "Identifiers",
          "score": 0.569,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "category": 0,
          "fls_section": "15.-2.8",
          "fls_title": "Drop Scopes",
          "score": 0.558,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_pvfqhtts3qsa",
          "category": -2,
          "fls_section": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "score": 0.557,
          "reason": "Per FLS: 'The declaration of a function introduces a binding scope and a gene...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_24c95c56tugl",
          "category": -2,
          "fls_section": "fls_7bxv8lybxm18",
          "fls_title": "Identifier Patterns",
          "score": 0.557,
          "reason": "Per FLS: 'The identifier pattern enters its binding into binding scope in the...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_puly43s4x360",
          "category": -2,
          "fls_section": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "score": 0.555,
          "reason": "Per FLS: 'The declaration of a struct type introduces a generic parameter sco...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_iec3otx863yp",
          "category": -2,
          "fls_section": "fls_octf6sf7yso",
          "fls_title": "Textual Macro Scope",
          "score": 0.554,
          "reason": "Per FLS: 'A declarative macro is in scope after the related macro declaration...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.554,
          "reason": "Section-level similarity match (score: 0.55)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this also applies to macro names",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this also applies to macro names"
    },
    {
      "guideline_id": "Rule 5.4",
      "guideline_title": "Macro identifiers shall be distinct C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per ADD-6: C-specific macro identifier rules. Rust's procedural macros are proper functions. Declarative macros (macro_rules!) have hygiene and clear scoping.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.5",
      "guideline_title": "Identifiers shall be distinct from macro names C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_jejt5z8m1yew",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.669,
          "reason": "Per FLS: '[Declarative macro]s and [procedural macro]s shall receive normaliz...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.-2.3",
          "fls_title": "Identifiers",
          "score": 0.608,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_tjn92evtlflq",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.594,
          "reason": "Per FLS: 'The DelimitedTokenTree of the invoking attribute macro is transform...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.589,
          "reason": "Per FLS: 'Two [identifier]s are considered the same if they consist of the sa...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_my93neopj9x0",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.583,
          "reason": "Per FLS: 'The returned proc_macro::TokenStream of the macro implementation fu...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_mewfehvgm16r",
          "category": -2,
          "fls_section": "fls_wn1i6hzg2ff7",
          "fls_title": "Procedural Macros",
          "score": 0.583,
          "reason": "Per FLS: 'A macro implementation function enters the name of the procedural m...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_Sm4qVsHKYLY2",
          "category": -2,
          "fls_section": "fls_k01lsksqtq1r",
          "fls_title": "Repetition",
          "score": 0.577,
          "reason": "Per FLS: 'If the macro repetition has a separator, the separator shall be all...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_tgzga1lanfuo",
          "category": -2,
          "fls_section": "fls_qezwyridmjob",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": 0.577,
          "reason": "Per FLS: 'When invoking macro core::arch::global_asm and macro core::arch::na...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_o9rwz9z0a2h4",
          "category": -2,
          "fls_section": "fls_ym00b6ewf4n3",
          "fls_title": "Macro Transcription",
          "score": 0.577,
          "reason": "Per FLS: 'where the metavariable of the macro repetition in matching are repe...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_76prdp6k1fga",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.576,
          "reason": "Per FLS: 'The TokenTree of the macro invocation is matched against the [macro...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_n8beqlt54rhy",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.572,
          "reason": "Per FLS: 'The macro invocation is replaced with the returned proc_macro::Toke...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_8nzypdu9j3ge",
          "category": 0,
          "fls_section": "20.-2.3",
          "fls_title": "Metavariables",
          "score": 0.566,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_xa7lp0zg1ol2",
          "category": 0,
          "fls_section": "20.-2.2",
          "fls_title": "Declarative Macros",
          "score": 0.565,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_ym00b6ewf4n3",
          "category": 0,
          "fls_section": "20.-2.14",
          "fls_title": "Macro Transcription",
          "score": 0.545,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_o8s3r7m90q59",
          "category": 0,
          "fls_section": "20.-2.7",
          "fls_title": "Derive Macros",
          "score": 0.539,
          "reason": "Section-level similarity match (score: 0.54)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "macros and functions use different syntax",
      "confidence": "medium",
      "notes": "MISRA ADD-6: macros and functions use different syntax"
    },
    {
      "guideline_id": "Rule 5.6",
      "guideline_title": "A typedef name shall be a unique identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_89yNjGNB7KI3",
          "category": -2,
          "fls_section": "fls_fk2m2irwpeof",
          "fls_title": "Implementations",
          "score": 0.63,
          "reason": "Per FLS: '[Inherent implementation]s of the same implementing type shall not ...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_kgvleup5mdhq",
          "category": 0,
          "fls_section": "4.-2.25",
          "fls_title": "Type Aliases",
          "score": 0.625,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_qofr9vme46wp",
          "category": -2,
          "fls_section": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "score": 0.613,
          "reason": "Per FLS: 'The declaration of a type alias introduces a generic parameter scope.' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_w9dx5h7m31sj",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.602,
          "reason": "Per FLS: 'A type alias is unifiable with another type when the aliased type i...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_bibigic4jjad",
          "category": -2,
          "fls_section": "fls_kgvleup5mdhq",
          "fls_title": "Type Aliases",
          "score": 0.599,
          "reason": "Per FLS: 'A type alias is an item that defines a name for a type.' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_EoEbldkKBQW0",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.579,
          "reason": "Per FLS: 'If either type is a global type variable, the global type variable ...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_b60omrhc7t73",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.572,
          "reason": "Per FLS: 'The type of a named initializer and the type of the matched field s...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_24c95c56tugl",
          "category": -2,
          "fls_section": "fls_7bxv8lybxm18",
          "fls_title": "Identifier Patterns",
          "score": 0.571,
          "reason": "Per FLS: 'The identifier pattern enters its binding into binding scope in the...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_y9bc691kkh6v",
          "category": -2,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.569,
          "reason": "Per FLS: 'Otherwise the type is associated type core::ops::Deref::Target.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_151r19d7xbgz",
          "category": 0,
          "fls_section": "14.-2.1",
          "fls_title": "Entities",
          "score": 0.566,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_z3gj1v6g605r",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.565,
          "reason": "Per FLS: 'The value of a named initializer is the value of its expression.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_mq80i8fof7sx",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.562,
          "reason": "Per FLS: 'Contain exactly one matched named initializer, or' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_7bxv8lybxm18",
          "category": 0,
          "fls_section": "5.-2.3",
          "fls_title": "Identifier Patterns",
          "score": 0.56,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_dq403wq5yrs",
          "category": 0,
          "fls_section": "14.-2.12",
          "fls_title": "Namespaces",
          "score": 0.545,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_vhpwge5123cm",
          "category": 0,
          "fls_section": "12.-2.1",
          "fls_title": "Generic Parameters",
          "score": 0.531,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 5.7",
      "guideline_title": "A tag name shall be a unique identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no separate tag name space in Rust",
      "confidence": "high",
      "notes": "Per ADD-6: 'no separate tag name space in Rust'. Rust types are in a single type namespace. struct Foo and enum Foo would conflict - no tag vs type distinction.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.8",
      "guideline_title": "Identifiers that define objects or functions with external linkage shall be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ktnf6zkrdy45",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.638,
          "reason": "Per FLS: 'A pure identifier is an identifier that does not include [weak keyw...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.-2.3",
          "fls_title": "Identifiers",
          "score": 0.627,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_xsdmun5uqy4c",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.622,
          "reason": "Per FLS: 'An identifier is a lexical element that refers to a name.' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_jpecw46eh061",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.61,
          "reason": "Per FLS: 'A pure identifier shall follow the specification in Unicode Standar...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_w473jevurlt1",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.609,
          "reason": "Per FLS: '[Name]s of external [crate]s represented in a simple path, when the...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_p44fky7fifc",
          "category": 0,
          "fls_section": "13.-2.19",
          "fls_title": "Attribute ``link_name``",
          "score": 0.608,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.607,
          "reason": "Per FLS: 'Two [identifier]s are considered the same if they consist of the sa...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_irwcldiotei2",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.594,
          "reason": "Per FLS: 'A pure identifier shall be restricted to characters in category Asc...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_jejt5z8m1yew",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.579,
          "reason": "Per FLS: '[Declarative macro]s and [procedural macro]s shall receive normaliz...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_d00wni4edi8f",
          "category": -2,
          "fls_section": "fls_p44fky7fifc",
          "fls_title": "Attribute ``link_name``",
          "score": 0.578,
          "reason": "Per FLS: 'Attribute :dc:link_name shall specify the linking symbol of the rel...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_joIQdDn44oIT",
          "category": -2,
          "fls_section": "fls_7bxv8lybxm18",
          "fls_title": "Identifier Patterns",
          "score": 0.573,
          "reason": "Per FLS: 'An identifier pattern with keyword ref is a reference identifier pa...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_g09jhukl0ez2",
          "category": -2,
          "fls_section": "fls_p44fky7fifc",
          "fls_title": "Attribute ``link_name``",
          "score": 0.562,
          "reason": "Per FLS: 'Attribute link_name shall apply to [external function]s and [extern...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_151r19d7xbgz",
          "category": 0,
          "fls_section": "14.-2.1",
          "fls_title": "Entities",
          "score": 0.513,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 5.9",
      "guideline_title": "Identifiers that define objects or functions with internal linkage should be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dq403wq5yrs",
          "category": 0,
          "fls_section": "14.3",
          "fls_title": "Namespaces",
          "score": 0.555,
          "reason": "Per FLS fls_1d4jm61qnt4l: 'A namespace is a logical grouping of names such that the occurrence of a name in one namespace does not conflict with an occurrence of the same name in another namespace.' Rust's 5 namespaces (label, lifetime, macro, type, value) prevent the identifier confusion that MISRA aims to avoid."
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.3",
          "fls_title": "Identifiers",
          "score": 0.674,
          "reason": "Per FLS fls_j9yh8j8jgdeu: 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization.' Defines identifier equality/uniqueness."
        },
        {
          "fls_id": "fls_151r19d7xbgz",
          "category": 0,
          "fls_section": "14.1",
          "fls_title": "Entities",
          "score": 0.588,
          "reason": "Defines how entities (functions, objects, types) are named and resolved within Rust's module system, which provides isolation analogous to C's internal linkage."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA aims to prevent confusion from duplicate internal-linkage identifiers. Rust's module system and namespace segregation (FLS 14.3) structurally prevents this issue. Private items are module-scoped, not file-scoped like C's 'static', and the 5-namespace model ensures names in different categories never conflict.",
      "rejected_matches": [
        {
          "fls_id": "fls_p44fky7fifc",
          "category": 0,
          "fls_section": "13.19",
          "fls_title": "Attribute link_name",
          "score": 0.629,
          "reason": "About renaming symbols for FFI linking, not about identifier uniqueness."
        },
        {
          "fls_id": "fls_7bxv8lybxm18",
          "category": 0,
          "fls_section": "5.3",
          "fls_title": "Identifier Patterns",
          "score": 0.548,
          "reason": "Pattern matching syntax, not about identifier uniqueness or naming conflicts."
        }
      ]
    },
    {
      "guideline_id": "Rule 5.10",
      "guideline_title": "A reserved identifier or reserved macro name shall not be declared C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_jejt5z8m1yew",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.656,
          "reason": "Per FLS: '[Declarative macro]s and [procedural macro]s shall receive normaliz...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_3mhj0kkupwuz",
          "category": -2,
          "fls_section": "fls_ixjc5jaamx84",
          "fls_title": "Constants",
          "score": 0.647,
          "reason": "Per FLS: 'An unnamed constant is a constant declared with character 0x5F (low...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_n8beqlt54rhy",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.638,
          "reason": "Per FLS: 'The macro invocation is replaced with the returned proc_macro::Toke...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_OR85NVifPwjr",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.627,
          "reason": "Per FLS: 'extern \"C\"' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_fobs8ebt7dhc",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.622,
          "reason": "Per FLS: '[Struct expression]s,' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_my93neopj9x0",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.62,
          "reason": "Per FLS: 'The returned proc_macro::TokenStream of the macro implementation fu...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_mi92etjtpamu",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.619,
          "reason": "Per FLS: 'The macro implementation function is called with the proc_macro::To...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_tbe2qq7whq10",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.619,
          "reason": "Per FLS: 'The macro implementation function is called with the proc_macro::To...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_ul7nhfyvyzh",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.619,
          "reason": "Per FLS: 'The macro implementation function is called with the two [proc_macr...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_tjn92evtlflq",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.618,
          "reason": "Per FLS: 'The DelimitedTokenTree of the invoking attribute macro is transform...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.-2.5",
          "fls_title": "Assembly Instructions",
          "score": 0.579,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.-2.3",
          "fls_title": "Identifiers",
          "score": 0.568,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_hejgghwzblf",
          "category": 0,
          "fls_section": "22.-2.4",
          "fls_title": "Register Arguments",
          "score": 0.563,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_p090c5oTnElW",
          "category": 0,
          "fls_section": "2.-2.10",
          "fls_title": "Simple C String Literals",
          "score": 0.558,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.-2.2",
          "fls_title": "ABI",
          "score": 0.552,
          "reason": "Section-level similarity match (score: 0.55)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "only possible in some cases. Previously Rule 21.2",
      "confidence": "medium",
      "notes": "MISRA ADD-6: only possible in some cases. Previously Rule 21.2"
    },
    {
      "guideline_id": "Rule 6.1",
      "guideline_title": "Bit-fields shall only be declared with an appropriate type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "only provided as a library feature",
      "confidence": "high",
      "notes": "Per ADD-6: 'only provided as a library feature'. Rust has no native bit-field syntax. Use bitflags crate or manual bit manipulation with explicit types.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 6.2",
      "guideline_title": "Single-bit named bit-fields shall not be of a signed type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no native bit-fields. Bit manipulation is done with explicit integer types. signedness is always explicit (i32 vs u32).",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 6.3",
      "guideline_title": "A bit-field shall not be declared as a member of a union C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no native bit-fields. Unions in Rust are for FFI compatibility and don't have bit-field members.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.1",
      "guideline_title": "Octal constants shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_4v7awnutbpoe",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.728,
          "reason": "Per FLS: 'An octal literal is an integer literal in base 8.' (similarity: 0.73)"
        },
        {
          "fls_id": "fls_2268lchxkzjp",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.656,
          "reason": "Per FLS: 'A hexadecimal literal is an integer literal in base 16.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_3mhj0kkupwuz",
          "category": -2,
          "fls_section": "fls_ixjc5jaamx84",
          "fls_title": "Constants",
          "score": 0.655,
          "reason": "Per FLS: 'An unnamed constant is a constant declared with character 0x5F (low...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_rn8xfd66yvst",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.639,
          "reason": "Per FLS: 'A decimal literal is an integer literal in base 10.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_7yq2fep848ky",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.639,
          "reason": "Per FLS: 'Suffix i8 specifies type i8.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_xrv4q56lmoo3",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.633,
          "reason": "Per FLS: 'Suffix u8 specifies type u8.' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_b46nyamfqxdu",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.629,
          "reason": "Per FLS: 'The evaluation of a constant expression that results in arithmetic ...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_fsaimo419gf0",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.629,
          "reason": "Per FLS: 'Suffix u128 specifies type u128.' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_66e3q5um6cwc",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.621,
          "reason": "Per FLS: 'Suffix u16 specifies type u16.' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_o7cqfdnr253y",
          "category": -2,
          "fls_section": "fls_wttihxen35as",
          "fls_title": "Constant Promotion",
          "score": 0.617,
          "reason": "Per FLS: 'An anonymous constant is created, whose constant initializer holds ...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_29tlg1vyqay2",
          "category": 0,
          "fls_section": "2.-2.14",
          "fls_title": "Float Literals",
          "score": 0.592,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_2ed4axpsy9u0",
          "category": 0,
          "fls_section": "2.-2.13",
          "fls_title": "Integer Literals",
          "score": 0.572,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_2ifjqwnw03ms",
          "category": 0,
          "fls_section": "2.-2.5",
          "fls_title": "Byte Literals",
          "score": 0.563,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_nrkd5wpi64oo",
          "category": 0,
          "fls_section": "2.-2.4",
          "fls_title": "Literals",
          "score": 0.558,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "category": 0,
          "fls_section": "7.-2.2",
          "fls_title": "Constants",
          "score": 0.542,
          "reason": "Section-level similarity match (score: 0.54)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "Rust octals have a distinct prefix from decimals",
      "confidence": "medium",
      "notes": "MISRA ADD-6: Rust octals have a distinct prefix from decimals"
    },
    {
      "guideline_id": "Rule 7.2",
      "guideline_title": "A \u201cu\u201d or \u201cU\u201d suffix shall be applied to all integer constants that are represented in an unsigned type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_xrv4q56lmoo3",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.693,
          "reason": "Per FLS: 'Suffix u8 specifies type u8.' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_5asyk66y7c9d",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.69,
          "reason": "Per FLS: 'Suffix u32 specifies type u32.' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_fsaimo419gf0",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.685,
          "reason": "Per FLS: 'Suffix u128 specifies type u128.' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_66e3q5um6cwc",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.682,
          "reason": "Per FLS: 'Suffix u16 specifies type u16.' (similarity: 0.68)"
        },
        {
          "fls_id": "fls_76fifqjka0lx",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.662,
          "reason": "Per FLS: 'Suffix u64 specifies type u64.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_idzhusp2l908",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.651,
          "reason": "Per FLS: 'If an integer type can be uniquely determined from the surrounding ...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_6z45ss502alt",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.646,
          "reason": "Per FLS: '[Bit expression]s of [scalar type]s,' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_7yq2fep848ky",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.643,
          "reason": "Per FLS: 'Suffix i8 specifies type i8.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_jEZVWlfVPevb",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.637,
          "reason": "Per FLS: 'If U is a floating-point type or an floating-point type variable, t...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_50qipwqi3arw",
          "category": -2,
          "fls_section": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "score": 0.631,
          "reason": "Per FLS: 'The type of an unsuffixed integer is determined by type inference a...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_29tlg1vyqay2",
          "category": 0,
          "fls_section": "2.-2.14",
          "fls_title": "Float Literals",
          "score": 0.607,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_3qnpv2z7yjil",
          "category": 0,
          "fls_section": "4.-2.6",
          "fls_title": "Integer Types",
          "score": 0.575,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_wrvjizrqf3po",
          "category": 0,
          "fls_section": "4.-2.4",
          "fls_title": "Char Type",
          "score": 0.553,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "category": 0,
          "fls_section": "7.-2.2",
          "fls_title": "Constants",
          "score": 0.552,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.-2.24",
          "fls_title": "Type Cast Expressions",
          "score": 0.549,
          "reason": "Section-level similarity match (score: 0.55)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "this is an error by default but can be enabled",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is an error by default but can be enabled"
    },
    {
      "guideline_id": "Rule 7.3",
      "guideline_title": "The lowercase character \u201cl\u201d shall not be used in a literal suffix",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust integer literal suffixes use full type names (i32, u64, etc.) not single letters. No 'l' suffix exists - uses i64 or u64 explicitly.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.4",
      "guideline_title": "A string literal shall not be assigned to an object unless the object\u2019s type is \u201cpointer to const-qualified char\u201d C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust string literals are &str (immutable by design). No implicit const-stripping. Mutable strings require String::from() or .to_string().",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.5",
      "guideline_title": "The argument of an integer constant macro shall have an appropriate form C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per ADD-6: C-specific integer constant macro concern. Rust uses typed literals directly (123i32, 456u64) - no macros needed for type-specific constants.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.6",
      "guideline_title": "The small integer variants of the minimum-width integer constant macros shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per ADD-6: C-specific macro concern. Rust uses explicit type suffixes on literals. No INT8_C or similar macros - just use 123i8 directly.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.1",
      "guideline_title": "Types shall be explicitly specified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust requires explicit types in most contexts. Type inference exists but is local and explicit. Function signatures require types. No implicit int.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.2",
      "guideline_title": "Function types shall be in prototype form with named parameters C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust functions always have explicit parameter types and return types. No K&R style declarations. Parameters are always named in definitions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.3",
      "guideline_title": "All declarations of an object or function shall use the same names and type qualifiers C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_lv7w7aalpwm5",
          "category": 0,
          "fls_section": "4.-2.37",
          "fls_title": "Type Inference",
          "score": 0.632,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.627,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "category": 0,
          "fls_section": "4.-2.27",
          "fls_title": "Type Representation",
          "score": 0.625,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.609,
          "reason": "Per FLS: 'A variadic part indicates the presence of C-like optional parameters.' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_qcb1n9c0e5hz",
          "category": 0,
          "fls_section": "9.-2.1",
          "fls_title": "Functions",
          "score": 0.608,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_b60omrhc7t73",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.605,
          "reason": "Per FLS: 'The type of a named initializer and the type of the matched field s...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_dv1qish8svc",
          "category": -1,
          "fls_section": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "score": 0.604,
          "reason": "Per FLS: 'This document is made available for contribution and review, and ca...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_2dajkhq58cdp",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.599,
          "reason": "Per FLS: 'The type of a shorthand initializer and the type of the matched fie...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_g2u1dfhphrrg",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.596,
          "reason": "Per FLS: 'The [type]s of the corresponding [function parameter]s are unifiabl...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_vhpwge5123cm",
          "category": 0,
          "fls_section": "12.-2.1",
          "fls_title": "Generic Parameters",
          "score": 0.595,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_8s1vddh8vdhy",
          "category": -2,
          "fls_section": "fls_ohhsmifo0urd",
          "fls_title": "Type Representation",
          "score": 0.593,
          "reason": "Per FLS: 'C representation lays out a type such that the type is interoperabl...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_dfajs3xaxbv",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.59,
          "reason": "Per FLS: 'The type of the operand of an indexed initializer and the type of t...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_wz2etmkpvxed",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.582,
          "reason": "Per FLS: 'A function pointer type is unifiable only with another function poi...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_cPlCLGCcl7EK",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.58,
          "reason": "Per FLS: 'The expression of a static initializer.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_A1NVYkepoaMk",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.579,
          "reason": "Per FLS: 'The size operand of an array expression or an array type.' (similarity: 0.58)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "an extern declaration shall have a type compatible with the C declaration",
      "confidence": "medium",
      "notes": "MISRA ADD-6: an extern declaration shall have a type compatible with the C declaration. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 8.4",
      "guideline_title": "A compatible declaration shall be visible when an object or function with external linkage is defined C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.3",
          "score": 0.59,
          "reason": "External blocks declare FFI functions but Rust has no separate definition/declaration model requiring compatibility checks."
        },
        {
          "fls_id": "fls_p44fky7fifc",
          "category": 0,
          "fls_section": "13.x",
          "score": 0.525,
          "reason": "link_name is for symbol naming in FFI, not declaration/definition compatibility."
        },
        {
          "fls_id": "fls_mvd7nz8k3wcy",
          "category": 0,
          "fls_section": "13.x",
          "score": 0.511,
          "reason": "no_mangle is for symbol naming in FFI, not declaration/definition compatibility."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no separate declaration/definition model. Functions are defined in one place. For FFI (extern blocks), the extern declaration IS the declaration - there is no separate definition in Rust to check against. The C concept of \"compatible declaration\" checking between header and source file does not exist in Rust."
    },
    {
      "guideline_id": "Rule 8.5",
      "guideline_title": "An external object or function shall be declared once in one and only one file",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_4dje9t5y2dia",
          "category": -2,
          "fls_section": "fls_tmoh3y9oyqsy",
          "fls_title": "External Blocks",
          "score": 0.565,
          "reason": "Per FLS: 'An external block is a construct that provides the declarations of ...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.56,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_section": "21.-2.4",
          "fls_title": "External Functions",
          "score": 0.511,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "medium",
      "notes": "MISRA ADD-6: may affect extern \u201cC\u201d declarations. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 8.6",
      "guideline_title": "An identifier with external linkage shall have exactly one external definition C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.5,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.' The 'unchecked' nature means Rust trusts the linker to enforce ODR for external symbols."
        },
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_section": "21.2",
          "fls_title": "External Functions",
          "score": 0.48,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per fls_rdu4723vp0oo: 'An external function shall not specify a FunctionBody.' These are declarations only - the single definition must exist in linked C code."
        },
        {
          "fls_id": "fls_s4yt19sptl7d",
          "category": 0,
          "fls_section": "21.3",
          "fls_title": "External Statics",
          "score": 0.48,
          "reason": "Per FLS fls_8ddsytjr4il6: 'An external static is an import of a foreign variable.' Per fls_tr7purzcldn0: 'An external static shall not specify a static initializer.' These are declarations only."
        },
        {
          "fls_id": "fls_mvd7nz8k3wcy",
          "category": 0,
          "fls_section": "13.24",
          "fls_title": "Attribute no_mangle",
          "score": 0.53,
          "reason": "The #[no_mangle] attribute exposes Rust symbols with external linkage, making ODR concerns relevant when Rust functions are called from C."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "high",
      "notes": "MISRA enforces C's ODR for external linkage. In Rust, extern blocks provide 'unchecked imports' - the compiler trusts that exactly one definition exists in linked code. For pure Rust items, the module system and crate boundaries enforce uniqueness. For FFI with #[no_mangle], the user must ensure ODR compliance in the linked C code. Per ADD-6: 'may affect extern \"C\" declarations'.",
      "rejected_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.3",
          "fls_title": "Identifiers",
          "score": 0.652,
          "reason": "About identifier syntax, not about external linkage or definition uniqueness."
        },
        {
          "fls_id": "fls_7bxv8lybxm18",
          "category": 0,
          "fls_section": "5.3",
          "fls_title": "Identifier Patterns",
          "score": 0.579,
          "reason": "Pattern matching syntax, not related to external linkage."
        }
      ]
    },
    {
      "guideline_id": "Rule 8.7",
      "guideline_title": "Functions and objects should not be defined with external linkage if they are referenced in only one translation unit",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.603,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_p44fky7fifc",
          "category": 0,
          "fls_section": "13.-2.19",
          "fls_title": "Attribute ``link_name``",
          "score": 0.587,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_4dje9t5y2dia",
          "category": -2,
          "fls_section": "fls_tmoh3y9oyqsy",
          "fls_title": "External Blocks",
          "score": 0.572,
          "reason": "Per FLS: 'An external block is a construct that provides the declarations of ...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_qh5sXG4znAXa",
          "category": -2,
          "fls_section": "fls_Obik2w9gvhLN",
          "fls_title": "Attribute ``link_ordinal``",
          "score": 0.565,
          "reason": "Per FLS: 'The related extern block of the [external function] or [external st...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_section": "21.-2.4",
          "fls_title": "External Functions",
          "score": 0.562,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_w00qi1gx204e",
          "category": -2,
          "fls_section": "fls_yztwtek0y34v",
          "fls_title": "External Functions",
          "score": 0.556,
          "reason": "Per FLS: 'An external function inherits the ABI of its enclosing external block.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_Obik2w9gvhLN",
          "category": 0,
          "fls_section": "13.-2.21",
          "fls_title": "Attribute ``link_ordinal``",
          "score": 0.534,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_s4yt19sptl7d",
          "category": 0,
          "fls_section": "21.-2.5",
          "fls_title": "External Statics",
          "score": 0.519,
          "reason": "Section-level similarity match (score: 0.52)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "items should not be declared pub if referenced in only one crate",
      "confidence": "medium",
      "notes": "MISRA ADD-6: items should not be declared pub if referenced in only one crate"
    },
    {
      "guideline_id": "Rule 8.8",
      "guideline_title": "The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.3",
          "score": 0.679,
          "reason": "Rust statics are about storage duration, not linkage. Visibility in Rust is controlled by pub/module system, not storage class specifiers."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.3",
          "score": 0.603,
          "reason": "External blocks are for FFI declarations, not about internal vs external linkage control."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C uses storage class specifiers (static/extern) for linkage control. Rust has no equivalent concept - visibility is controlled through the module system (pub, pub(crate), private by default). Rust's \"static\" keyword is for storage duration, not linkage."
    },
    {
      "guideline_id": "Rule 8.9",
      "guideline_title": "An object should be declared at block scope if its identifier only appears in a single function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_MW7mtH5oOeQ1",
          "category": 0,
          "fls_section": "22.-2.11",
          "fls_title": "Label block",
          "score": 0.594,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.581,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_G59PiNQkVUnQ",
          "category": 0,
          "fls_section": "6.-2.11",
          "fls_title": "Const Blocks",
          "score": 0.568,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_veEGzEbpT4ny",
          "category": -2,
          "fls_section": "fls_G59PiNQkVUnQ",
          "fls_title": "Const Blocks",
          "score": 0.565,
          "reason": "Per FLS: 'An const block expression denotes a new control flow boundary.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_2i7TD7VoQk4B",
          "category": -2,
          "fls_section": "fls_G59PiNQkVUnQ",
          "fls_title": "Const Blocks",
          "score": 0.56,
          "reason": "Per FLS: 'The value of a const block expression is the value of the contained...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_769b4p8v3cwu",
          "category": 0,
          "fls_section": "14.-2.8",
          "fls_title": "Label Scope",
          "score": 0.555,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_m0z7omni9hp0",
          "category": 0,
          "fls_section": "14.-2.7",
          "fls_title": "Item Scope",
          "score": 0.511,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 8.10",
      "guideline_title": "An inline function shall be declared with the static storage class C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_ypio6boj3pwf",
          "category": 0,
          "fls_section": "13.-2.5",
          "fls_title": "Attribute ``inline``",
          "score": 0.672,
          "reason": "Rust's #[inline] attribute is a compiler optimization hint, not a linkage specifier. Per FLS fls_r3p4din7rjz8: 'A tool is not obliged to perform inlining.' Unlike C, Rust has no external/internal linkage distinction for inline functions."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.669,
          "reason": "External blocks are for FFI declarations, unrelated to inline function linkage semantics."
        },
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.-2.3",
          "fls_title": "Statics",
          "score": 0.631,
          "reason": "Rust statics have different semantics than C static storage class; not related to inline function linkage."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's UB when an inline function with external linkage lacks a definition in the translation unit, and timing ambiguity when both inline and external definitions exist. Rust has no equivalent issue: (1) functions have exactly one definition - no inline vs external definition distinction, (2) #[inline] is an optimization hint orthogonal to visibility (pub/pub(crate)), (3) Rust's module system and single-definition rule eliminate the linkage ambiguity that MISRA addresses."
    },
    {
      "guideline_id": "Rule 8.11",
      "guideline_title": "When an array with external linkage is declared, its size should be explicitly specified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_uj0kpjwyld60",
          "category": 0,
          "fls_section": "4.-2.7",
          "fls_title": "Array Types",
          "score": 0.511,
          "reason": "Rust arrays always require explicit size - per FLS fls_imr2jx6cbuzq: 'The size operand shall be a constant expression or an inferred constant.' There is no incomplete array type in Rust."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's ability to declare arrays with incomplete type (unspecified size) with external linkage. Rust prevents this entirely: per FLS fls_imr2jx6cbuzq, array types require 'a constant expression or an inferred constant' for size. Rust has no concept of incomplete array types - [T; N] always requires N to be known at compile time. The concern about cross-translation-unit consistency is also moot since Rust's module system and single-definition semantics prevent the ambiguity."
    },
    {
      "guideline_id": "Rule 8.12",
      "guideline_title": "Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_w9xj26ej869w",
          "category": -2,
          "fls_section": "fls_szibmtfv117b",
          "fls_title": "Enum Types",
          "score": 0.6,
          "reason": "Per FLS fls_w9xj26ej869w: 'It is a static error if two enum variants have discriminants with the same value.' Rust enforces this at compile time - duplicate discriminant values are rejected by the compiler."
        },
        {
          "fls_id": "fls_szibmtfv117b",
          "category": 0,
          "fls_section": "4.-2.11",
          "fls_title": "Enum Types",
          "score": 0.588,
          "reason": "Parent section containing discriminant uniqueness rules and implicit discriminant value calculation rules (fls_t36rk3wikq28, fls_8ajw5trd23wi)."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_66m2hwkju0vv",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.673,
          "reason": "About constant expression contexts, not discriminant uniqueness."
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "category": 0,
          "fls_section": "7.-2.2",
          "fls_title": "Constants",
          "score": 0.572,
          "reason": "About const items, not enum discriminants."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's ability to have duplicate enum constant values through mixing implicit and explicit specifications. Rust prevents this at compile time: per FLS fls_w9xj26ej869w, 'It is a static error if two enum variants have discriminants with the same value.' The discriminant calculation rules (fls_t36rk3wikq28: first variant is 0, fls_8ajw5trd23wi: subsequent are previous+1) combined with explicit initializers are checked for uniqueness by the compiler."
    },
    {
      "guideline_id": "Rule 8.13",
      "guideline_title": "A pointer should point to a const-qualified type whenever possible",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8ccwlliqw9jx",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.55,
          "reason": "Per FLS: 'An operand of type &mut [T; N] and a target type *const T perform a...' (similarity: 0.55)"
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "category": 0,
          "fls_section": "4.-2.17",
          "fls_title": "Raw Pointer Types",
          "score": 0.502,
          "reason": "Section-level similarity match (score: 0.50)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 8.14",
      "guideline_title": "The restrict type qualifier shall not be used C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.663,
          "reason": "Similarity based on pointer terminology; Rust function pointers have no restrict qualifier equivalent."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "category": 0,
          "fls_title": "Raw Pointer Types",
          "score": 0.658,
          "reason": "Rust raw pointers do not support restrict-like qualifiers; aliasing is handled differently via references and borrow checking."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no 'restrict' type qualifier. The C 'restrict' keyword is a promise to the compiler about pointer aliasing that enables optimizations but causes UB if violated. Rust handles aliasing safety through the borrow checker for references (&T, &mut T) and provides no user-accessible aliasing hints for raw pointers. The compiler internally uses noalias annotations based on reference semantics, but this is not exposed to users. Since restrict cannot be written in Rust, this rule is not applicable."
    },
    {
      "guideline_id": "Rule 8.15",
      "guideline_title": "All declarations of an object with an explicit alignment specification shall specify the same alignment C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_jr9dykj6rydn",
          "category": -2,
          "fls_section": "fls_rjxpof29a3nl",
          "fls_title": "Struct Type Representation",
          "score": 0.711,
          "reason": "Per FLS: 'The alignment of a struct type subject to C representation is the a...' (similarity: 0.71)"
        },
        {
          "fls_id": "fls_2npku94ookdn",
          "category": -2,
          "fls_section": "fls_rjxpof29a3nl",
          "fls_title": "Struct Type Representation",
          "score": 0.68,
          "reason": "Per FLS: 'Round up the current offset to the nearest multiple of the [struct ...' (similarity: 0.68)"
        },
        {
          "fls_id": "fls_muxfn9soi47l",
          "category": -2,
          "fls_section": "fls_g1z6bpyjqxkz",
          "fls_title": "Type Layout",
          "score": 0.677,
          "reason": "Per FLS: 'The alignment of a value specifies which addresses are valid for st...' (similarity: 0.68)"
        },
        {
          "fls_id": "fls_qkkc8x2oghst",
          "category": -2,
          "fls_section": "fls_ohhsmifo0urd",
          "fls_title": "Type Representation",
          "score": 0.666,
          "reason": "Per FLS: 'Type representation may be specified using attribute [repr] and mod...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.624,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_JBfZuFDQg3mU",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.616,
          "reason": "Per FLS: 'The base initializer of a struct expression.' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_fa5nkvu07jlp",
          "category": -2,
          "fls_section": "fls_rjxpof29a3nl",
          "fls_title": "Struct Type Representation",
          "score": 0.605,
          "reason": "Per FLS: 'If the current offset is not a multiple of the [field]'s alignment,...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_4uoi6k8r7mvc",
          "category": -2,
          "fls_section": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.604,
          "reason": "Per FLS: 'The type of the assigned operand of a shift right assignment shall ...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_EoEbldkKBQW0",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.6,
          "reason": "Per FLS: 'If either type is a global type variable, the global type variable ...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "category": 0,
          "fls_section": "4.-2.26",
          "fls_title": "Type Layout",
          "score": 0.6,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_pdgj2xekdead",
          "category": -2,
          "fls_section": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.595,
          "reason": "Per FLS: 'The type of the assigned operand of a shift left assignment shall i...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_7cjbxleo998q",
          "category": -2,
          "fls_section": "fls_g1z6bpyjqxkz",
          "fls_title": "Type Layout",
          "score": 0.594,
          "reason": "Per FLS: 'For array type [T; N] where T is the element type and N is size ope...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_e1pgdlv81vul",
          "category": 0,
          "fls_section": "11.-2.3",
          "fls_title": "Implementation Conformance",
          "score": 0.581,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.572,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "category": 0,
          "fls_section": "15.-2.5",
          "fls_title": "Passing Conventions",
          "score": 0.562,
          "reason": "Section-level similarity match (score: 0.56)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "medium",
      "notes": "MISRA ADD-6: may affect extern \u201cC\u201d declarations. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 8.16",
      "guideline_title": "The alignment specification of zero should not appear in an object declaration",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_muxfn9soi47l",
          "category": -2,
          "fls_section": "fls_g1z6bpyjqxkz",
          "fls_title": "Type Layout",
          "score": 0.675,
          "reason": "Per FLS fls_muxfn9soi47l: 'The alignment of a value... is at least one, and always a power of two.' This rule prevents align(0) - the compiler rejects it with error E0589 'not a power of two'."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.596,
          "reason": "Section about C representation layout, not alignment constraints."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust prevents alignment of 0 at compile time. Per FLS fls_muxfn9soi47l: 'The alignment of a value... is at least one, and always a power of two.' Attempting #[repr(align(0))] results in compiler error E0589: 'invalid repr(align) attribute: not a power of two'. C's _Alignas(0) meaning 'use default alignment' has no equivalent in Rust - if you want default alignment, simply don't specify any alignment."
    },
    {
      "guideline_id": "Rule 8.17",
      "guideline_title": "At most one explicit alignment specifier should appear in an object declaration",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_aibb2quva4mn",
          "category": 0,
          "fls_section": "13.-2.25",
          "fls_title": "Attribute ``repr``",
          "score": 0.534,
          "reason": "While Rust allows multiple #[repr(align(N))] attributes (taking the maximum), this is applied to type definitions not object declarations. The C pattern of _Alignas on variable declarations has no Rust equivalent."
        },
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.593,
          "reason": "Section about struct layout, not alignment specification syntax."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C, _Alignas can be applied directly to object declarations (variables), allowing confusing constructs like '_Alignas(4) _Alignas(8) int x;'. In Rust, alignment is specified via #[repr(align(N))] on type definitions only - you cannot specify alignment on individual variable declarations. While Rust technically allows multiple #[repr(align(N))] on a type (taking the maximum), this is uncommon and linted against by clippy. The MISRA concern about 'object declarations' doesn't translate directly since Rust's alignment model is type-centric rather than object-centric."
    },
    {
      "guideline_id": "Rule 8.18",
      "guideline_title": "There shall be no tentative definitions in a header file C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.-2.3",
          "fls_title": "Statics",
          "score": 0.507,
          "reason": "Rust statics have single-definition semantics; no tentative definitions exist."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C 'tentative definitions' (e.g., 'int x;' without initializer in a header) create multiple object instances per translation unit. Rust has no equivalent concept. Rust's statics require explicit 'static' keyword and an initializer, enforcing single-definition semantics. Rust's module system and lack of textual header inclusion prevent the issue entirely - items are defined once and imported by path."
    },
    {
      "guideline_id": "Rule 8.19",
      "guideline_title": "There should be no external declarations in a source file",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.698,
          "reason": "Rust's 'extern' blocks are for FFI declarations, not the C sense of 'external' meaning cross-translation-unit visibility. Rust's module system is fundamentally different from C's header/source model."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's pattern where 'extern' declarations appear in source files rather than headers, breaking modularity. Rust's compilation model is fundamentally different: there are no header files, no textual inclusion, and no 'extern' declarations for Rust items (only for FFI). Items are defined once in a module and made visible via 'pub' and 'use'. Rust's 'extern' blocks (for FFI) typically go in dedicated modules/crates and don't have the modularity concerns MISRA addresses."
    },
    {
      "guideline_id": "Rule 9.1",
      "guideline_title": "The value of an object with automatic storage duration shall not be read before it has been set C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3xvm61x0t251",
          "category": 0,
          "fls_section": "15.-2.2",
          "fls_title": "Initialization",
          "score": 0.646,
          "reason": "Section-level similarity match (score: 0.65)"
        },
        {
          "fls_id": "fls_46910buiwvv9",
          "category": -2,
          "fls_section": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "score": 0.643,
          "reason": "Per FLS: 'A variable shall be initialized before it is accessed.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_ch2lvm50olqd",
          "category": -2,
          "fls_section": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "score": 0.618,
          "reason": "Per FLS: 'When a variable lacks a value or its value has been passed <passing...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_wnhci8phdu4m",
          "category": -2,
          "fls_section": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "score": 0.61,
          "reason": "Per FLS: 'When a variable holds a value, the variable is considered to be ini...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_e5b9n910z1cp",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.593,
          "reason": "Per FLS: 'The value of an indexed initializer is the value of its operand.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_hydq3pvm00bn",
          "category": -2,
          "fls_section": "fls_rjxpof29a3nl",
          "fls_title": "Struct Type Representation",
          "score": 0.592,
          "reason": "Per FLS: 'Initialize a current offset to zero. #.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.-2.1",
          "fls_title": "Values",
          "score": 0.591,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.582,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is eithe...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_6lg0oaaopc26",
          "category": -4,
          "fls_section": "fls_94a8v54bufn8",
          "fls_title": "Values",
          "score": 0.577,
          "reason": "Per FLS: 'It is undefined behavior to create a value from uninitialized memor...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_caufcwkpz689",
          "category": -3,
          "fls_section": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "score": 0.577,
          "reason": "Per FLS: 'All memory starts as uninitialized.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_xuuFKmm181bs",
          "category": -4,
          "fls_section": "fls_94a8v54bufn8",
          "fls_title": "Values",
          "score": 0.575,
          "reason": "Per FLS: 'It is undefined behavior to create an allocated object with memory ...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_z3gj1v6g605r",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.573,
          "reason": "Per FLS: 'The value of a named initializer is the value of its expression.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.-2.3",
          "fls_title": "Statics",
          "score": 0.569,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_gho955gmob73",
          "category": 0,
          "fls_section": "7.-2.5",
          "fls_title": "Variables",
          "score": 0.545,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "category": 0,
          "fls_section": "15.-2.4",
          "fls_title": "Borrowing",
          "score": 0.538,
          "reason": "Section-level similarity match (score: 0.54)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc but can be bypassed by unsafe",
      "confidence": "medium",
      "notes": "MISRA ADD-6: enforced by rustc but can be bypassed by unsafe"
    },
    {
      "guideline_id": "Rule 9.2",
      "guideline_title": "The initializer for an aggregate or union shall be enclosed in braces C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.-2.34",
          "fls_title": "Struct Expressions",
          "score": 0.606,
          "reason": "Rust struct syntax always requires braces - there's no ambiguous form to prohibit."
        },
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.514,
          "reason": "Rust array syntax always requires brackets - there's no ambiguous form to prohibit."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's ambiguous aggregate initialization where braces can be omitted (e.g., 'int arr[2][3] = {1,2,3,4,5,6}'). Rust's syntax is unambiguous by design: arrays use brackets [a, b, c], structs use braces Foo { field: value }, and nested structures require explicit nesting. The compiler enforces this - there's no optional brace syntax to misuse."
    },
    {
      "guideline_id": "Rule 9.3",
      "guideline_title": "Arrays shall not be partially initialized",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.55,
          "reason": "Rust array expressions require all elements but this is a different model than C's partial initialization."
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "category": 0,
          "fls_section": "15.-2.2",
          "fls_title": "Initialization",
          "score": 0.595,
          "reason": "General initialization section, not specific to array partial initialization."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C allows partial array initialization (e.g., 'int arr[5] = {1, 2}' where remaining elements are implicitly zeroed). Rust has no equivalent concept - arrays must be fully initialized via element list [a, b, c] or repetition [x; N]. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 9.4",
      "guideline_title": "An element of an object shall not be initialized more than once",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.61,
          "reason": "Per FLS fls_bbmm5vir9xos: 'Contain at most one matched named initializer'. Per fls_j2kmp1fee0g4: 'Contain at most one matched indexed initializer'. These rules explicitly prevent duplicate field initialization in struct expressions."
        },
        {
          "fls_id": "fls_bbmm5vir9xos",
          "category": -2,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.62,
          "reason": "'Contain at most one matched named initializer' - Rust enforces this at compile time, directly addressing MISRA's concern about duplicate initialization."
        },
        {
          "fls_id": "fls_j2kmp1fee0g4",
          "category": -2,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.6,
          "reason": "'Contain at most one matched indexed initializer' - Prevents duplicate initialization of tuple struct fields."
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "category": 0,
          "fls_section": "15.2",
          "fls_title": "Initialization",
          "score": 0.651,
          "reason": "Defines initialization semantics. Per FLS: 'A variable shall be initialized before it is accessed.' Rust's initialization tracking ensures each field is initialized exactly once."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "high",
      "notes": "MISRA prevents duplicate designated initializers in C. Rust enforces this at compile time via FLS 6.4 (Struct Expressions): each field must have 'at most one matched named/indexed/shorthand initializer'. The compiler emits error E0062 for duplicate field specifications. Per ADD-6: 'enforced by rustc'.",
      "rejected_matches": [
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.1",
          "fls_title": "Values",
          "score": 0.517,
          "reason": "General value semantics, not specifically about initialization uniqueness."
        }
      ]
    },
    {
      "guideline_id": "Rule 9.5",
      "guideline_title": "Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.565,
          "reason": "Rust has no designated initializers - array initialization is either element list or repetition constructor."
        },
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.-2.34",
          "fls_title": "Struct Expressions",
          "score": 0.522,
          "reason": "Struct field initialization is named but this is different from C's designated initializers for arrays."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C99 designated initializers (e.g., 'int arr[10] = {[5] = 1, [2] = 3}') allow sparse array initialization where size can be implicitly determined by highest index. Rust has no designated initializer syntax for arrays - arrays are initialized via element list [a, b, c] (size inferred from count) or repetition [x; N] (size explicit). The concept doesn't exist in Rust."
    },
    {
      "guideline_id": "Rule 9.6",
      "guideline_title": "An initializer using chained designators shall not contain initializers without designators",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.-2.34",
          "fls_title": "Struct Expressions",
          "score": 0.552,
          "reason": "Rust struct expressions use named fields, but this is different from C's chained designators."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C99 chained designators (e.g., 'struct s arr[2] = {[0].x = 1, 2, 3}') allow mixing designated and positional initializers, which is confusing. Rust has no chained designator syntax. Struct fields use named initialization (Foo { x: 1, y: 2 }), and arrays use element lists or repetition. The mixing of designated/non-designated initializers that MISRA prohibits cannot occur in Rust."
    },
    {
      "guideline_id": "Rule 9.7",
      "guideline_title": "Atomic objects shall be appropriately initialized before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.1",
          "fls_title": "Atomics",
          "score": 0.697,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.' Rust's atomic types require const initialization (e.g., AtomicBool::new(false))."
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "category": 0,
          "fls_section": "15.2",
          "fls_title": "Initialization",
          "score": 0.501,
          "reason": "Per FLS fls_46910buiwvv9: 'A variable shall be initialized before it is accessed.' This fundamental rule applies to atomic types - the compiler enforces initialization before access."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_section": "17.0",
          "fls_title": "Concurrency",
          "score": 0.529,
          "reason": "Per FLS fls_tx4b8r6i93n4: 'A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.' Rust's atomic types prevent data races through memory ordering guarantees."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA requires atomic objects to be initialized before access to avoid data races. Rust's atomic types (core::sync::atomic) must be initialized with const constructors like AtomicBool::new(). The compiler enforces FLS fls_46910buiwvv9: 'A variable shall be initialized before it is accessed.' For safe Rust, the type system prevents uninitialized access entirely. For unsafe Rust with static atomics, the const initialization requirement applies.",
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "3.10",
          "fls_title": "Statics",
          "score": 0.524,
          "reason": "About static variable declarations, not specifically about atomic initialization."
        }
      ]
    },
    {
      "guideline_id": "Rule 10.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's type system prevents implicit type conversions entirely. MISRA's 'essential type model' exists because C has implicit conversions between bool/char/numeric - Rust has none.",
      "guideline_title": "Operands shall not be of an inappropriate essential type C90 [Unspecified 23; Implementation G.3.4(8), G.3.5(3,5), G.3.9(6)] C99 [Undefined 13, 48, 49; Implementation J.3.4(2,5), J.3.5(5), J.3.9(6)] C11 [Undefined 15, 51, 52; Implementation J.3.4(2,5), J.3.5(5), J.3.9(7)]",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.7,
          "reason": "About enum discriminant memory layout, not type conversion rules",
          "fls_section": "4.11.2.1",
          "category": -2
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.67,
          "reason": "About &, |, ^ operators, not essential type mixing",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.65,
          "reason": "About unary negation, not type conversion",
          "fls_section": "6.5.4",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_title": "Type Representation",
          "score": 0.64,
          "reason": "About memory layout, not conversion legality rules",
          "fls_section": "4.11.2",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.65,
          "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' All numeric conversions require explicit 'as' cast - no implicit type mixing possible.",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: Numeric widening and narrowing are NOT allowed implicitly. Only reference/pointer coercions are implicit. This prevents C's 'usual arithmetic conversions'.",
          "fls_section": "4.12.3",
          "category": -2
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.45,
          "reason": "Per FLS: Operands of arithmetic operators must be the SAME type. Compiler error if types don't match. MISRA's essential type mixing cannot occur.",
          "fls_section": "6.5.5",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's char type cannot be used in arithmetic. Explicit cast to u32/i32 required for any numeric operations on character values.",
      "guideline_title": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations",
      "rejected_matches": [
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.59,
          "reason": "About unary operators, not char arithmetic",
          "fls_section": "6.5.4",
          "category": -2
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.57,
          "reason": "About +=/-= etc., not char type restrictions",
          "fls_section": "6.5.12",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_wrvjizrqf3po",
          "fls_title": "Char Type",
          "score": 0.59,
          "reason": "Per FLS: Rust's char is a 4-byte Unicode scalar value, NOT a numeric type. Cannot participate in arithmetic without explicit conversion.",
          "fls_section": "4.3.2",
          "category": -2
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Arithmetic operands must be numeric types of the same type. char is not a numeric type, so arithmetic on char is a compile error.",
          "fls_section": "6.5.5",
          "category": -2
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.56,
          "reason": "Per FLS: Must use explicit 'as u32' or similar to convert char to numeric. Conversion is always explicit and intentional.",
          "fls_section": "6.5.10",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.3",
      "guideline_title": "The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category C90 [Undefined 15; Implementation G.3.5(2)] C99 [Undefined 15, 16; Implementation J.3.5(4)] C11 [Undefined 17, 18; Implementation J.3.5(4)]",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's type system prevents implicit narrowing conversions entirely. All numeric type conversions require explicit 'as' casts. The compiler rejects assignments between incompatible types.",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_section": "6.5.10",
          "fls_title": "Type Cast Expressions",
          "score": 0.681,
          "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' Numeric widening/narrowing requires explicit 'as' cast - not implicit.",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_section": "4.12.3",
          "fls_title": "Type Coercion",
          "score": 0.604,
          "reason": "Per FLS: Type coercion list does NOT include numeric widening/narrowing. Only reference/pointer coercions are implicit. This prevents MISRA's narrowing concern.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_lv7w7aalpwm5",
          "fls_section": "4.12.7",
          "fls_title": "Type Inference",
          "score": 0.64,
          "reason": "About how compiler infers types, not about conversion rules between types.",
          "category": -2
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "fls_section": "7.1",
          "fls_title": "Constants",
          "score": 0.589,
          "reason": "About constant declarations, not type conversion.",
          "category": -2
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "fls_section": "6.5.2",
          "fls_title": "Dereference Expression",
          "score": 0.587,
          "reason": "About pointer dereferencing, not numeric type conversion.",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.576,
          "reason": "About memory layout, not conversion legality rules.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C's 'usual arithmetic conversions' don't exist in Rust. Operands must match exactly or code won't compile.",
      "guideline_title": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category C90 [Implementation G.3.6(2)], C99 [Implementation J.3.6(4)], C11 [Implementation J.3.6(5)]",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.69,
          "reason": "Shows Rust's explicit alternative but rule is about implicit conversions which don't exist",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.63,
          "reason": "Operators have same-type requirement but not the focus of this rule",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.6,
          "reason": "About overflow behavior, not type conversion",
          "fls_section": "6.23",
          "category": -1
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.66,
          "reason": "Per FLS: Operands must be the SAME type. 'i32 + i64' is a compile error. No implicit 'usual arithmetic conversions' exist in Rust.",
          "fls_section": "6.5.5",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit numeric widening or narrowing. The 'usual arithmetic conversions' from C simply don't exist in Rust.",
          "fls_section": "4.12.3",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust's 'as' casts can perform potentially inappropriate conversions (truncation, sign loss). Clippy lints 'cast_possible_truncation', 'cast_sign_loss' provide additional enforcement.",
      "guideline_title": "The value of an expression should not be cast to an inappropriate essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.61,
          "reason": "About enum layout, not cast appropriateness",
          "fls_section": "4.11.2.1",
          "category": -2
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.57,
          "reason": "Unary operator, not type casting",
          "fls_section": "6.5.4",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.7,
          "reason": "Per FLS: Rust's 'as' casts allow numeric conversions including truncation and sign changes. While more restricted than C (no arbitrary pointer casts in safe Rust), numeric casts can still silently truncate. Advisory rule applies.",
          "fls_section": "6.5.10",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no implicit widening. Assignment requires exact type match. If wider arithmetic is needed, explicit cast before the operation is required.",
      "guideline_title": "The value of a composite expression shall not be assigned to an object with wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.56,
          "reason": "About struct initialization, not assignment widening",
          "fls_section": "6.11",
          "category": -2
        },
        {
          "fls_id": "fls_3ut3biyra4r9",
          "fls_title": "Assignee Expressions",
          "score": 0.55,
          "reason": "About what can be assigned to, not type widening",
          "fls_section": "6.1.1",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_y4by2i8dl05o",
          "fls_title": "Assignment Expressions",
          "score": 0.58,
          "reason": "Per FLS: Assignment requires types to match exactly. Cannot assign u16 result to u32 variable without explicit cast.",
          "fls_section": "6.5.11",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: No implicit widening coercions. The C pattern of 'u32 x = u16_a + u16_b' (implicit widening) doesn't compile in Rust.",
          "fls_section": "4.12.3",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.45,
          "reason": "Per FLS: Overflow has defined behavior (panic or wrap), not UB. Even if narrow arithmetic overflows, behavior is deterministic.",
          "fls_section": "6.23",
          "category": -1
        }
      ]
    },
    {
      "guideline_id": "Rule 10.7",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Similar to 10.6 - Rust's same-type requirement for operators prevents mixing narrow composite expressions with wider operands.",
      "guideline_title": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.6,
          "reason": "Shows explicit alternative, but rule about implicit conversions which don't exist",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.59,
          "reason": "Same-type requirement but not the focus",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.54,
          "reason": "About overflow, not type widening",
          "fls_section": "6.23",
          "category": -1
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Both operands must be the SAME type. Mixing u16 composite with u32 operand is a compile error.",
          "fls_section": "6.5.5",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit widening. The scenario this rule prevents cannot occur because Rust rejects type mismatches.",
          "fls_section": "4.12.3",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.8",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust allows explicit widening casts after narrow arithmetic. The MISRA concern is partially mitigated by defined overflow behavior, but explicit casts can still mask programmer intent errors.",
      "guideline_title": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.54,
          "reason": "About bitwise operators, not casting composite expressions",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.5,
          "reason": "About type inference, not explicit casting",
          "fls_section": "4.12.2",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.66,
          "reason": "Per FLS: Rust allows explicit widening casts after narrow arithmetic: '(a + b) as u32' is legal. The cast is explicit, making intent clear, but can still mask overflow issues.",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.48,
          "reason": "Per FLS: Overflow has DEFINED behavior (panic in debug, wrap in release) - not UB like C. Mitigates but doesn't eliminate the MISRA concern about implementation-dependent results.",
          "fls_section": "6.23",
          "category": -1
        }
      ]
    },
    {
      "guideline_id": "Rule 11.1",
      "guideline_title": "Conversions shall not be performed between a pointer to a function and any other type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.8",
          "fls_title": "Function Pointer Types",
          "score": 0.669,
          "reason": "Per FLS fls_v2wrytr3t04h: 'A function pointer type is an indirection type that refers to a function.' Defines function pointer as a distinct type."
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.548,
          "reason": "Per FLS fls_133j6xw8k4qe: 'An operand of a function pointer type and a target type *const V or *mut V... perform function-pointer-to-pointer cast.' Per fls_bhw2j9wjpf2x: function-pointer-to-address casts are explicitly defined. Rust allows these casts via 'as' but they require explicit syntax."
        },
        {
          "fls_id": "fls_wz2etmkpvxed",
          "category": -2,
          "fls_section": "4.19",
          "fls_title": "Type Unification",
          "score": 0.705,
          "reason": "'A function pointer type is unifiable only with another function pointer type when...' - Function pointers have strict type compatibility rules, preventing implicit conversions."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "MISRA prohibits conversions between function pointers and other types due to UB. Rust allows explicit casts via 'as' (fn ptr -> *const T, fn ptr -> usize) but these are explicit, not implicit. For safe Rust, function pointers have strict type unification rules (fls_wz2etmkpvxed). For unsafe transmute operations, the user takes responsibility. Per ADD-6: 'includes both safe `as` and unsafe `transmute` operations'.",
      "rejected_matches": [
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.17",
          "fls_title": "Dereference Expression",
          "score": 0.528,
          "reason": "About dereferencing pointers, not about function pointer type conversions."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.2",
      "guideline_title": "Conversions shall not be performed between a pointer to an incomplete type and any other type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_ismr7wwvek4q",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.668,
          "reason": "Per FLS: 'A raw pointer type is unifiable only with another raw pointer type ...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_wz2etmkpvxed",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.654,
          "reason": "Per FLS: 'A function pointer type is unifiable only with another function poi...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_k6ues2936pjq",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.611,
          "reason": "Per FLS: 'Comparing a value of a raw pointer type to a value of a dynamically...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.6,
          "reason": "Per FLS: 'It is a validity invariant for a value of a function pointer type t...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_jd1inwz7ulyw",
          "category": -2,
          "fls_section": "19.-2.4",
          "fls_title": "Unsafety",
          "score": 0.594,
          "reason": "Per FLS: 'Dereferencing a value of a raw pointer type.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_bw8zutjcteki",
          "category": -2,
          "fls_section": "fls_963gsjp2jas2",
          "fls_title": "Type Classification",
          "score": 0.592,
          "reason": "Per FLS: '[Raw pointer type]s' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_rpbhr0xukbx9",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.592,
          "reason": "Per FLS: 'A raw pointer type is an indirection type without validity guarantees.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_6b4rwkrc1ap6",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.59,
          "reason": "Per FLS: 'A dereference expression whose operand's type is a mutable raw poin...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_133j6xw8k4qe",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.589,
          "reason": "Per FLS: 'An operand of a function pointer type and a target type *const V or...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.583,
          "reason": "Per FLS: 'An operand of type *const T or *mut T and a target type *const V or...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.567,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.552,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.-2.24",
          "fls_title": "Type Cast Expressions",
          "score": 0.546,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "category": 0,
          "fls_section": "4.-2.17",
          "fls_title": "Raw Pointer Types",
          "score": 0.532,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "category": 0,
          "fls_section": "4.-2.27",
          "fls_title": "Type Representation",
          "score": 0.527,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 11.3",
      "guideline_title": "A conversion shall not be performed between a pointer to object type and a pointer to a different object type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ismr7wwvek4q",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.695,
          "reason": "Per FLS: 'A raw pointer type is unifiable only with another raw pointer type ...' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_wz2etmkpvxed",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.694,
          "reason": "Per FLS: 'A function pointer type is unifiable only with another function poi...' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_k6ues2936pjq",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.689,
          "reason": "Per FLS: 'Comparing a value of a raw pointer type to a value of a dynamically...' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_jd1inwz7ulyw",
          "category": -2,
          "fls_section": "19.-2.4",
          "fls_title": "Unsafety",
          "score": 0.664,
          "reason": "Per FLS: 'Dereferencing a value of a raw pointer type.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_133j6xw8k4qe",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.659,
          "reason": "Per FLS: 'An operand of a function pointer type and a target type *const V or...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_bw8zutjcteki",
          "category": -2,
          "fls_section": "fls_963gsjp2jas2",
          "fls_title": "Type Classification",
          "score": 0.657,
          "reason": "Per FLS: '[Raw pointer type]s' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_6b4rwkrc1ap6",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.655,
          "reason": "Per FLS: 'A dereference expression whose operand's type is a mutable raw poin...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.651,
          "reason": "Per FLS: 'An operand of type *const T or *mut T and a target type *const V or...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_hrum767l6dte",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.651,
          "reason": "Per FLS: 'Comparing two [value]s of [raw pointer type]s compares the addresse...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_rpbhr0xukbx9",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.638,
          "reason": "Per FLS: 'A raw pointer type is an indirection type without validity guarantees.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.606,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "category": 0,
          "fls_section": "4.-2.17",
          "fls_title": "Raw Pointer Types",
          "score": 0.595,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.-2.24",
          "fls_title": "Type Cast Expressions",
          "score": 0.59,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.578,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "category": 0,
          "fls_section": "15.-2.3",
          "fls_title": "References",
          "score": 0.575,
          "reason": "Section-level similarity match (score: 0.58)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 11.4",
      "guideline_title": "A conversion shall not be performed between a pointer to object and an arithmetic type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.709,
          "reason": "Defines pointer-to-integer and integer-to-pointer casts. Per fls_i4zsbbmfa2fl: 'pointer-to-address cast produces an integer that represents the machine address'. Per fls_59mpteeczzo: 'address-to-pointer cast produces a pointer that interprets the integer as a machine address.' These casts require explicit 'as' syntax."
        },
        {
          "fls_id": "fls_i4zsbbmfa2fl",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.68,
          "reason": "'An operand of type *const T or *mut T... and a target integer type perform pointer-to-address cast... If the integer type is smaller than the type of the operand, the address is truncated.' Addresses truncation concern from MISRA."
        },
        {
          "fls_id": "fls_59mpteeczzo",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.701,
          "reason": "'An operand of integer type and target type *const V or *mut V... perform address-to-pointer cast.' Explicitly requires 'as' cast - no implicit conversion."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA prohibits implicit pointer-integer conversions due to alignment and representation UB. Rust requires explicit 'as' casts for pointer<->integer conversions (fls_i4zsbbmfa2fl, fls_59mpteeczzo). The explicit syntax ensures developer awareness. Using raw pointer casts to dereference requires unsafe context. For usize/isize, the cast is well-defined; for smaller integers, truncation occurs (documented in FLS).",
      "rejected_matches": [
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "7.3",
          "fls_title": "Arithmetic Overflow",
          "score": 0.586,
          "reason": "About integer overflow, not about pointer-integer conversions."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.5",
      "guideline_title": "A conversion should not be performed from pointer to void into pointer to object C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_k6ues2936pjq",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.661,
          "reason": "Per FLS: 'Comparing a value of a raw pointer type to a value of a dynamically...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_jd1inwz7ulyw",
          "category": -2,
          "fls_section": "19.-2.4",
          "fls_title": "Unsafety",
          "score": 0.659,
          "reason": "Per FLS: 'Dereferencing a value of a raw pointer type.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.657,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is eithe...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_5dd7icjcl3nt",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.641,
          "reason": "Per FLS: 'An unsafe function pointer type is a function pointer type subject ...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.64,
          "reason": "Per FLS: 'It is a validity invariant for a value of a function pointer type t...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_8i4jzksxlrw0",
          "category": -2,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.63,
          "reason": "Per FLS: 'Dereferencing a raw pointer shall require unsafe context unless the...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_hrum767l6dte",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.629,
          "reason": "Per FLS: 'Comparing two [value]s of [raw pointer type]s compares the addresse...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_rpbhr0xukbx9",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.628,
          "reason": "Per FLS: 'A raw pointer type is an indirection type without validity guarantees.' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_g1iYVw7upBnH",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.613,
          "reason": "Per FLS: 'The return type of a function pointer type is determined as follows:' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_bhw2j9wjpf2x",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.601,
          "reason": "Per FLS: 'An operand of a function pointer type and a target integer type per...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.592,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.563,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "category": 0,
          "fls_section": "4.-2.17",
          "fls_title": "Raw Pointer Types",
          "score": 0.557,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.53,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 11.6",
      "guideline_title": "A cast shall not be performed between pointer to void and an arithmetic type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.658,
          "reason": "Defines all pointer-to-integer and integer-to-pointer casts. Rust's *const T/*mut T (including *const ()) can be cast to usize/isize via explicit 'as', but requires unsafe for dereferencing."
        },
        {
          "fls_id": "fls_i4zsbbmfa2fl",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.644,
          "reason": "Per FLS: 'An operand of type *const T or *mut T... and a target integer type perform pointer-to-address cast.' This covers void pointer (*const ()) to integer conversion."
        },
        {
          "fls_id": "fls_59mpteeczzo",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.664,
          "reason": "Per FLS: 'An operand of integer type and target type *const V or *mut V... perform address-to-pointer cast.' Covers integer to void pointer conversion."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA prohibits void* <-> arithmetic conversions. Rust doesn't have void* but uses *const ()/*mut c_void. These can be cast to usize/isize via explicit 'as' (fls_i4zsbbmfa2fl, fls_59mpteeczzo). No implicit conversions exist. Floating-point to pointer is not directly supported in Rust - would require intermediate integer cast. Only applicable in unsafe Rust for dereferencing.",
      "rejected_matches": [
        {
          "fls_id": "fls_pcromhosmnf0",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.704,
          "reason": "About bool/char to integer casts, not about void pointer conversions."
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "7.3",
          "fls_title": "Arithmetic Overflow",
          "score": 0.506,
          "reason": "About integer overflow, not about pointer-integer conversions."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.8",
      "guideline_title": "A conversion shall not remove any const, volatile or _Atomic qualification from the type pointed to by a pointer C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_k6ues2936pjq",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.67,
          "reason": "Per FLS: 'Comparing a value of a raw pointer type to a value of a dynamically...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.668,
          "reason": "Per FLS: 'An operand of type *const T or *mut T and a target type *const V or...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_133j6xw8k4qe",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.665,
          "reason": "Per FLS: 'An operand of a function pointer type and a target type *const V or...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_8uWfFAsZeRCs",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.664,
          "reason": "Per FLS: 'An immutable raw pointer type is a raw pointer type subject to keyw...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_ismr7wwvek4q",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.659,
          "reason": "Per FLS: 'A raw pointer type is unifiable only with another raw pointer type ...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_i4zsbbmfa2fl",
          "category": -2,
          "fls_section": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.658,
          "reason": "Per FLS: 'An operand of type *const T or *mut T where T implements the core::...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_6b4rwkrc1ap6",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.657,
          "reason": "Per FLS: 'A dereference expression whose operand's type is a mutable raw poin...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_e0a1e8ddph7",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.65,
          "reason": "Per FLS: '[Type cast expression]s that are not [pointer-to-address cast]s, [f...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_jd1inwz7ulyw",
          "category": -2,
          "fls_section": "19.-2.4",
          "fls_title": "Unsafety",
          "score": 0.647,
          "reason": "Per FLS: 'Dereferencing a value of a raw pointer type.' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_e3lgrtqb7jwe",
          "category": -2,
          "fls_section": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.644,
          "reason": "Per FLS: 'The source type is &T and the target type is *const T.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.-2.24",
          "fls_title": "Type Cast Expressions",
          "score": 0.617,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "category": 0,
          "fls_section": "15.-2.3",
          "fls_title": "References",
          "score": 0.601,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.593,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "category": 0,
          "fls_section": "4.-2.17",
          "fls_title": "Raw Pointer Types",
          "score": 0.589,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "category": 0,
          "fls_section": "4.-2.33",
          "fls_title": "Type Coercion",
          "score": 0.588,
          "reason": "Section-level similarity match (score: 0.59)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 11.9",
      "guideline_title": "The macro NULL shall be the only permitted form of integer null pointer constant",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.591,
          "reason": "About function pointer validity invariants, not null pointer constants."
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "category": 0,
          "fls_section": "7.-2.2",
          "fls_title": "Constants",
          "score": 0.53,
          "reason": "About Rust constants in general, not null pointer representation."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "Rust does not have a null pointer constant",
      "confidence": "high",
      "notes": "Rust has no NULL macro or integer null pointer constant. For raw pointers, Rust uses std::ptr::null() and std::ptr::null_mut() functions. For safe code, Option<T> replaces nullable pointers entirely. The C pattern of using 0 or (void*)0 as null doesn't exist in Rust. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 11.10",
      "guideline_title": "The _Atomic qualifier shall not be applied to the incomplete type void",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.-2.3",
          "fls_title": "Atomics",
          "score": 0.613,
          "reason": "Rust atomics are types (AtomicU32, AtomicPtr<T>, etc.) not qualifiers. No _Atomic qualifier exists."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C11's _Atomic is a type qualifier that can be applied to arbitrary types including void. Rust has no _Atomic qualifier - atomics are distinct types in core::sync::atomic (AtomicBool, AtomicU32, AtomicPtr<T>, etc.). You cannot create an 'atomic void' in Rust because atomics are concrete types, not qualifiers. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 11.11",
      "guideline_title": "Pointers shall not be implicitly compared to NULL",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.602,
          "reason": "Per FLS: 'It is a validity invariant for a value of a function pointer type t...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_k6ues2936pjq",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.557,
          "reason": "Per FLS: 'Comparing a value of a raw pointer type to a value of a dynamically...' (similarity: 0.56)"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA ADD-6: enforced by rustc"
    },
    {
      "guideline_id": "Rule 12.1",
      "guideline_title": "The precedence of operators within expressions should be made explicit",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_kw25194gpael",
          "category": 0,
          "fls_section": "6.21",
          "fls_title": "Expression Precedence",
          "score": 0.733,
          "reason": "FLS defines operator precedence and associativity rules. Rust has a well-defined precedence table. The MISRA concern about making precedence explicit applies - Rust allows parentheses for clarity."
        },
        {
          "fls_id": "fls_ckvjj4tt1hh2",
          "category": 0,
          "fls_section": "6.0",
          "fls_title": "Expressions",
          "score": 0.649,
          "reason": "Chapter-level context for expression semantics and evaluation order."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA recommends explicit parentheses for precedence clarity. FLS 6.21 (Expression Precedence) defines Rust's operator precedence. Rust's precedence is well-defined but MISRA's stylistic recommendation to use parentheses for clarity applies equally. Clippy lint 'precedence' can warn about complex expressions.",
      "rejected_matches": [
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.3",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.676,
          "reason": "About compound assignment operators specifically, not about general precedence."
        }
      ]
    },
    {
      "guideline_id": "Rule 12.2",
      "guideline_title": "The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_fbazfgd5m1ot",
          "category": -2,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.777,
          "reason": "Per FLS: 'The value of a shift right expression is the result of core::ops::S...' (similarity: 0.78)"
        },
        {
          "fls_id": "fls_kqntxbwnc58v",
          "category": -2,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.767,
          "reason": "Per FLS: 'The value of a shift left expression is the result of core::ops::Sh...' (similarity: 0.77)"
        },
        {
          "fls_id": "fls_r02OGonXp93A",
          "category": -3,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.738,
          "reason": "Per FLS: 'If the types of both [operand]s are [integer type]s, then the shift...' (similarity: 0.74)"
        },
        {
          "fls_id": "fls_f0p70y92k14f",
          "category": -3,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.737,
          "reason": "Per FLS: 'If the types of both [operand]s are [integer type]s, then the shift...' (similarity: 0.74)"
        },
        {
          "fls_id": "fls_8trozue35xe4",
          "category": -2,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.724,
          "reason": "Per FLS: 'The type of a shift left expression is associated type core::ops::S...' (similarity: 0.72)"
        },
        {
          "fls_id": "fls_yq8rtwfp3nv0",
          "category": -2,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.722,
          "reason": "Per FLS: 'The type of a shift right expression is associated type core::ops::...' (similarity: 0.72)"
        },
        {
          "fls_id": "fls_303r0u6ug215",
          "category": -3,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.692,
          "reason": "Per FLS: 'The evaluation of a shift right expression proceeds as follows: #.' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_2kkpr955i4lm",
          "category": -3,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.69,
          "reason": "Per FLS: 'The evaluation of a shift left expression proceeds as follows: #.' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_t709sl4co3al",
          "category": -2,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.685,
          "reason": "Per FLS: 'A shift right expression is a bit expression that uses bit shift ri...' (similarity: 0.68)"
        },
        {
          "fls_id": "fls_1f4pc612f2a8",
          "category": -2,
          "fls_section": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.683,
          "reason": "Per FLS: 'The type of the left operand of a shift left expression shall imple...' (similarity: 0.68)"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "category": 0,
          "fls_section": "6.-2.20",
          "fls_title": "Bit Expressions",
          "score": 0.51,
          "reason": "Section-level similarity match (score: 0.51)"
        },
        {
          "fls_id": "fls_3qnpv2z7yjil",
          "category": 0,
          "fls_section": "4.-2.6",
          "fls_title": "Integer Types",
          "score": 0.508,
          "reason": "Section-level similarity match (score: 0.51)"
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.-2.24",
          "fls_title": "Type Cast Expressions",
          "score": 0.503,
          "reason": "Section-level similarity match (score: 0.50)"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "6.-1.2",
          "fls_title": "Arithmetic Overflow",
          "score": 0.501,
          "reason": "Section-level similarity match (score: 0.50)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 12.3",
      "guideline_title": "The comma operator should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_1pg5ig740tg1",
          "category": 0,
          "fls_section": "8.-2.3",
          "fls_title": "Expression Statements",
          "score": 0.526,
          "reason": "Rust has no comma operator. Expression statements are separated by semicolons, not commas."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no comma operator. In C, the comma operator evaluates left operand, discards result, evaluates right operand (e.g., 'a = (b++, c)'). Rust uses semicolons to separate statements and has no equivalent construct. Tuple construction uses commas but that's syntactically distinct. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 12.4",
      "guideline_title": "Evaluation of constant expressions should not lead to unsigned integer wrap-around",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_Et5gp1I7VqBX",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.695,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.70)"
        },
        {
          "fls_id": "fls_b46nyamfqxdu",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.69,
          "reason": "Per FLS: 'The evaluation of a constant expression that results in arithmetic ...' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_6z45ss502alt",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.686,
          "reason": "Per FLS: '[Bit expression]s of [scalar type]s,' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_QMpI8K43K2yU",
          "category": -3,
          "fls_section": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.653,
          "reason": "Per FLS: 'The resulting value of the expression may be truncated, discarding ...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_Vy0DyZqfy7Iv",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.65,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_NcLf4o1dpniS",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.649,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_y6ore0iwx7e0",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.646,
          "reason": "Per FLS: '[Arithmetic expression]s of [scalar type]s,' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_Kdr6fLrRj0Du",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.646,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_lSxXWxJn0vMO",
          "category": -3,
          "fls_section": "fls_izdv9i4spokw",
          "fls_title": "Operator Expressions",
          "score": 0.643,
          "reason": "Per FLS: 'An operator expression that operates with [floating-point value]s r...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_zyuxqty09SDO",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.638,
          "reason": "Per FLS: 'All forms of [borrow]s except those of expressions that are subject...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "6.-1.2",
          "fls_title": "Arithmetic Overflow",
          "score": 0.629,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_66m4rnbssgig",
          "category": 0,
          "fls_section": "6.-2.3",
          "fls_title": "Constant Expressions",
          "score": 0.609,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_wttihxen35as",
          "category": 0,
          "fls_section": "7.-2.6",
          "fls_title": "Constant Promotion",
          "score": 0.541,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "category": 0,
          "fls_section": "6.-2.20",
          "fls_title": "Bit Expressions",
          "score": 0.528,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "category": 0,
          "fls_section": "6.-2.18",
          "fls_title": "Negation Expression",
          "score": 0.526,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this is either well-defined or will not occur",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is either well-defined or will not occur. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 12.5",
      "guideline_title": "The sizeof operator shall not have an operand which is a function parameter declared as \"array of type\"",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_uj0kpjwyld60",
          "category": 0,
          "fls_section": "4.-2.7",
          "fls_title": "Array Types",
          "score": 0.501,
          "reason": "Rust arrays don't decay to pointers. Array parameters retain their type information."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C, arrays decay to pointers when passed as function parameters, so sizeof on such a parameter gives pointer size, not array size. Rust has no array-to-pointer decay: arrays are passed by reference (&[T; N]) or as slices (&[T]). std::mem::size_of::<[T; N]>() always gives the actual array size. The C pitfall doesn't exist in Rust. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 12.6",
      "guideline_title": "Structure and union members of atomic objects shall not be directly accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.-2.3",
          "fls_title": "Atomics",
          "score": 0.759,
          "reason": "Rust atomics are opaque types, not structs with accessible members. You cannot directly access internal fields."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C11, _Atomic can be applied to struct types, and directly accessing members of such atomic structs is non-atomic and unsafe. Rust's atomic types (AtomicU32, AtomicBool, etc.) are opaque - they don't expose internal fields. You must use methods like load(), store(), compare_exchange() which guarantee atomic access. There's no way to directly access 'members' of an atomic in Rust. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 13.1",
      "guideline_title": "Initializer lists shall not contain persistent side effects C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.682,
          "reason": "Struct expressions define field initialization order. Per ADD-6: 'order of evaluation is strict in Rust' - field initializers are evaluated left-to-right."
        },
        {
          "fls_id": "fls_ckvjj4tt1hh2",
          "category": 0,
          "fls_section": "6.0",
          "fls_title": "Expressions",
          "score": 0.6,
          "reason": "Rust expressions have defined evaluation order, unlike C's unspecified order in initializer lists."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "order of evaluation is strict in Rust",
      "confidence": "high",
      "notes": "MISRA prohibits side effects in initializers due to C's unspecified evaluation order. Rust has strict left-to-right evaluation order (per ADD-6). Side effects in struct field initializers are well-defined, making the MISRA concern less critical but still relevant for readability.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 13.2",
      "guideline_title": "The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders and shall be independent from thread interleaving C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.697,
          "reason": "Similarity due to 'evaluation order' term but FLS discusses control flow divergence (break/return/panic), not C-style unspecified operand evaluation order."
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.641,
          "reason": "Matched on 'expression' and 'evaluation' terms. This section defines dereference semantics, not evaluation order between operands."
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.-2.28",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.631,
          "reason": "Matched on 'evaluation' and 'operand' terms. Rust compound assignments have defined order (left then right), unlike C's unspecified order."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "order of evaluation is strict in Rust",
      "confidence": "high",
      "notes": "Rust has defined left-to-right evaluation order for all expressions (e.g., FLS Arithmetic Expressions: 'The left operand is evaluated. The right operand is evaluated.'). C allows unspecified evaluation order leading to undefined behavior. The MISRA concern does not apply to Rust."
    },
    {
      "guideline_id": "Rule 13.3",
      "guideline_title": "A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "category": 0,
          "fls_section": "6.11",
          "fls_title": "Arithmetic Expressions",
          "score": 0.682,
          "reason": "Matched on 'operator' and 'expression' terms. Rust arithmetic uses +, -, *, / operators but has no ++ or -- operators."
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.-2.28",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.545,
          "reason": "Rust uses += and -= for increment/decrement but these are statements, not expressions that return values like C's ++ and --."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust does not have ++ or -- operators. Increment/decrement is done via compound assignment (x += 1) which returns unit type, not the modified value. The MISRA concern about side effects from these operators does not apply."
    },
    {
      "guideline_id": "Rule 13.4",
      "guideline_title": "The result of an assignment operator should not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_y4by2i8dl05o",
          "category": 0,
          "fls_section": "6.-2.25",
          "fls_title": "Assignment Expressions",
          "score": 0.643,
          "reason": "This section confirms rule is not applicable: per fls_qengy157fa4a 'The type of an assignment expression is the unit type' and fls_bwwtgqprbxrm 'The value of an assignment expression is the unit value.' Unlike C where a=5 returns 5, Rust assignment returns ()."
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.-2.28",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.671,
          "reason": "Matched on 'assignment operator' terms. Compound assignments (+=, -=) also return unit type in Rust, so their result cannot be used."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C, 'a = 5' returns 5, enabling problematic patterns like 'a = b = c = 0' or 'if (a = b)'. In Rust, assignment expressions return the unit type () per FLS fls_qengy157fa4a, so the result cannot be used. The MISRA concern is structurally prevented."
    },
    {
      "guideline_id": "Rule 13.5",
      "guideline_title": "The right hand operand of a logical && or || operator shall not contain persistent side effects",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dltmd8e8c5ia",
          "category": -2,
          "fls_section": "fls_rm4ncoopcdvj",
          "fls_title": "Drop Scopes",
          "score": 0.606,
          "reason": "Per FLS: 'The drop scope of the right operand of a lazy boolean expression.' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_jugckad775kq",
          "category": -3,
          "fls_section": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.591,
          "reason": "Per FLS: 'The left operand is evaluated. #.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_p0rafjsridre",
          "category": -3,
          "fls_section": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.591,
          "reason": "Per FLS: 'The left operand is evaluated. #.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_yg1348rlziw3",
          "category": -3,
          "fls_section": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.589,
          "reason": "Per FLS: 'If the left operand evaluated to false, then the right operand is e...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.589,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_lstusiu2c8lu",
          "category": 0,
          "fls_section": "6.-2.22",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.588,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_tmfmu3syxp2q",
          "category": -3,
          "fls_section": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.574,
          "reason": "Per FLS: 'If the left operand evaluated to true, then the right operand is ev...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_srfv1d4idxy9",
          "category": -3,
          "fls_section": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.573,
          "reason": "Per FLS: 'Otherwise the lazy and expression evaluates to false.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_yffozo2vq5xz",
          "category": -3,
          "fls_section": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.573,
          "reason": "Per FLS: 'Otherwise the lazy or expression evaluates to true.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_1r29rtnjlkql",
          "category": -2,
          "fls_section": "fls_ckvjj4tt1hh2",
          "fls_title": "Expressions",
          "score": 0.571,
          "reason": "Per FLS: 'A left operand is an operand that appears on the left-hand side of ...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_lSxXWxJn0vMO",
          "category": -3,
          "fls_section": "fls_izdv9i4spokw",
          "fls_title": "Operator Expressions",
          "score": 0.567,
          "reason": "Per FLS: 'An operator expression that operates with [floating-point value]s r...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_i9sxf2q5jjqt",
          "category": -2,
          "fls_section": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "score": 0.563,
          "reason": "Per FLS: 'The value of an if expression is the value of its block expression.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "category": 0,
          "fls_section": "6.-2.18",
          "fls_title": "Negation Expression",
          "score": 0.562,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_mkut7gut49gi",
          "category": 0,
          "fls_section": "6.-2.48",
          "fls_title": "If Expressions",
          "score": 0.552,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_kw25194gpael",
          "category": 0,
          "fls_section": "6.-2.53",
          "fls_title": "Expression Precedence",
          "score": 0.549,
          "reason": "Section-level similarity match (score: 0.55)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 13.6",
      "guideline_title": "The operand of the sizeof operator shall not contain any expression which has potential side effects C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.75,
          "reason": "Matched on 'size operand' term but this refers to array size [T; N], not C's sizeof operator. Rust's std::mem::size_of::<T>() takes a type parameter, not an expression."
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "category": 0,
          "fls_section": "4.-2.26",
          "fls_title": "Type Layout",
          "score": 0.593,
          "reason": "Describes type size/alignment concepts but Rust has no sizeof operator that takes expressions. size_of::<T>() is a generic function taking a type."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is not an expression operator in Rust",
      "confidence": "high",
      "notes": "Rust has no sizeof operator. Size is obtained via std::mem::size_of::<T>() which takes a type parameter, not an expression. You cannot write size_of(x + y) in Rust, eliminating the MISRA concern about unevaluated side effects in sizeof operands."
    },
    {
      "guideline_id": "Rule 14.1",
      "guideline_title": "A loop counter shall not have essentially floating type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_XEc0cIkpkyzJ",
          "category": -2,
          "fls_section": "fls_rr908hgunja7",
          "fls_title": "Loop Expressions",
          "score": 0.578,
          "reason": "Per FLS: 'The type of the loop body shall be the unit type.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_b4xporvr64s",
          "category": 0,
          "fls_section": "4.-2.5",
          "fls_title": "Floating Point Types",
          "score": 0.538,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_29tlg1vyqay2",
          "category": 0,
          "fls_section": "2.-2.14",
          "fls_title": "Float Literals",
          "score": 0.528,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_sf4qnd43z2wc",
          "category": 0,
          "fls_section": "6.-2.41",
          "fls_title": "Infinite Loops",
          "score": 0.507,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to while loops only",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to while loops only"
    },
    {
      "guideline_id": "Rule 14.2",
      "guideline_title": "A for loop shall be well-formed",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_onfyolkcbeh3",
          "category": 0,
          "fls_section": "6.-2.40",
          "fls_title": "For Loops",
          "score": 0.753,
          "reason": "Matched on 'for loop' term but Rust's for loop is fundamentally different from C's. Per FLS: 'A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.' Rust for is 'for pattern in iterator', not C's 'for(init; cond; update)'."
        },
        {
          "fls_id": "fls_rr908hgunja7",
          "category": 0,
          "fls_section": "6.-2.39",
          "fls_title": "Loop Expressions",
          "score": 0.651,
          "reason": "General loop semantics section. Rust loops are iterator-based or infinite (loop {}), not the 3-part C for loop that MISRA constrains."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA's 'well-formed for loop' constrains C's 3-part for(init; cond; update) construct to prevent misuse. Rust's for loop is 'for pattern in iterator' per FLS fls_onfyolkcbeh3, based on IntoIterator trait. There is no separate init/condition/update to misuse. The C-specific concern does not apply."
    },
    {
      "guideline_id": "Rule 14.3",
      "guideline_title": "Controlling expressions shall not be invariant",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_zyuxqty09SDO",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.688,
          "reason": "Per FLS: 'All forms of [borrow]s except those of expressions that are subject...' (similarity: 0.69)"
        },
        {
          "fls_id": "fls_ucFupTeCyylb",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.646,
          "reason": "Per FLS: 'The block expression of a const block expression.' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_to4e7imq2c0w",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.644,
          "reason": "Per FLS: '[Dereference expression]s,' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_b5fraqx07wuo",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.641,
          "reason": "Per FLS: '[If let expression]s,' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_qvofy4wkql0s",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.638,
          "reason": "Per FLS: '[While loop expression]s.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_pdDr8Lk1GQ0T",
          "category": -2,
          "fls_section": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "score": 0.634,
          "reason": "Per FLS: 'Any expression whose evaluation requires the evaluation of a diverg...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_fobs8ebt7dhc",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.631,
          "reason": "Per FLS: '[Struct expression]s,' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_kwg8a351vc7",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.631,
          "reason": "Per FLS: '[Lazy boolean expression]s of [scalar type]s,' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_qls0wj8bmupz",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.63,
          "reason": "Per FLS: '[If expression]s,' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_zcuzhw7qkzkr",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.627,
          "reason": "Per FLS: '[Unsafe block expression]s,' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_mkut7gut49gi",
          "category": 0,
          "fls_section": "6.-2.48",
          "fls_title": "If Expressions",
          "score": 0.619,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_66m4rnbssgig",
          "category": 0,
          "fls_section": "6.-2.3",
          "fls_title": "Constant Expressions",
          "score": 0.618,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.614,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_8l74abhlxzdl",
          "category": 0,
          "fls_section": "6.-2.51",
          "fls_title": "Return Expressions",
          "score": 0.606,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_ckvjj4tt1hh2",
          "category": 0,
          "fls_section": "6.-2.1",
          "fls_title": "Expressions",
          "score": 0.588,
          "reason": "Section-level similarity match (score: 0.59)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 14.4",
      "guideline_title": "The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_mkut7gut49gi",
          "category": 0,
          "fls_section": "6.-2.48",
          "fls_title": "If Expressions",
          "score": 0.651,
          "reason": "Section-level similarity match (score: 0.65)"
        },
        {
          "fls_id": "fls_Mcpwyvz47SoG",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.65,
          "reason": "Per FLS: 'If the else expression has an if expression, infer that nested if e...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_wf11yp1jwf53",
          "category": -2,
          "fls_section": "fls_sf4qnd43z2wc",
          "fls_title": "Infinite Loops",
          "score": 0.649,
          "reason": "Per FLS: 'If the infinite loop expression contains at least one break express...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_1e8qer6bh2f3",
          "category": -2,
          "fls_section": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "score": 0.648,
          "reason": "Per FLS: 'The type of an else expression is the type of its block expression,...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_r7gzxo16esri",
          "category": -2,
          "fls_section": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "score": 0.647,
          "reason": "Per FLS: 'The type of the subject expression of an if expression shall be typ...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_Esa4ST7lLp8T",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.647,
          "reason": "Per FLS: 'A for loop expression is inferred by unifying the type of its patte...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_iv9t4nfs4f6w",
          "category": -2,
          "fls_section": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "score": 0.642,
          "reason": "Per FLS: 'The type of an if expression is the type of its block expression.' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_4vyrufo4qdeg",
          "category": -2,
          "fls_section": "fls_p0t1ch115tra",
          "fls_title": "If Let Expressions",
          "score": 0.635,
          "reason": "Per FLS: 'The type of an if let expression is the type of its block expression.' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_u0gwo0s2l0tn",
          "category": -2,
          "fls_section": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.633,
          "reason": "Per FLS: 'The [type]s of the [operand]s of a lazy boolean expression shall be...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_KRQxdSav1KBA",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.63,
          "reason": "Per FLS: 'If the else expression has a block expression, infer the block expr...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_lEr4iqwdBcbA",
          "category": -2,
          "fls_section": "fls_p0t1ch115tra",
          "fls_title": "If Let Expressions",
          "score": 0.625,
          "reason": "Per FLS: 'The type of an if let expression and the type of an else expression...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_p0t1ch115tra",
          "category": 0,
          "fls_section": "6.-2.49",
          "fls_title": "If Let Expressions",
          "score": 0.614,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_onfyolkcbeh3",
          "category": 0,
          "fls_section": "6.-2.40",
          "fls_title": "For Loops",
          "score": 0.606,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_lstusiu2c8lu",
          "category": 0,
          "fls_section": "6.-2.22",
          "fls_title": "Lazy Boolean Expressions",
          "score": 0.599,
          "reason": "Section-level similarity match (score: 0.60)"
        },
        {
          "fls_id": "fls_jr4tpuyksr75",
          "category": 0,
          "fls_section": "6.-2.45",
          "fls_title": "Break Expressions",
          "score": 0.594,
          "reason": "Section-level similarity match (score: 0.59)"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA ADD-6: enforced by rustc"
    },
    {
      "guideline_id": "Rule 15.1",
      "guideline_title": "The goto statement should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no goto statement. Control flow is managed through structured constructs (loop, while, for, if, match) and labeled breaks/continues."
    },
    {
      "guideline_id": "Rule 15.2",
      "guideline_title": "The goto statement shall jump to a label declared later in the same function",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no goto statement. Labeled breaks/continues only jump to enclosing loops, never forward to arbitrary labels."
    },
    {
      "guideline_id": "Rule 15.3",
      "guideline_title": "Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no goto statement. Loop labels for break/continue are scoped to the labeled loop expression.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.4",
      "guideline_title": "There should be no more than one break or goto statement used to terminate any iteration statement",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_jr4tpuyksr75",
          "category": 0,
          "fls_section": "6.15",
          "fls_title": "Break Expressions",
          "score": 0.665,
          "reason": "Defines break expression semantics. Rust allows labeled breaks for loop control, making multi-level breaks explicit and traceable."
        },
        {
          "fls_id": "fls_sjwrlwvpulp",
          "category": 0,
          "fls_section": "6.16",
          "fls_title": "Continue Expressions",
          "score": 0.55,
          "reason": "Defines continue expression semantics. Like break, supports labels for multi-level continues."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA limits break/goto to improve control flow clarity. Rust has no goto statement. Break and continue support labels for multi-level control flow (break 'label), making intent explicit. This is a stylistic guideline - Rust's labeled breaks are more structured than C's goto.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.5",
      "guideline_title": "A function should have a single point of exit at the end",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ofqy10q4a9jk",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.611,
          "reason": "Per FLS: 'Any lifetime related to the return type of a function.' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_4wDpAHhnWZAB",
          "category": -2,
          "fls_section": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "score": 0.598,
          "reason": "Per FLS: '[Call expression]s and [method call expression]s if the return type...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_5v3j5ghhw8j8",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.596,
          "reason": "Per FLS: 'A return expression shall appear within a control flow boundary.' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_8l74abhlxzdl",
          "category": 0,
          "fls_section": "6.-2.51",
          "fls_title": "Return Expressions",
          "score": 0.585,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_yofbo96tjppf",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.584,
          "reason": "Per FLS: 'Any lifetime related to the return type of a function pointer type.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_njndlx2rps2k",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.578,
          "reason": "Per FLS: 'If the return expression has an operand, then the value is the valu...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_crb6m6b3cdwh",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.574,
          "reason": "Per FLS: 'If a function has a self parameter with exactly 1 self input lifeti...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_6km3cbchuxr2",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.574,
          "reason": "Per FLS: 'If a construct has exactly one input lifetime, then that lifetime i...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_7Ck4LMQMeQCv",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.568,
          "reason": "Per FLS: 'The type of a return expression is the never type.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_vljy4mm0zca2",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.567,
          "reason": "Per FLS: 'A return type is the type of the result a function, closure type or...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_d9avvfi548t7",
          "category": -3,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.558,
          "reason": "Per FLS: 'If the return expression has an operand, then #.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.545,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_jr4tpuyksr75",
          "category": 0,
          "fls_section": "6.-2.45",
          "fls_title": "Break Expressions",
          "score": 0.526,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.509,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "no longer endorsed by MISRA",
      "confidence": "medium",
      "notes": "MISRA ADD-6: no longer endorsed by MISRA"
    },
    {
      "guideline_id": "Rule 15.6",
      "guideline_title": "The body of an iteration-statement or a selection-statement shall be a compound-statement",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust enforces this by design. All if/loop/while/for/match constructs require block expressions as their body - single statements are not allowed. The \"dangling else\" ambiguity is impossible.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.7",
      "guideline_title": "All if \u2026 else if constructs shall be terminated with an else statement",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_mkut7gut49gi",
          "category": 0,
          "fls_section": "6.7",
          "fls_title": "If Expressions",
          "score": 0.653,
          "reason": "Defines if/else expression semantics. Rust if is an expression, which naturally encourages exhaustive handling when used for values."
        },
        {
          "fls_id": "fls_e5td0fa92fay",
          "category": 0,
          "fls_section": "6.6",
          "fls_title": "Match Expressions",
          "score": 0.55,
          "reason": "Match expressions require exhaustive pattern coverage, providing a stronger alternative to if-else chains."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA requires else clause for defensive programming. Rust's if is an expression - when used for its value, both branches must return compatible types (implicit exhaustiveness). For statement-style if, this is a stylistic recommendation. Match expressions provide compiler-enforced exhaustiveness as an alternative to if-else chains.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.1",
      "guideline_title": "All switch statements shall be well-formed",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no switch statement. Match expressions have stricter, well-defined semantics: exhaustive patterns required, no fall-through, each arm is an expression.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.2",
      "guideline_title": "A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no switch or case labels. Match arm patterns are syntactically bound to their match expression - they cannot appear elsewhere.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.3",
      "guideline_title": "Every switch-clause shall be appropriately terminated",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust match arms have no fall-through semantics. Each arm is an expression that evaluates to a value - there is no need for break statements and no accidental fall-through.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.4",
      "guideline_title": "Every switch statement shall have a default label",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "a corresponding match expression must be complete",
      "confidence": "high",
      "notes": "Rust match expressions must be exhaustive - the compiler enforces that all possible values are covered. A wildcard pattern (_) serves as the equivalent of default when needed.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "rust_prevents"
    },
    {
      "guideline_id": "Rule 16.5",
      "guideline_title": "A default label shall appear as either the first or the last switch label of a switch statement",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "irrefutable pattern causes a subsequent refutable one to be unreachable",
      "confidence": "high",
      "notes": "Rust has no default label. Wildcard patterns (_) in match expressions are ordered by specificity, not position, and the compiler checks for unreachable patterns.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 16.6",
      "guideline_title": "Every switch statement shall have at least two switch-clauses",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust allows single-arm match expressions, though if-let or let-else are often more idiomatic for single-pattern matching.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 16.7",
      "guideline_title": "A switch-expression shall not have essentially Boolean type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no switch statement. Match expressions on bool are allowed but using if/else is more idiomatic for boolean conditions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.1",
      "guideline_title": "The standard header file <stdarg.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no stdarg.h equivalent. Variadic functions are only available in extern \"C\" FFI declarations. Safe Rust functions cannot be variadic.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.2",
      "guideline_title": "Functions shall not call themselves, either directly or indirectly",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "No high-confidence FLS matches found"
    },
    {
      "guideline_id": "Rule 17.3",
      "guideline_title": "A function shall not be declared implicitly",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no implicit function declarations. All functions must be explicitly declared before use - the compiler enforces this strictly.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.4",
      "guideline_title": "All exit paths from a function with non-void return type shall have an explicit return statement with an expression",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "the return keyword is not needed to return a value in Rust, only to exit",
      "confidence": "high",
      "notes": "Rust enforces this at compile time. All code paths in a non-unit-returning function must produce a value of the correct type. The last expression in a block is the return value.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.5",
      "guideline_title": "The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C arrays decay to pointers, losing size info. Rust arrays [T; N] carry size in the type. Slices &[T] carry runtime length. This C problem does not exist in Rust.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.7",
      "guideline_title": "The value returned by a function having non-void return type shall be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_7Ck4LMQMeQCv",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.756,
          "reason": "Per FLS: 'The type of a return expression is the never type.' (similarity: 0.76)"
        },
        {
          "fls_id": "fls_njndlx2rps2k",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.726,
          "reason": "Per FLS: 'If the return expression has an operand, then the value is the valu...' (similarity: 0.73)"
        },
        {
          "fls_id": "fls_EqJb3Jl3vK8K",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.724,
          "reason": "Per FLS: 'The return type of a function is determined as follows:' (similarity: 0.72)"
        },
        {
          "fls_id": "fls_r610t5vsi7bx",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.703,
          "reason": "Per FLS: 'The value returned by a return expression is determined as follows:' (similarity: 0.70)"
        },
        {
          "fls_id": "fls_vljy4mm0zca2",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.702,
          "reason": "Per FLS: 'A return type is the type of the result a function, closure type or...' (similarity: 0.70)"
        },
        {
          "fls_id": "fls_4wDpAHhnWZAB",
          "category": -2,
          "fls_section": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "score": 0.682,
          "reason": "Per FLS: '[Call expression]s and [method call expression]s if the return type...' (similarity: 0.68)"
        },
        {
          "fls_id": "fls_C7dvzcXcpQCy",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.674,
          "reason": "Per FLS: 'If the FunctionDeclaration specifies a ReturnType, then the return ...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_8gpvNJfVlyaD",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.671,
          "reason": "Per FLS: 'If the function pointer type specifies a ReturnTypeWithoutBounds, t...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_5v3j5ghhw8j8",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.664,
          "reason": "Per FLS: 'A return expression shall appear within a control flow boundary.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_KcI6yK0P8Onn",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.658,
          "reason": "Per FLS: 'Otherwise the return type is the unit type.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_8l74abhlxzdl",
          "category": 0,
          "fls_section": "6.-2.51",
          "fls_title": "Return Expressions",
          "score": 0.607,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.503,
          "reason": "Section-level similarity match (score: 0.50)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 17.8",
      "guideline_title": "A function parameter should not be modified",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_1jnn9bsb71k7",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.586,
          "reason": "Per FLS: 'Any lifetime related to a function pointer type parameter.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_pjil71kk0r25",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.56,
          "reason": "Per FLS: 'Any lifetime related to a function parameter.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "category": -2,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.558,
          "reason": "Per FLS: 'A variadic part indicates the presence of C-like optional parameters.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.51,
          "reason": "Section-level similarity match (score: 0.51)"
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "category": 0,
          "fls_section": "15.-2.3",
          "fls_title": "References",
          "score": 0.509,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "this cannot be done accidentally without declaring parameters `mut`",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this cannot be done accidentally without declaring parameters `mut`"
    },
    {
      "guideline_id": "Rule 17.9",
      "guideline_title": "A function declared with a _Noreturn function specifier shall not return to its caller C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_4wDpAHhnWZAB",
          "category": -2,
          "fls_section": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "score": 0.638,
          "reason": "Per FLS: '[Call expression]s and [method call expression]s if the return type...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_yofbo96tjppf",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.62,
          "reason": "Per FLS: 'Any lifetime related to the return type of a function pointer type.' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_7Ck4LMQMeQCv",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.609,
          "reason": "Per FLS: 'The type of a return expression is the never type.' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.609,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.608,
          "reason": "Per FLS: 'It is a validity invariant for a value of a function pointer type t...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_ofqy10q4a9jk",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.603,
          "reason": "Per FLS: 'Any lifetime related to the return type of a function.' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.603,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is eithe...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_8l74abhlxzdl",
          "category": 0,
          "fls_section": "6.-2.51",
          "fls_title": "Return Expressions",
          "score": 0.59,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_o3fc1z2mn8zc",
          "category": -3,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.582,
          "reason": "Per FLS: 'The operand is evaluated. #.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.579,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_1jnn9bsb71k7",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.577,
          "reason": "Per FLS: 'Any lifetime related to a function pointer type parameter.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_d9avvfi548t7",
          "category": -3,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.576,
          "reason": "Per FLS: 'If the return expression has an operand, then #.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_5v3j5ghhw8j8",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.57,
          "reason": "Per FLS: 'A return expression shall appear within a control flow boundary.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.562,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.561,
          "reason": "Section-level similarity match (score: 0.56)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "this is expressed with the `!` (Never) type, and enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA ADD-6: this is expressed with the `!` (Never) type, and enforced by rustc. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 17.10",
      "guideline_title": "A function declared with a _Noreturn function specifier shall have void return type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust uses the never type (!) for diverging functions. A function returning ! can be assigned to any type variable since it never actually returns. Different design than C _Noreturn.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.11",
      "guideline_title": "A function that never returns should be declared with a _Noreturn function specifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_7Ck4LMQMeQCv",
          "category": -2,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.633,
          "reason": "Per FLS: 'The type of a return expression is the never type.' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_4wDpAHhnWZAB",
          "category": -2,
          "fls_section": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "score": 0.608,
          "reason": "Per FLS: '[Call expression]s and [method call expression]s if the return type...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_ofqy10q4a9jk",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.587,
          "reason": "Per FLS: 'Any lifetime related to the return type of a function.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_EqJb3Jl3vK8K",
          "category": -2,
          "fls_section": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "score": 0.558,
          "reason": "Per FLS: 'The return type of a function is determined as follows:' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_d9avvfi548t7",
          "category": -3,
          "fls_section": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "score": 0.555,
          "reason": "Per FLS: 'If the return expression has an operand, then #.' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_98lnexk53ru4",
          "category": 0,
          "fls_section": "4.-2.23",
          "fls_title": "Never Type",
          "score": 0.531,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "a non-returning function can be declared to return a value type",
      "confidence": "medium",
      "notes": "MISRA ADD-6: a non-returning function can be declared to return a value type"
    },
    {
      "guideline_id": "Rule 17.12",
      "guideline_title": "A function identifier should only be used with either a preceding &, or with a parenthesized parameter list",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust function items have unique zero-sized types. They coerce to function pointers when needed. There is no ambiguity between function and function-pointer that this C rule addresses.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.13",
      "guideline_title": "A function type shall not be type qualified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C type qualifiers (const, volatile) on function types are undefined behavior. Rust has no type qualifiers on function types - this concept does not exist.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.1",
      "guideline_title": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_aeh5pzpcjveq",
          "category": -2,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.657,
          "reason": "Per FLS: 'When the operand of a dereference expression is of a pointer type, ...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_6b4rwkrc1ap6",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.632,
          "reason": "Per FLS: 'A dereference expression whose operand's type is a mutable raw poin...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.611,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is eithe...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_t52in1kkyli3",
          "category": -3,
          "fls_section": "fls_xinykul167l",
          "fls_title": "Array Expressions",
          "score": 0.61,
          "reason": "Per FLS: 'The evaluation of an array expression with an array element constru...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_by21pey7k423",
          "category": -2,
          "fls_section": "fls_xinykul167l",
          "fls_title": "Array Expressions",
          "score": 0.609,
          "reason": "Per FLS: 'The [type]s of the [operand]s of an array element constructor shall...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.606,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_j6kffhbxdm7o",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.605,
          "reason": "Per FLS: 'The size operand of an array type,' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_f3izbkm8607z",
          "category": -3,
          "fls_section": "fls_xinykul167l",
          "fls_title": "Array Expressions",
          "score": 0.604,
          "reason": "Per FLS: 'If the value of the size operand is greater than zero, then the rep...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_imr2jx6cbuzq",
          "category": -2,
          "fls_section": "fls_uj0kpjwyld60",
          "fls_title": "Array Types",
          "score": 0.596,
          "reason": "Per FLS: 'The size operand shall be a constant expression or an inferred cons...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.594,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_f6wktzofzdn1",
          "category": -2,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.592,
          "reason": "Per FLS: 'A dereference expression is an expression that obtains the pointed-...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_A1NVYkepoaMk",
          "category": -2,
          "fls_section": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "score": 0.589,
          "reason": "Per FLS: 'The size operand of an array expression or an array type.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_6ydylimiv553",
          "category": 0,
          "fls_section": "6.-2.5",
          "fls_title": "Place Expressions",
          "score": 0.529,
          "reason": "Section-level similarity match (score: 0.53)"
        },
        {
          "fls_id": "fls_9beohh5475s2",
          "category": 0,
          "fls_section": "6.-2.27",
          "fls_title": "Destructuring Assignment",
          "score": 0.517,
          "reason": "Section-level similarity match (score: 0.52)"
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "6.-1.2",
          "fls_title": "Arithmetic Overflow",
          "score": 0.51,
          "reason": "Section-level similarity match (score: 0.51)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "medium",
      "notes": "MISRA ADD-6: by unsafe API. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.2",
      "guideline_title": "Subtraction between pointers shall only be applied to pointers that address elements of the same array C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_Vy0DyZqfy7Iv",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.664,
          "reason": "Per FLS: 'If the type of both [operand]s is the same integer type or floating...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_v8vekngd27sz",
          "category": -2,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.664,
          "reason": "Per FLS: 'The value of a subtraction expression is the result of core::ops::S...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_8j408kckzzud",
          "category": -3,
          "fls_section": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.62,
          "reason": "Per FLS: 'For a subtraction assignment, core::ops::SubAssign::sub_assign(&mut...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_bndpd66973ev",
          "category": -3,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.603,
          "reason": "Per FLS: 'The evaluation of a subtraction expression proceeds as follows: #.' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_aalxhbvu8kdi",
          "category": -2,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.6,
          "reason": "Per FLS: 'A subtraction expression is an arithmetic expression that uses subt...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_9x2i1zlsm364",
          "category": -2,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.597,
          "reason": "Per FLS: 'The type of a subtraction expression is associated type core::ops::...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_7l7v7vigw3fu",
          "category": -2,
          "fls_section": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.583,
          "reason": "Per FLS: 'A subtraction assignment expression is a compound assignment expres...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_fjcv1nm8tlgf",
          "category": -2,
          "fls_section": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.555,
          "reason": "Per FLS: 'The type of the left operand of a subtraction expression shall impl...' (similarity: 0.56)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.533,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "medium",
      "notes": "MISRA ADD-6: by unsafe API. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.3",
      "guideline_title": "The relational operators >, >=, < and <= shall not be applied to expressions of pointer type except where they point into the same object C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_hrum767l6dte",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.648,
          "reason": "Per FLS: 'Comparing two [value]s of [raw pointer type]s compares the addresse...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_emcNJzl2tHSA",
          "category": -2,
          "fls_section": "fls_wsfw8xF3vniL",
          "fls_title": "Structural Equality",
          "score": 0.625,
          "reason": "Per FLS: 'Bool, char, [function pointer type]s, [integer type]s, str, and [ra...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_nsvzzbldhq53",
          "category": 0,
          "fls_section": "6.-2.21",
          "fls_title": "Comparison Expressions",
          "score": 0.592,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_pso38dowbk91",
          "category": -2,
          "fls_section": "fls_nsvzzbldhq53",
          "fls_title": "Comparison Expressions",
          "score": 0.584,
          "reason": "Per FLS: 'The value of a greater-than expression is the result of core::cmp::...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_xmtxkit3qpw7",
          "category": -2,
          "fls_section": "fls_nsvzzbldhq53",
          "fls_title": "Comparison Expressions",
          "score": 0.582,
          "reason": "Per FLS: 'The value of a less-than expression is the result of core::cmp::Par...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_wytygse41vzm",
          "category": -2,
          "fls_section": "fls_nsvzzbldhq53",
          "fls_title": "Comparison Expressions",
          "score": 0.581,
          "reason": "Per FLS: 'The value of a greater-than-or-equals expression is the result of c...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_7pfsqby2saag",
          "category": -2,
          "fls_section": "fls_nsvzzbldhq53",
          "fls_title": "Comparison Expressions",
          "score": 0.578,
          "reason": "Per FLS: 'The value of a less-than-or-equals expression is the result of core...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_rfomib80bnn2",
          "category": -3,
          "fls_section": "fls_nsvzzbldhq53",
          "fls_title": "Comparison Expressions",
          "score": 0.578,
          "reason": "Per FLS: 'core::cmp::PartialOrd::lt(&left_operand, &right_operand) is invoked.' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_k6ues2936pjq",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.577,
          "reason": "Per FLS: 'Comparing a value of a raw pointer type to a value of a dynamically...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_t52in1kkyli3",
          "category": -3,
          "fls_section": "fls_xinykul167l",
          "fls_title": "Array Expressions",
          "score": 0.573,
          "reason": "Per FLS: 'The evaluation of an array expression with an array element constru...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.-2.1",
          "fls_title": "Values",
          "score": 0.573,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_6b4rwkrc1ap6",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.571,
          "reason": "Per FLS: 'A dereference expression whose operand's type is a mutable raw poin...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_ckvjj4tt1hh2",
          "category": 0,
          "fls_section": "6.-2.1",
          "fls_title": "Expressions",
          "score": 0.565,
          "reason": "Section-level similarity match (score: 0.56)"
        },
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.551,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_3ut3biyra4r9",
          "category": 0,
          "fls_section": "6.-2.2",
          "fls_title": "Assignee Expressions",
          "score": 0.55,
          "reason": "Section-level similarity match (score: 0.55)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 18.4",
      "guideline_title": "The +, -, += and -= operators should not be applied to an expression of pointer type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_aeh5pzpcjveq",
          "category": -2,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.567,
          "reason": "Per FLS: 'When the operand of a dereference expression is of a pointer type, ...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_hrum767l6dte",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.567,
          "reason": "Per FLS: 'Comparing two [value]s of [raw pointer type]s compares the addresse...' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.552,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_6ydylimiv553",
          "category": 0,
          "fls_section": "6.-2.5",
          "fls_title": "Place Expressions",
          "score": 0.522,
          "reason": "Section-level similarity match (score: 0.52)"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.-2.1",
          "fls_title": "Values",
          "score": 0.502,
          "reason": "Section-level similarity match (score: 0.50)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "applies to use of the unsafe API",
      "confidence": "medium",
      "notes": "MISRA ADD-6: applies to use of the unsafe API. Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.5",
      "guideline_title": "Declarations should contain no more than two levels of pointer nesting",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_wz2etmkpvxed",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.642,
          "reason": "Per FLS: 'A function pointer type is unifiable only with another function poi...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_ismr7wwvek4q",
          "category": -2,
          "fls_section": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.613,
          "reason": "Per FLS: 'A raw pointer type is unifiable only with another raw pointer type ...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_9k9hourczbv7",
          "category": -2,
          "fls_section": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "score": 0.594,
          "reason": "Per FLS: 'The type specification of a function pointer type introduces a gene...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_puly43s4x360",
          "category": -2,
          "fls_section": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "score": 0.59,
          "reason": "Per FLS: 'The declaration of a struct type introduces a generic parameter sco...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_5w9lj5dc84p",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.587,
          "reason": "Per FLS: 'The struct expression shall not contain a base initializer.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_6b4rwkrc1ap6",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.577,
          "reason": "Per FLS: 'A dereference expression whose operand's type is a mutable raw poin...' (similarity: 0.58)"
        },
        {
          "fls_id": "fls_rclgwzdhfjj",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.571,
          "reason": "Per FLS: 'Have exactly one base initializer.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_90q7krxazc6u",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.571,
          "reason": "Per FLS: 'Have exactly one base initializer.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.571,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_JBfZuFDQg3mU",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.57,
          "reason": "Per FLS: 'The base initializer of a struct expression.' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_9370n5xkkzce",
          "category": -2,
          "fls_section": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.569,
          "reason": "Per FLS: 'Contain at most one matched shorthand initializer, or' (similarity: 0.57)"
        },
        {
          "fls_id": "fls_lnpyb285qdiy",
          "category": 0,
          "fls_section": "14.-2.11",
          "fls_title": "Scope Hierarchy",
          "score": 0.567,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.55,
          "reason": "Section-level similarity match (score: 0.55)"
        },
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.535,
          "reason": "Section-level similarity match (score: 0.54)"
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "category": 0,
          "fls_section": "4.-2.27",
          "fls_title": "Type Representation",
          "score": 0.532,
          "reason": "Section-level similarity match (score: 0.53)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Similarity-based mapping - requires manual verification"
    },
    {
      "guideline_id": "Rule 18.6",
      "guideline_title": "The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_CUJyMj0Sj8NS",
          "category": -2,
          "fls_section": "fls_94a8v54bufn8",
          "fls_title": "Values",
          "score": 0.648,
          "reason": "Per FLS: 'An allocated object is a value stored at some memory address.' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "category": 0,
          "fls_section": "15.-2.3",
          "fls_title": "References",
          "score": 0.641,
          "reason": "Section-level similarity match (score: 0.64)"
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "category": 0,
          "fls_section": "15.-2.4",
          "fls_title": "Borrowing",
          "score": 0.628,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_kaomYy0Ml4Nh",
          "category": -2,
          "fls_section": "fls_94a8v54bufn8",
          "fls_title": "Values",
          "score": 0.607,
          "reason": "Per FLS: 'The base address of an allocated object is the memory address where...' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_6b4rwkrc1ap6",
          "category": -2,
          "fls_section": "fls_6ydylimiv553",
          "fls_title": "Place Expressions",
          "score": 0.601,
          "reason": "Per FLS: 'A dereference expression whose operand's type is a mutable raw poin...' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_1jnn9bsb71k7",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.598,
          "reason": "Per FLS: 'Any lifetime related to a function pointer type parameter.' (similarity: 0.60)"
        },
        {
          "fls_id": "fls_hrum767l6dte",
          "category": -2,
          "fls_section": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "score": 0.595,
          "reason": "Per FLS: 'Comparing two [value]s of [raw pointer type]s compares the addresse...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_jd1inwz7ulyw",
          "category": -2,
          "fls_section": "19.-2.4",
          "fls_title": "Unsafety",
          "score": 0.594,
          "reason": "Per FLS: 'Dereferencing a value of a raw pointer type.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_uhwpuv6cx4ip",
          "category": -4,
          "fls_section": "fls_94a8v54bufn8",
          "fls_title": "Values",
          "score": 0.593,
          "reason": "Per FLS: 'It is undefined behavior to create an allocated object with memory ...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_yofbo96tjppf",
          "category": -2,
          "fls_section": "fls_HEtHxXBcg7JA",
          "fls_title": "Function Lifetime Elision",
          "score": 0.593,
          "reason": "Per FLS: 'Any lifetime related to the return type of a function pointer type.' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_gOXUWePymgGV",
          "category": -2,
          "fls_section": "fls_vXGuvRWOLbEE",
          "fls_title": "Raw Borrow Expression",
          "score": 0.592,
          "reason": "Per FLS: 'When the operand of a raw borrow expression is a place expression, ...' (similarity: 0.59)"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.-2.1",
          "fls_title": "Values",
          "score": 0.588,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.-2.3",
          "fls_title": "Statics",
          "score": 0.583,
          "reason": "Section-level similarity match (score: 0.58)"
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.-2.1",
          "fls_title": "Unsafety",
          "score": 0.571,
          "reason": "Section-level similarity match (score: 0.57)"
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_section": "fls_5cm4gkt55hjh",
          "fls_title": "Dereference Expression",
          "score": 0.561,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is eithe...' (similarity: 0.56)"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Only applicable in unsafe Rust"
    },
    {
      "guideline_id": "Rule 18.7",
      "guideline_title": "Flexible array members shall not be declared",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C99 flexible array members (struct { int n; char data[]; }) have no Rust equivalent. Rust uses Vec<T> or slices for variable-length data, with proper bounds checking.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.8",
      "guideline_title": "Variable-length arrays shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no VLAs. Array sizes must be compile-time constants. For runtime-sized collections, use Vec<T> which allocates on the heap with proper bounds checking.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.9",
      "guideline_title": "An object with temporary lifetime shall not undergo array-to-pointer conversion",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C array-to-pointer decay does not exist in Rust. Rust arrays [T; N] do not implicitly convert to pointers. Taking a reference to a temporary is controlled by borrowing rules.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.10",
      "guideline_title": "Pointers to variably-modified array types shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no variably-modified array types (C99/C11 VLA feature). Array sizes are compile-time constants in Rust.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 19.1",
      "guideline_title": "An object shall not be assigned or copied to an overlapping object C90 [Undefined 34, 55], C99 [Undefined 51, 94], C11 [Undefined 54, 100]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Safe Rust's borrow checker prevents overlapping mutable references at compile time. FLS 15.3 explicitly states 'no other reference shall refer to a value that overlaps with the referent of the mutable reference'. In unsafe Rust, aliasing mutable references is explicitly UB.",
      "accepted_matches": [
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_section": "15.3",
          "fls_title": "References",
          "score": 0.526,
          "reason": "PRIMARY: Per FLS fls_i1ny0k726a4a: 'While a mutable reference is active, no other reference shall refer to a value that overlaps with the referent of the mutable reference.' Also defines UB: 'It is undefined behavior to access a value through aliasing mutable references from unsafe context.'",
          "category": -2
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_section": "15.4",
          "fls_title": "Borrowing",
          "score": 0.492,
          "reason": "Per FLS fls_kxws4zmaahj6: 'Borrowing a field of a union type borrows all remaining fields using the same lifetime.' This treats union fields as overlapping memory.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_94a8v54bufn8",
          "fls_section": "7",
          "fls_title": "Values",
          "score": 0.525,
          "reason": "Chapter-level section too broad. Contains value overlap definition but the enforceable rules are in 15.3 References.",
          "category": -2
        },
        {
          "fls_id": "fls_9beohh5475s2",
          "fls_section": "6.5.11.2",
          "fls_title": "Destructuring Assignment",
          "score": 0.519,
          "reason": "About tuple destructuring syntax, not memory overlap safety concerns.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 19.2",
      "guideline_title": "The union keyword should not be used C90 [Undefined 39, 40; Implementation G.3.9(1)] C99 [Unspecified 10; Undefined 61, 62] C11 [Unspecified 11; Undefined 64, 65]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "Rust unions exist but have strict type restrictions (Copy/ManuallyDrop field types only). Reading any union field requires unsafe context. FLS defines implementation-defined and UB scenarios similar to MISRA's concerns.",
      "accepted_matches": [
        {
          "fls_id": "fls_fmdn7n7s413d",
          "fls_section": "4.5.3",
          "fls_title": "Union Types",
          "score": 0.69,
          "reason": "PRIMARY: Defines union type rules including field type restrictions per FLS fls_ZJG2Q6lJYXhY: 'The type of a union field shall be either: A copy type, or a mutable reference type, or core::mem::ManuallyDrop...'",
          "category": -2
        },
        {
          "fls_id": "fls_cmq8ogs84ivh",
          "fls_section": "4.11.2.3",
          "fls_title": "Union Type Representation",
          "score": 0.691,
          "reason": "Defines union memory layout - size is max of all fields, all fields share common storage. Addresses MISRA's padding/alignment/endianness concerns.",
          "category": -2
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_section": "19",
          "fls_title": "Unsafety",
          "score": 0.0,
          "reason": "MANUAL: Per FLS fls_ucghxcnpaq2t: 'Accessing a field of a union, other than to assign to it' is listed as an unsafe operation requiring unsafe context.",
          "category": -2
        },
        {
          "fls_id": "fls_18k3uajrgq5f",
          "fls_section": "6.13",
          "fls_title": "Field Access Expressions",
          "score": 0.0,
          "reason": "MANUAL: Per FLS fls_kddnnz8uc15b: 'Reading the selected field of a union shall require unsafe context.' This is the enforcement mechanism for MISRA's concern.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "fls_section": "4.11.2.2",
          "fls_title": "Struct Type Representation",
          "score": 0.591,
          "reason": "About struct layout, not union - high similarity due to shared 'representation' terminology.",
          "category": -2
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_section": "4.11.1",
          "fls_title": "Type Layout",
          "score": 0.561,
          "reason": "General layout section. Union-specific content is in child section 4.11.2.3 which is more specific.",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.554,
          "reason": "Parent section. Child 4.11.2.3 (Union Type Representation) is more specific and already accepted.",
          "category": -2
        },
        {
          "fls_id": "fls_wrvjizrqf3po",
          "fls_section": "4.3.2",
          "fls_title": "Char Type",
          "score": 0.509,
          "reason": "About char type, not unions. High score likely due to type representation terminology overlap.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 19.3",
      "guideline_title": "A union member shall not be read unless it has been previously set C99 [Unspecified 10], C11 [Unspecified 11]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "FLS explicitly defines UB for reading union fields with invalid data (fls_Vani4665hiJY). Reading any union field requires unsafe context. Rust treats union field read-after-different-write as transmute, matching MISRA's type punning concern.",
      "accepted_matches": [
        {
          "fls_id": "fls_fmdn7n7s413d",
          "fls_section": "4.5.3",
          "fls_title": "Union Types",
          "score": 0.662,
          "reason": "PRIMARY: Defines union field type restrictions (Copy/ManuallyDrop) which limit what can be stored and safely reinterpreted.",
          "category": -2
        },
        {
          "fls_id": "fls_18k3uajrgq5f",
          "fls_section": "6.13",
          "fls_title": "Field Access Expressions",
          "score": 0.0,
          "reason": "MANUAL: CRITICAL - Contains the explicit UB definition per FLS fls_Vani4665hiJY: 'It is undefined behavior reading the selected field of a union type when it contains data that is invalid for the selected field's type.' Also defines transmute equivalence for union field access (fls_t6xmsm2nk1bc).",
          "category": -2
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_section": "19",
          "fls_title": "Unsafety",
          "score": 0.524,
          "reason": "Per FLS fls_ucghxcnpaq2t: Union field access (except assignment) is an unsafe operation. This forces explicit acknowledgment of the type punning risk.",
          "category": -2
        },
        {
          "fls_id": "fls_cmq8ogs84ivh",
          "fls_section": "4.11.2.3",
          "fls_title": "Union Type Representation",
          "score": 0.644,
          "reason": "Per FLS: 'All union fields share a common storage.' This is the memory model underlying MISRA's concern about reading unwritten members.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "fls_section": "4.11.2.2",
          "fls_title": "Struct Type Representation",
          "score": 0.587,
          "reason": "About struct layout, not union. High score due to shared 'representation' terminology.",
          "category": -2
        },
        {
          "fls_id": "fls_8tsynkj2cufj",
          "fls_section": "6.11",
          "fls_title": "Struct Expressions",
          "score": 0.529,
          "reason": "About struct initialization syntax, not union field access.",
          "category": -2
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_section": "15.3",
          "fls_title": "References",
          "score": 0.524,
          "reason": "About reference aliasing rules, not union type punning. More relevant to Rule 19.1.",
          "category": -2
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "fls_section": "15.5",
          "fls_title": "Passing Conventions",
          "score": 0.524,
          "reason": "About move/copy semantics during value transfer, not union field access.",
          "category": -2
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_section": "4.11.1",
          "fls_title": "Type Layout",
          "score": 0.541,
          "reason": "General layout section. Child section 4.11.2.3 is more specific for unions.",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.52,
          "reason": "Parent section. Child 4.11.2.3 already accepted and is more specific.",
          "category": -2
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "fls_section": "6.5.2",
          "fls_title": "Dereference Expression",
          "score": 0.516,
          "reason": "About pointer dereferencing, not union field access. Different unsafe operation.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 20.1",
      "guideline_title": "#include directives should only be preceded by preprocessor directives or comments",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "rules specific to the C preprocessor do not apply to Rust",
      "confidence": "high",
      "notes": "Rust has no #include. The mod/use system handles module imports with well-defined semantics independent of textual position.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.2",
      "guideline_title": "The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #include or header files. Module paths use :: separators and follow Rust identifier rules.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.3",
      "guideline_title": "The #include directive shall be followed by either a <filename> or \"filename\" sequence",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #include directive. Module inclusion uses mod declarations with strict syntax.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 20.4",
      "guideline_title": "A macro shall not be defined with the same name as a keyword C90",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_jejt5z8m1yew",
          "category": -2,
          "fls_section": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "score": 0.661,
          "reason": "Per FLS: '[Declarative macro]s and [procedural macro]s shall receive normaliz...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_nz5stwcc41gk",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.648,
          "reason": "Per FLS: 'Macro expansion of [declarative macro]s proceeds as follows: #.' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_g93r3teei8wo",
          "category": -2,
          "fls_section": "fls_8nzypdu9j3ge",
          "fls_title": "Metavariables",
          "score": 0.64,
          "reason": "Per FLS: '[Declarative macro]s employ [metavariable]s to match a token of a p...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_76prdp6k1fga",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.64,
          "reason": "Per FLS: 'The TokenTree of the macro invocation is matched against the [macro...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_xa7lp0zg1ol2",
          "category": 0,
          "fls_section": "20.-2.2",
          "fls_title": "Declarative Macros",
          "score": 0.635,
          "reason": "Section-level similarity match (score: 0.63)"
        },
        {
          "fls_id": "fls_y4podc7ee8lf",
          "category": -2,
          "fls_section": "fls_ym00b6ewf4n3",
          "fls_title": "Macro Transcription",
          "score": 0.629,
          "reason": "Per FLS: 'A metavariable indication shall be used in a macro repetition in tr...' (similarity: 0.63)"
        },
        {
          "fls_id": "fls_rnty1c8l5495",
          "category": -2,
          "fls_section": "fls_83182bfa9uqb",
          "fls_title": "Macros",
          "score": 0.624,
          "reason": "Per FLS: '[Token]s are a subset of [lexical element]s consumed by [macro]s.' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_8nzypdu9j3ge",
          "category": 0,
          "fls_section": "20.-2.3",
          "fls_title": "Metavariables",
          "score": 0.624,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_bl55g03jmayf",
          "category": -2,
          "fls_section": "fls_9kjpxri0axvg",
          "fls_title": "Weak Keywords",
          "score": 0.623,
          "reason": "Per FLS: 'Word macro_rules acts as a keyword only when used in the context of...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_mewfehvgm16r",
          "category": -2,
          "fls_section": "fls_wn1i6hzg2ff7",
          "fls_title": "Procedural Macros",
          "score": 0.617,
          "reason": "Per FLS: 'A macro implementation function enters the name of the procedural m...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_w44hav7mw3ao",
          "category": -2,
          "fls_section": "fls_xa7lp0zg1ol2",
          "fls_title": "Declarative Macros",
          "score": 0.616,
          "reason": "Per FLS: 'A declarative macro is a macro that associates a name with a set of...' (similarity: 0.62)"
        },
        {
          "fls_id": "fls_ofzql79i9if",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.615,
          "reason": "Per FLS: 'It shall lack [function qualifier]s,' (similarity: 0.61)"
        },
        {
          "fls_id": "fls_wjldgtio5o75",
          "category": 0,
          "fls_section": "20.-2.10",
          "fls_title": "Macro Expansion",
          "score": 0.613,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_ym00b6ewf4n3",
          "category": 0,
          "fls_section": "20.-2.14",
          "fls_title": "Macro Transcription",
          "score": 0.59,
          "reason": "Section-level similarity match (score: 0.59)"
        },
        {
          "fls_id": "fls_xlfo7di0gsqz",
          "category": 0,
          "fls_section": "20.-1.1",
          "fls_title": "Hygiene",
          "score": 0.574,
          "reason": "Section-level similarity match (score: 0.57)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "possible with raw identifiers but the compiler prevents visual conflicts",
      "confidence": "medium",
      "notes": "MISRA ADD-6: possible with raw identifiers but the compiler prevents visual conflicts"
    },
    {
      "guideline_id": "Rule 20.5",
      "guideline_title": "#undef should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #undef. Rust macros use hygienic scoping and cannot be undefined after declaration.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.6",
      "guideline_title": "Tokens that look like a preprocessing directive shall not occur within a macro argument",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust macros operate on token trees, not text. There are no preprocessing directives within macro arguments - the concept does not apply.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.7",
      "guideline_title": "Expressions resulting from the expansion of macro parameters shall be appropriately delimited",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_wjldgtio5o75",
          "category": 0,
          "fls_section": "20.-2.10",
          "fls_title": "Macro Expansion",
          "score": 0.733,
          "reason": "Section-level similarity match (score: 0.73)"
        },
        {
          "fls_id": "fls_tjn92evtlflq",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.704,
          "reason": "Per FLS: 'The DelimitedTokenTree of the invoking attribute macro is transform...' (similarity: 0.70)"
        },
        {
          "fls_id": "fls_fbgal48cgj44",
          "category": -2,
          "fls_section": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "score": 0.67,
          "reason": "Per FLS: 'The sole parameter of the macro implementation function captures th...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_g1rml9tavh8v",
          "category": -2,
          "fls_section": "fls_qpx6lgapce57",
          "fls_title": "Token Matching",
          "score": 0.666,
          "reason": "Per FLS: 'The outer [Delimiter]s of a macro matcher match any outer [Delimite...' (similarity: 0.67)"
        },
        {
          "fls_id": "fls_nz5stwcc41gk",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.66,
          "reason": "Per FLS: 'Macro expansion of [declarative macro]s proceeds as follows: #.' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_nsh2vwx8oiw",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.659,
          "reason": "Per FLS: 'If the macro invocation appears as part of an expression-without-bl...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_l8j2jiuuao4f",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.659,
          "reason": "Per FLS: 'If the macro invocation appears as part of an expression-without-bl...' (similarity: 0.66)"
        },
        {
          "fls_id": "fls_ym00b6ewf4n3",
          "category": 0,
          "fls_section": "20.-2.14",
          "fls_title": "Macro Transcription",
          "score": 0.655,
          "reason": "Section-level similarity match (score: 0.66)"
        },
        {
          "fls_id": "fls_3zn4dz19nyvq",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.654,
          "reason": "Per FLS: 'If the macro invocation appears as part of a statement, the output ...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_stseor6tln22",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.654,
          "reason": "Per FLS: 'If the macro invocation appears as part of a statement, the output ...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_fku5beu3mr4c",
          "category": -2,
          "fls_section": "fls_4vjbkm4ceymk",
          "fls_title": "Attribute Macros",
          "score": 0.649,
          "reason": "Per FLS: 'The first function parameter of the macro implementation function c...' (similarity: 0.65)"
        },
        {
          "fls_id": "fls_40xq8Ri1OMZZ",
          "category": -2,
          "fls_section": "fls_wjldgtio5o75",
          "fls_title": "Macro Expansion",
          "score": 0.641,
          "reason": "Per FLS: 'The TokenTree of the macro invocation has all [outer block doc]s an...' (similarity: 0.64)"
        },
        {
          "fls_id": "fls_8nzypdu9j3ge",
          "category": 0,
          "fls_section": "20.-2.3",
          "fls_title": "Metavariables",
          "score": 0.618,
          "reason": "Section-level similarity match (score: 0.62)"
        },
        {
          "fls_id": "fls_4vjbkm4ceymk",
          "category": 0,
          "fls_section": "20.-2.8",
          "fls_title": "Attribute Macros",
          "score": 0.611,
          "reason": "Section-level similarity match (score: 0.61)"
        },
        {
          "fls_id": "fls_kw25194gpael",
          "category": 0,
          "fls_section": "6.-2.53",
          "fls_title": "Expression Precedence",
          "score": 0.603,
          "reason": "Section-level similarity match (score: 0.60)"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "possible to express with procedural macros only, not macro_rules",
      "confidence": "medium",
      "notes": "MISRA ADD-6: possible to express with procedural macros only, not macro_rules"
    },
    {
      "guideline_id": "Rule 20.8",
      "guideline_title": "The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust uses cfg attributes and cfg! macro for conditional compilation. These use predicate syntax (cfg(feature = \"x\")), not integer expressions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.9",
      "guideline_title": "All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be defined before evaluation",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust cfg attributes check for presence/absence of configuration options. There is no integer expression evaluation with potentially undefined identifiers.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.10",
      "guideline_title": "The # and ## preprocessor operators should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no # or ## stringizing/token-pasting operators. Rust macros use different mechanisms (stringify!, concat!) that are type-safe.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.11",
      "guideline_title": "A macro parameter immediately following a # operator shall not immediately be followed by a ## operator",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no # or ## operators. Macro hygiene and token tree manipulation in Rust avoid these C preprocessor pitfalls.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.12",
      "guideline_title": "A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no # or ## operators. Rust macro expansion has well-defined ordering without these C preprocessor complexities.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.13",
      "guideline_title": "A line whose first token is # shall be a valid preprocessing directive",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C-style preprocessing directives. # in Rust is used for attributes (#[...]) which have strict syntax requirements enforced by the compiler.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.14",
      "guideline_title": "All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #if/#else/#endif. The cfg attribute system applies to complete syntactic items and cannot span files.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.15",
      "guideline_title": "#define and #undef shall not be used on a reserved identifier or reserved macro name",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "previously Rule 21.1",
      "confidence": "high",
      "notes": "Rust has no #define/#undef. Rust macros (macro_rules! and proc macros) operate in a hygienic namespace system with different reserved identifier rules."
    },
    {
      "guideline_id": "Rule 21.3",
      "guideline_title": "The memory allocation and deallocation functions of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_fs0lcfllamj",
          "category": 0,
          "fls_title": "Attribute global_allocator",
          "score": 0.58,
          "reason": "Per FLS fls_5b8aewlgeon8: 'Attribute global_allocator shall apply to [static]s whose [type]s implement the core::alloc::GlobalAlloc trait.' This is Rust's mechanism for custom memory allocation."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_title": "Dereference Expression (UB)",
          "score": 0.63,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' This directly addresses MISRA's concern about using freed memory."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "category": 0,
          "fls_title": "Destructors",
          "score": 0.72,
          "reason": "Per FLS fls_wzuwapjqtyyy: 'Dropping a value is the act of invoking the destructor of the related type.' Rust's RAII through Drop handles deallocation automatically for safe types."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA ADD-6 notes this is only accessible through unsafe extern 'C'. In Rust, memory allocation uses Box/Vec with RAII, or the global allocator interface. When calling C's malloc/free via FFI, these sections apply.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.4",
      "guideline_title": "The standard header file <setjmp.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "setjmp/longjmp have no Rust equivalent. Rust uses Result/Option for error handling and panic for unwinding. This rule applies only when calling C code via FFI that uses setjmp/longjmp.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.5",
      "guideline_title": "The standard header file <signal.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C signal handling has no Rust equivalent. Rust does not have a standard signal handling mechanism. This rule applies only when calling C code via FFI that uses signal.h.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 21.6",
      "guideline_title": "The Standard Library input/output functions shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.4",
          "fls_title": "ABI",
          "score": 0.65,
          "reason": "C library functions require ABI specification. Standard Library input/output functions only accessible in Rust through unsafe extern 'C' blocks."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.55,
          "reason": "C library function declarations would appear in unsafe external blocks, requiring unsafe context to call."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA prohibits C stdio functions. In Rust, C stdio is only accessible via unsafe extern 'C'. Rust has std::io for safe I/O. Per ADD-6: 'only accessible through unsafe extern \"C\"'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.7",
      "guideline_title": "The Standard Library functions atof, atoi, atol and atoll of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.4",
          "fls_title": "ABI",
          "score": 0.65,
          "reason": "C library functions require ABI specification. atof, atoi, atol, atoll functions only accessible in Rust through unsafe extern 'C' blocks."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.55,
          "reason": "C library function declarations would appear in unsafe external blocks, requiring unsafe context to call."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA prohibits these due to undefined behavior on invalid input. In Rust, use str::parse() which returns Result for safe error handling. C functions only via unsafe extern 'C'. Per ADD-6: 'only accessible through unsafe extern \"C\"'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.8",
      "guideline_title": "The Standard Library termination functions of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_k44b6atjwy89",
          "category": 0,
          "fls_title": "Panic",
          "score": 0.55,
          "reason": "Rust's panic!() macro provides controlled abnormal termination with unwinding. Per FLS, a panic causes the current thread to unwind or abort."
        },
        {
          "fls_id": "fls_hi1iz0gbnksi",
          "category": 0,
          "fls_title": "Abort",
          "score": 0.72,
          "reason": "Per FLS fls_9a1izu3omkbn: 'Abort is the immediate termination of a program.' Per FLS fls_wd2q6ft9yzrg: 'Control flow halts the execution of all threads.' This directly corresponds to C's abort() function."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C termination functions (abort, exit, _Exit, quick_exit) map to Rust's abort/panic. Rust uses std::process::abort() and panic!() for abnormal termination.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.9",
      "guideline_title": "The Standard Library functions bsearch and qsort of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's bsearch/qsort use function pointers which can be unsafe. Rust provides safe alternatives via slice::binary_search() and slice::sort() which are type-safe and don't require unsafe function pointers.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.10",
      "guideline_title": "The Standard Library time and date functions shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C time/date functions have no standard Rust equivalent. Rust uses chrono or std::time for time handling which are type-safe. This applies only when using C time functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 21.11",
      "guideline_title": "The standard header file <tgmath.h> should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "high",
      "notes": "Rust has no <tgmath.h>. Type-generic math in Rust is achieved through traits (e.g., num-traits crate) and generic functions, with compile-time type safety."
    },
    {
      "guideline_id": "Rule 21.12",
      "guideline_title": "The standard header file <fenv.h> shall not be used C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C floating-point environment (fenv.h) has no Rust equivalent. Rust does not expose floating-point exception flags or rounding mode control. This applies only when calling C code via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.13",
      "guideline_title": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's ctype.h functions accept int but expect unsigned char range. Rust's char methods (is_alphabetic, is_digit, etc.) work on Unicode chars and are type-safe. This applies only when calling C ctype.h via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.14",
      "guideline_title": "The Standard Library function memcmp shall not be used to compare null terminated strings",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's memcmp can expose padding bytes. Rust's PartialEq/Eq traits provide safe comparisons. For byte-level comparison, Rust slices can be compared directly. This applies only when calling C memcmp via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.15",
      "guideline_title": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's memcpy/memmove/memcmp use void* which loses type information. Rust's slice::copy_from_slice and Clone are type-safe. This applies only when calling C memory functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.16",
      "guideline_title": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's memcmp with pointers to different types is problematic. Rust's comparison traits are type-safe. This applies only when calling C memcmp via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.17",
      "guideline_title": "Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.4",
          "fls_title": "ABI",
          "score": 0.65,
          "reason": "C library functions require ABI specification. string.h buffer overflows only accessible in Rust through unsafe extern 'C' blocks."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.55,
          "reason": "C library function declarations would appear in unsafe external blocks, requiring unsafe context to call."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA prevents buffer overflows in string functions. Rust's String/&str are safe by design. C string functions only via unsafe extern 'C'. Use std::ffi::CStr/CString for FFI. Per ADD-6: 'only accessible through unsafe extern \"C\"'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.18",
      "guideline_title": "The size_t argument passed to any function in <string.h> shall have an appropriate value C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's string.h functions with size_t can have buffer overflow issues. Rust slices carry their length and prevent out-of-bounds access. This applies only when calling C string functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.19",
      "guideline_title": "The pointers returned by the Standard Library functions localeconv, getenv, setlocale or strerror shall only be used as if they have pointer to const-qualified type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's localeconv/getenv/setlocale return pointers that can be invalidated. Rust's std::env functions return owned Strings. This applies only when calling C locale functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.20",
      "guideline_title": "The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's strtok uses internal static state which is not thread-safe. Rust has no equivalent; String::split returns an iterator. This applies only when calling C strtok via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.21",
      "guideline_title": "The Standard Library function system of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's system() spawns a shell which is a security risk. Rust's std::process::Command allows explicit command execution without shell. This applies only when calling C system() via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.22",
      "guideline_title": "All operand arguments to any type-generic macros declared in <tgmath.h> shall have an appropriate essential type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "high",
      "notes": "Rust has no <tgmath.h> type-generic macros. Rust generics and traits provide type-safe polymorphism with compile-time checking.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.23",
      "guideline_title": "All operand arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "high",
      "notes": "Rust has no <tgmath.h>. Generic functions in Rust have explicit type constraints that the compiler enforces.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.24",
      "guideline_title": "The random number generator functions of <stdlib.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's rand/srand are not cryptographically secure and use global state. Rust's rand crate provides thread-safe, seedable RNGs. This applies only when calling C random functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 21.25",
      "guideline_title": "All memory synchronization operations shall be executed in sequentially consistent order C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.61,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' This directly addresses MISRA's memory synchronization concerns."
        },
        {
          "fls_id": "fls_isypweqewe78",
          "category": -4,
          "fls_title": "Concurrency (UB)",
          "score": 0.45,
          "reason": "Per FLS: 'It is undefined behavior if two or more threads engage in a data race.' Rust's atomics prevent data races when used correctly."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Memory synchronization operations in C11 map to Rust's atomics. Rust's core::sync::atomic provides atomic types with ordering guarantees.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.26",
      "guideline_title": "The Standard Library function mtx_timedlock() shall only be invoked on mutex objects of appropriate mutex type C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11's mtx_timedlock() has no standard Rust equivalent. Rust's std::sync::Mutex doesn't support timed locking. parking_lot crate provides timed locking. This applies only when calling C mtx_timedlock via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.1",
      "guideline_title": "All resources obtained dynamically by means of Standard Library functions shall be explicitly released",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to resources acquired through FFI only",
      "confidence": "high",
      "notes": "Resource release maps directly to Rust's RAII/Drop semantics. In safe Rust, resources are automatically released when values go out of scope. When using C resources via FFI, manual management in unsafe code is required.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_4jiw35pan7vn",
          "category": 0,
          "fls_title": "Destruction",
          "score": 0.7,
          "reason": "Per FLS fls_e7ucq87s806d: 'Destruction is the process of recovering resources associated with a value as it goes out of scope.' This is Rust's RAII mechanism."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "category": 0,
          "fls_title": "Destructors",
          "score": 0.72,
          "reason": "Per FLS fls_wzuwapjqtyyy: 'Dropping a value is the act of invoking the destructor of the related type.' The Drop trait ensures resources are released."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "category": 0,
          "fls_title": "Drop Scopes",
          "score": 0.65,
          "reason": "Per FLS fls_7uav7vkcv4pz: 'A drop scope is a region of program text that governs the dropping of [value]s.' Drop scopes ensure deterministic resource cleanup."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "guideline_id": "Rule 22.2",
      "guideline_title": "A block of memory shall only be freed if it was allocated by means of a Standard Library function C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_svkx6szhr472",
          "category": 0,
          "fls_title": "Ownership",
          "score": 0.7,
          "reason": "Per FLS fls_ze0u9gfylmhn: 'A value shall have only one owner.' This prevents double-free by ensuring single ownership."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_title": "Dereference Expression (UB)",
          "score": 0.63,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' Dereferencing freed memory is UB."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "Double-free prevention maps to Rust's ownership model. In safe Rust, each value has exactly one owner and is dropped exactly once. When using C memory via FFI, this rule applies to raw pointer management.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.3",
      "guideline_title": "The same file shall not be open for read and write access at the same time on different streams C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* simultaneous read/write streams have no Rust equivalent. Rust's std::fs::File uses separate read/write handles. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.4",
      "guideline_title": "There shall be no attempt to write to a stream which has been opened as read-only",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* read-only stream handling has no Rust equivalent. Rust's type system enforces read vs write at compile time. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.5",
      "guideline_title": "A pointer to a FILE object shall not be dereferenced",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* is an opaque type that should not be dereferenced. Rust has no equivalent; File handles are opaque. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.6",
      "guideline_title": "The value of a pointer to a FILE shall not be used after the associated stream has been closed C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* pointer becomes invalid after fclose. Rust's ownership prevents use-after-close. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.7",
      "guideline_title": "The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's EOF macro has no Rust equivalent. Rust uses Result/Option for error/end-of-file. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.8",
      "guideline_title": "The value of errno shall be set to zero prior to a call to an errno- setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's errno has no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 22.9",
      "guideline_title": "The value of errno shall be tested against zero after calling an errno- setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's errno checking has no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 22.10",
      "guideline_title": "The value of errno shall only be tested when the last function to be called was an errno-setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's errno value semantics have no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 22.11",
      "guideline_title": "A thread that was previously either joined or detached shall not be subsequently joined nor detached C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 thread join/detach semantics have no direct FLS equivalent. Rust's std::thread::JoinHandle ensures threads are joined. This applies only when calling C11 thread functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.12",
      "guideline_title": "Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.55,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' This enforces safe cross-thread value transfer."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11 thread object copying maps to Rust's Send/Sync traits. Rust's type system enforces thread-safety at compile time.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.13",
      "guideline_title": "Thread objects, thread synchronization objects and thread-specific storage pointers shall have appropriate storage duration C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "category": 0,
          "fls_title": "Drop Scopes",
          "score": 0.65,
          "reason": "Per FLS fls_7uav7vkcv4pz: 'A drop scope is a region of program text that governs the dropping of [value]s.' This ensures deterministic cleanup of thread objects."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 thread object destruction maps to Rust's Drop semantics. Rust's RAII ensures thread handles are properly cleaned up.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.14",
      "guideline_title": "Thread synchronization objects shall be initialized before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to creating synchronization objects before threads that use them",
      "confidence": "high",
      "notes": "C11 thread synchronization object initialization has no direct FLS equivalent. Rust's Mutex/RwLock constructors ensure proper initialization. This applies only when using C11 sync primitives via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.15",
      "guideline_title": "Thread synchronization objects and thread-specific storage pointers shall not be destroyed until after all threads accessing them have terminated C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.55,
          "reason": "Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.'"
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to releasing synchronization objects after threads that use them",
      "confidence": "high",
      "notes": "C11 thread-specific storage copying maps to Rust's Send/Sync traits. Rust enforces thread-safety at compile time.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.16",
      "guideline_title": "All mutex objects locked by a thread shall be explicitly unlocked by the same thread C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11 mutex unlock requirements have no direct FLS equivalent. Rust's MutexGuard uses RAII to ensure unlock on drop. This applies only when using C11 mutexes via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.17",
      "guideline_title": "No thread shall unlock a mutex or call cnd_wait() or cnd_timedwait() for a mutex it has not locked before C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11 mutex ownership for unlock/cnd_wait has no direct FLS equivalent. Rust's MutexGuard enforces ownership. This applies only when using C11 mutexes via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.18",
      "guideline_title": "Non-recursive mutexes shall not be recursively locked C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 non-recursive mutex rules have no direct FLS equivalent. Rust's Mutex is non-recursive by default and panics on relock. This applies only when using C11 mutexes via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.19",
      "guideline_title": "A condition variable shall be associated with at most one mutex object",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 condition variable association rules have no direct FLS equivalent. Rust's Condvar doesn't have this restriction. This applies only when using C11 condition variables via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.20",
      "guideline_title": "Thread-specific storage pointers shall be created before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 thread-specific storage creation timing has no direct FLS equivalent. Rust's thread_local! macro handles this at compile time. This applies only when using C11 TLS via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.1",
      "guideline_title": "A generic selection should only be expanded from a macro",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic selection. Compile-time type dispatch in Rust uses trait methods, which are always type-safe and work with generics naturally.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.2",
      "guideline_title": "A generic selection that is not expanded from a macro shall not contain potentially evaluated expressions in its association list",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic selection. Rust trait-based dispatch does not have association lists with potentially unevaluated expressions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.3",
      "guideline_title": "A generic selection should contain at least one non-default association",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic selection with default associations. Rust match expressions require exhaustive patterns.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.4",
      "guideline_title": "A generic association shall list an appropriate type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic associations. Trait implementations specify concrete types that must be valid.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.5",
      "guideline_title": "A generic selection should not depend on implicit pointer type conversion",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic. Rust does not have implicit pointer conversions - all conversions must be explicit (via as or From/Into).",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.6",
      "guideline_title": "The controlling expression of a generic selection shall have an essential type that matches one of the selections",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic. Trait method dispatch in Rust is resolved at compile time with strict type matching.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.7",
      "guideline_title": "A generic selection that is expanded from a macro should evaluate its argument only once",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic. Rust macro hygiene and the borrow checker prevent multiple evaluation issues naturally.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.8",
      "guideline_title": "A default association shall appear as either the first or the last association of a generic selection",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic associations. Match arm ordering in Rust is handled by the compiler with unreachable pattern warnings.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    }
  ]
}