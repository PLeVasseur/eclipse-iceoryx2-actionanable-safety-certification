# FLS Mapping Review: MISRA-C

Generated: 2025-12-31
Total guidelines: 212

---

## Dir 1.1

**Type:** directive
**Title:** Any implementation-defined behaviour on which the output of the

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust prevents undefined behavior; unsafe requires careful handling; Rust uses std::io and std::fs; different API design

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |
| `fls_85vx1qfa061i` | 4.13 | Traits |
| `fls_4ikc07mfrez5` | 4.13.1 | Object Safety |
| `fls_jeoas4n6su4` | 4.14 | Trait and Lifetime Bounds |
| `fls_1ompd93w7c9f` | 4.8 | Trait Types |
| `fls_3xqobbu7wfsf` | 4.8.1 | Impl Trait Types |
| `fls_qa98qdi42orq` | 4.8.2 | Trait Object Types |

**FLS Sections:** 19, 19.-2.1, 19.-2.2, 19.-2.3, 4.13, 4.13.1, 4.14, 4.8, 4.8.1, 4.8.2

### FLS Content

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

#### `fls_85vx1qfa061i`: Traits

_File: types-and-traits.rst, Line: 2705_

**Legality Rules:**

- A trait is an item that describes an interface a type can implement.
- A trait body is a construct that encapsulates the associated items, inner attributes, and inner doc comments of a trait.
- Within a trait, the type :c:`Self` acts as a placeholder for a type implementing the trait, and behaves like a type parameter.
- A local trait is a trait that is defined in the current crate.
- A subtrait is a trait with a supertrait.
- _... and 9 more paragraphs_

**Examples:**

- Shape is a supertrait of Circle.
- Circle is a subtrait of Shape.

#### `fls_4ikc07mfrez5`: Object Safety

_File: types-and-traits.rst, Line: 2829_

**Legality Rules:**

- A trait is object safe when:
- An associated function is object safe when it is either an object safe dispatchable function or an object safe non-dispatchable function.
- A dispatchable function is object safe when:
- A function is object safe when it specifies a core::marker::Sized [trait bound] for :c:`Self` in a type bound predicate.

#### `fls_jeoas4n6su4`: Trait and Lifetime Bounds

_File: types-and-traits.rst, Line: 2882_

**Legality Rules:**

- A bound imposes a constraint on a generic parameter by limiting the set of possible generic substitutions.
- A bound does not impose a constraint on a generic parameter of a type alias unless it is an associated item.
- A lifetime bound is a bound that imposes a constraint on the lifetimes of generic parameters.
- A trait bound is a bound that imposes a constraint on the traits of generic parameters.
- A ForGenericParameterList shall not specify ConstantParameters or TypeParameters.
- _... and 10 more paragraphs_

#### `fls_1ompd93w7c9f`: Trait Types

_File: types-and-traits.rst, Line: 1103_

#### `fls_3xqobbu7wfsf`: Impl Trait Types

_File: types-and-traits.rst, Line: 1108_

**Legality Rules:**

- An impl trait type is a type that implements a trait, where the type is known at compile time.
- An impl trait type shall appear only within a function parameter or the return type of a function.
- An anonymous return type is an impl trait type ascribed to a function return type.
- An anonymous return type behaves as if it contained all declared type parameters of the return type's function and its parent trait or implementation.
- An anonymous return type derived from an async function behaves as if it contained all declared type parameters and lifetime parameters of the return type's function and its parent trait or implementation.
- _... and 4 more paragraphs_

#### `fls_qa98qdi42orq`: Trait Object Types

_File: types-and-traits.rst, Line: 1179_

**Legality Rules:**

- A trait object type is a type that implements a trait, where the type is not known at compile time.
- The principal trait of trait object type is the first trait bound.
- The principal trait shall denote an object safe trait.
- All non-principal trait trait bounds shall denote auto traits.
- A trait object type shall not contain opt-out trait bounds.
- _... and 2 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 1.2

**Type:** directive
**Title:** The use of language extensions should be minimized

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| misra_rust_comment | previously Rule 1.2 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: previously Rule 1.2. Rust module system replaces header files

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_maw4u1o8q37u` | 18.3 | Crates |
| `fls_gklst7joeo33` | 18.4 | Crate Imports |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |

**FLS Sections:** 18, 18.1, 18.2

### FLS Content

#### `fls_maw4u1o8q37u`: Crates

_File: program-structure-and-compilation.rst, Line: 107_

**Legality Rules:**

- A crate is a unit of compilation and linking that contains a tree of nested modules.
- The crate type of a crate is the value of the attribute ``crate_type`` of a crate or the value of ``--crate-type`` flag passed to the tool compiling the crate.
- The crate type of a crate if not specified is ``bin``.
- A crate may be subject to multiple crate types, treating each type as a separate crate.
- A binary crate is a crate whose crate type is ``bin``.
- _... and 6 more paragraphs_

#### `fls_gklst7joeo33`: Crate Imports

_File: program-structure-and-compilation.rst, Line: 158_

**Legality Rules:**

- A crate import specifies a required dependency on an external crate.
- A crate indication is a construct that indicates a crate.
- A crate import binds an external crate to its crate indication.
- Crate indication ``self`` shall require a renaming.
- A crate import with a renaming with an identifier binds the external crate to a local name and introduces the local name into the enclosing scope.
- _... and 2 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_s35hob3i7lr` → 18.1 Source Files
- `fls_e9hwvqsib5d5` → 18.2 Modules
- `fls_5w50kf83oo1u` → 18.5 Compilation Roots
- `fls_u1afezy1ye99` → 18.6 Conditional Compilation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 2.1

**Type:** directive
**Title:** All source files shall compile without any compilation errors

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust uses Result<T, E> type instead of errno; Rust uses std::io and std::fs; different API design

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |

**FLS Sections:** 16, 16.1, 16.2, 6.5.3

### FLS Content

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 3.1

**Type:** directive
**Title:** All code shall be traceable to documented requirements

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 17, 17.1, 17.2

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.1

**Type:** directive
**Title:** Run-time failures shall be minimized

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| misra_rust_comment | often in the form of panics |
| confidence | `N/A` |

**Notes:** MISRA ADD-6: often in the form of panics

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.2

**Type:** directive
**Title:** All usage of assembly language should be documented

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust has asm! macro for inline assembly; always requires unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_a3joqzqp1v9d` | 22.5 | ABI Clobbers |
| `fls_e0896uk0mdyl` | 22.4 | Assembly Instructions |
| `fls_lv19xysy1f7e` | 22.4.1 | Register Parameter Modifiers |

**FLS Sections:** 22, 22.1, 22.2

### FLS Content

#### `fls_a3joqzqp1v9d`: ABI Clobbers

_File: inline-assembly.rst, Line: 1383_

**Legality Rules:**

- An ABI clobber is an argument to macro core::arch::asm which indicates that the values of selected registers might be overwritten during the execution of an assembly code block.
- Multiple ABI clobbers may be specified for an assembly code block. Clobber constraints are applied for all unique registers in the union of all specified ABIs.
- The effects of an ABI clobber depend on the ABI in effect, as follows:
- On x86 architectures, the x87 floating-point register stack shall remain unchanged unless all ``st(``\ [``0``-``7``]\ ``)`` registers have been clobbered.
- On x86 architectures, if all x87 registers are clobbered, then the x87 register stack is presumed empty upon entry of an assembly code block. The x87 register stack shall be empty on exit from an assembly code block.

#### `fls_e0896uk0mdyl`: Assembly Instructions

_File: inline-assembly.rst, Line: 958_

**Legality Rules:**

- An assembly instruction is a string literal that represents a low-level assembly operation or an assembly directive.
- An assembly instruction shall use the syntax of format strings as defined in module std::fmt, and contain zero or more register parameters.
- An assembly code block is a sequence of assembly instructions.
- When an assembly code block contains multiple assembly instructions, the assembly instructions are treated as concatenated into a single string literal, with character 0x0A (new line) between them.
- The set of memory locations that an assembly code block is allowed to read and write are the same as those for an external function, excluding the memory locations that are private to the assembly code block.
- _... and 4 more paragraphs_

**Undefined Behavior:**

- On x86 architectures, it is undefined behavior if direction flag ``DF`` in register ``EFLAGS`` remains set on exit from an assembly code block.

#### `fls_lv19xysy1f7e`: Register Parameter Modifiers

_File: inline-assembly.rst, Line: 1027_

**Legality Rules:**

- A register parameter modifier is a substring that starts with character 0x3A (colon), follows a register parameter, and changes the formatting of the related register parameter.
- The effects of a register parameter modifier depends on the architecture and register class, as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_6momhvgx4w21` → 22.4.2 Directive Support
- `fls_ylli0ortyegk` → 22.6 Assembly Options
- `fls_qezwyridmjob` → 22.7 Macros: asm, global_asm, and naked_asm
- `fls_pz2ioqchjtym` → 22.2 Register Classes
- `fls_hejgghwzblf` → 22.3 Register Arguments

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.3

**Type:** directive
**Title:** Assembly language shall be encapsulated and isolated

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Rust has asm! macro for inline assembly; always requires unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_a3joqzqp1v9d` | 22.5 | ABI Clobbers |
| `fls_e0896uk0mdyl` | 22.4 | Assembly Instructions |
| `fls_lv19xysy1f7e` | 22.4.1 | Register Parameter Modifiers |

**FLS Sections:** 22, 22.1, 22.2

### FLS Content

#### `fls_a3joqzqp1v9d`: ABI Clobbers

_File: inline-assembly.rst, Line: 1383_

**Legality Rules:**

- An ABI clobber is an argument to macro core::arch::asm which indicates that the values of selected registers might be overwritten during the execution of an assembly code block.
- Multiple ABI clobbers may be specified for an assembly code block. Clobber constraints are applied for all unique registers in the union of all specified ABIs.
- The effects of an ABI clobber depend on the ABI in effect, as follows:
- On x86 architectures, the x87 floating-point register stack shall remain unchanged unless all ``st(``\ [``0``-``7``]\ ``)`` registers have been clobbered.
- On x86 architectures, if all x87 registers are clobbered, then the x87 register stack is presumed empty upon entry of an assembly code block. The x87 register stack shall be empty on exit from an assembly code block.

#### `fls_e0896uk0mdyl`: Assembly Instructions

_File: inline-assembly.rst, Line: 958_

**Legality Rules:**

- An assembly instruction is a string literal that represents a low-level assembly operation or an assembly directive.
- An assembly instruction shall use the syntax of format strings as defined in module std::fmt, and contain zero or more register parameters.
- An assembly code block is a sequence of assembly instructions.
- When an assembly code block contains multiple assembly instructions, the assembly instructions are treated as concatenated into a single string literal, with character 0x0A (new line) between them.
- The set of memory locations that an assembly code block is allowed to read and write are the same as those for an external function, excluding the memory locations that are private to the assembly code block.
- _... and 4 more paragraphs_

**Undefined Behavior:**

- On x86 architectures, it is undefined behavior if direction flag ``DF`` in register ``EFLAGS`` remains set on exit from an assembly code block.

#### `fls_lv19xysy1f7e`: Register Parameter Modifiers

_File: inline-assembly.rst, Line: 1027_

**Legality Rules:**

- A register parameter modifier is a substring that starts with character 0x3A (colon), follows a register parameter, and changes the formatting of the related register parameter.
- The effects of a register parameter modifier depends on the architecture and register class, as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_6momhvgx4w21` → 22.4.2 Directive Support
- `fls_ylli0ortyegk` → 22.6 Assembly Options
- `fls_qezwyridmjob` → 22.7 Macros: asm, global_asm, and naked_asm
- `fls_pz2ioqchjtym` → 22.2 Register Classes
- `fls_hejgghwzblf` → 22.3 Register Arguments

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.4

**Type:** directive
**Title:** Sections of code should not be “commented out”

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Rust has similar comment syntax plus doc comments

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_q8l2jza7d9xa` | 2.5 | Comments |

**FLS Sections:** 2.5

### FLS Content

#### `fls_q8l2jza7d9xa`: Comments

_File: lexical-elements.rst, Line: 1281_

**Legality Rules:**

- A comment is a lexical element that acts as an annotation or an explanation in program text.
- A block comment is a comment that spans one or more lines.
- A line comment is a comment that spans exactly one line.
- An inner block doc is a block comment that applies to an enclosing non-[comment] construct.
- An inner line doc is a line comment that applies to an enclosing non-[comment] construct.
- _... and 12 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_boyhlu5srp6u` → 2.4.6 String Literals
- `fls_jkab8eevzbte` → 2.4.7 Boolean Literals
- `fls_lish33a1naw5` → 2.6 Keywords
- `fls_mec5cg5aptf8` → 2.6.1 Strict Keywords

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.5

**Type:** directive
**Title:** Identifiers in the same name space with overlapping visibility should

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| misra_rust_comment | “ambiguity” is determined by the project |
| confidence | `medium` |

**Notes:** MISRA ADD-6: “ambiguity” is determined by the project. Rust unions require unsafe to read; safe Rust should use enums for tagged unions; Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 4.5.3, 4.11.2.3, 19, 19.-2.7, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_szibmtfv117b` → 4.5.1 Enum Types
- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_hbbek3z4wtcs` → 4.6 Function Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.6

**Type:** directive
**Title:** typedefs that indicate size and signedness should be used in place of

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | all primitive types already fulfil this |
| confidence | `medium` |

**Notes:** MISRA ADD-6: all primitive types already fulfil this. Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has std::mem::size_of

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_7pby13muw48o` | 4.11 | Representation |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 4.11.1, 4.11

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.7

**Type:** directive
**Title:** If a function returns error information, then that error information

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| misra_rust_comment | prefer Option, Result, etc. |
| confidence | `medium` |

**Notes:** MISRA ADD-6: prefer Option, Result, etc.. Similar function semantics with stronger type checking; Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 16, 16.1, 16.2, 6.5.3

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.8

**Type:** directive
**Title:** If a pointer to a structure or union is never dereferenced within a

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Core Rust concept for safe memory access, applies to all Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |
| `fls_3ra8s1v1vbek` | 19.-2.5 | External Static Access |
| `fls_6ipl0xo5qjyl` | 19.-2.6 | Mutable Static Access |
| `fls_ljocmnaz2m49` | 19.-2.8 | Unsafe Function Call |
| `fls_jb6krd90tjmc` | 19.-2.9 | Unsafe Context |
| `fls_ybnpe7ppq1vh` | 19.-2.10 | Unsafe Operation Requirement |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.5.2, 4.11.2.2, 4.11, 4.11.1, 4.5.3, 4.11.2.3, 19.-2.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 19.-2.1, 19.-2.2, 19.-2.3, 19.-2.5, 19.-2.6, 19.-2.8, 19.-2.9, 19.-2.10, 6.4.4

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

#### `fls_3ra8s1v1vbek`: _(not found in RST source)_

#### `fls_6ipl0xo5qjyl`: _(not found in RST source)_

#### `fls_ljocmnaz2m49`: _(not found in RST source)_

#### `fls_jb6krd90tjmc`: _(not found in RST source)_

#### `fls_ybnpe7ppq1vh`: _(not found in RST source)_

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.9

**Type:** directive
**Title:** A function should be used in preference to a function-like macro

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Core Rust concept for safe memory access, applies to all Rust; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.7.3, 15.3, 15.4, 6.5.1, 6.5.2, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types
- `fls_3xqobbu7wfsf` → 4.8.1 Impl Trait Types
- `fls_svkx6szhr472` → 15.1 Ownership
- `fls_3xvm61x0t251` → 15.2 Initialization

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.10

**Type:** directive
**Title:** Precautions shall be taken in order to prevent the contents of a

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6, 6.1, 6.5

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.11

**Type:** directive
**Title:** The validity of values passed to library functions shall be checked

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.12

**Type:** directive
**Title:** Dynamic memory allocation shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.13

**Type:** directive
**Title:** Functions which are designed to provide operations on a resource

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15.6, 15.7, 15.8

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.14

**Type:** directive
**Title:** The validity of values received from external sources shall be checked

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust uses pub visibility and modules instead of linkage; Rust has explicit FFI support with extern blocks; calling extern fn is unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uloyjbaso8pz` | 5.1.4 | Path Patterns |
| `fls_yztwtek0y34v` | 21.3 | External Functions |
| `fls_tmoh3y9oyqsy` | 21.2 | External Blocks |
| `fls_pgp7ezcc9lh8` | 13.2.6 | Foreign Function Interface Attributes |

**FLS Sections:** 14.2, 14.4.3, 14.7, 21, 21.1, 21.2, 13.2.6

### FLS Content

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uloyjbaso8pz`: Path Patterns

_File: patterns.rst, Line: 342_

**Legality Rules:**

- A path pattern is a pattern that matches a constant, a unit enum variant, or a unit struct constant indicated by a path.
- A path pattern expressed as a path expression shall refer to either an associated constant, or a constant.
- When a path pattern refers to an associated constant or a constant, the associated constant or constant shall not be of a union type.
- When a path pattern refers to an associated constant or a constant, the type of the associated constant or constant shall be structurally equal.
- When a path pattern refers to an associated constant or a constant, the constant must not contain any references to mutable statics, statics with interior mutability, or external statics.
- _... and 4 more paragraphs_

**Examples:**

- See :p:`fls_sfyfdxhvhk44` for the declaration of ``x``.

#### `fls_yztwtek0y34v`: External Functions

_File: ffi.rst, Line: 212_

**Legality Rules:**

- An external function is an unchecked import of a foreign function.
- An external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to ItemSafety with keyword ``safe``.
- An external function shall not specify a FunctionQualifierList.
- An external function inherits the ABI of its enclosing external block.
- An external function shall not specify a GenericParameterList containing constant parameters or type parameters.
- _... and 3 more paragraphs_

#### `fls_tmoh3y9oyqsy`: External Blocks

_File: ffi.rst, Line: 155_

**Legality Rules:**

- An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.
- An unsafe external block is an external block subject to keyword ``unsafe``.
- The ABI of an external block is determined as follows:

#### `fls_pgp7ezcc9lh8`: Foreign Function Interface Attributes

_File: attributes.rst, Line: 1118_

**Legality Rules:**

- Attribute :c:`crate_name` shall apply to the crate root module.
- Attribute :dc:`crate_name` shall specify the name of the related crate.
- Attribute :c:`crate_type` shall apply to the crate root module.
- Attribute :dc:`crate_type` shall specify the linkage type of the crate it appears in.
- Attribute :c:`export_name` shall apply to functions and statics.
- _... and 33 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_gdeyap4or1db` → 14 Entities and Resolution
- `fls_151r19d7xbgz` → 14.1 Entities
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_izl8iuhoz9e0` → 14.4 Scopes
- `fls_6ozthochxz1i` → 14.4.1 Binding Scopes
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope
- `fls_769b4p8v3cwu` → 14.4.4 Label Scope
- `fls_kgbi26212eof` → 14.4.5 Self Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 4.15

**Type:** directive
**Title:** Evaluation of floating-point expressions shall not lead to the

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| misra_rust_comment | Rust implements IEEE-754 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: Rust implements IEEE-754. Rust has similar floating point semantics to C (IEEE 754); Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_b4xporvr64s` | 4.3.3.1 | Floating Point Types |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 4.3.3.1, 2.4.4.2, 6.5.5, 6.5.7, 6, 6.1, 6.5

### FLS Content

#### `fls_b4xporvr64s`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 5.1

**Type:** directive
**Title:** There shall be no data races between threads

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| misra_rust_comment | not all safe Rust types are race-free |
| confidence | `medium` |

**Notes:** MISRA ADD-6: not all safe Rust types are race-free. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 17, 17.1, 17.2

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 5.2

**Type:** directive
**Title:** There shall be no deadlocks between threads

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 17, 17.1, 17.2

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Dir 5.3

**Type:** directive
**Title:** There shall be no dynamic thread creation

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 17, 17.1, 17.2

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 1.1

**Type:** rule
**Title:** 4.2 Compilation and build

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust prevents undefined behavior; unsafe requires careful handling

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |

**FLS Sections:** 19, 19.-2.1, 19.-2.2, 19.-2.3

### FLS Content

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 1.2

**Type:** rule
**Title:** Renumbered as Directive 1.2 MISRA C:2025

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | Renumbered moved to Directive 1.2 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: Renumbered moved to Directive 1.2. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust enums are more powerful (algebraic data types)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_szibmtfv117b` | 4.5.1 | Enum Types |
| `fls_xc1hof4qbf6p` | 4.11.2.1 | Enum Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.5.1, 4.11.2.1, 4.11, 19, 19.-2.1, 19.-2.2, 19.-2.3

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_szibmtfv117b`: Enum Types

_File: types-and-traits.rst, Line: 611_

**Legality Rules:**

- An enum type is an abstract data type that contains enum variants.
- A zero-variant enum type has no values.
- An enum variant is a construct that declares one of the possible variations of an enum.
- The name of an enum variant shall be unique within the related EnumDeclaration.
- A discriminant is an opaque integer that identifies an enum variant.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is a validity invariant for a value of an enum type to have a discriminant specified by the enum type.

#### `fls_xc1hof4qbf6p`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 1.3

**Type:** rule
**Title:** There shall be no occurrence of undefined or critical unspecified

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust prevents undefined behavior; unsafe requires careful handling

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |

**FLS Sections:** 19, 19.-2.1, 19.-2.2, 19.-2.3

### FLS Content

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 1.4

**Type:** rule
**Title:** Emergent language features shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | this is specific to C versioning |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this is specific to C versioning. Safe Rust prevents undefined behavior; unsafe requires careful handling

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |

**FLS Sections:** 19, 19.-2.1, 19.-2.2, 19.-2.3

### FLS Content

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 1.5

**Type:** rule
**Title:** Obsolescent language features shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | this applies to deprecated APIs |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this applies to deprecated APIs. Safe Rust prevents undefined behavior; unsafe requires careful handling. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |

**FLS Sections:** 19, 19.-2.1, 19.-2.2, 19.-2.3

### FLS Content

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.1

**Type:** rule
**Title:** A project shall not contain unreachable code

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Rust compiler warns about unreachable code; has unreachable!() macro

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 4.9.3

### FLS Content

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_s45k21yn4qur` → 4.9.1 Inferred Types
- `fls_XJCXBAJHzP3D` → ? Type Parameters
- `fls_olbj67eyxz2k` → 4.9.4 Parenthesized Types
- `fls_kgvleup5mdhq` → 4.10 Type Aliases

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.2

**Type:** rule
**Title:** A project shall not contain dead code

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust compiler warns about unreachable code; has unreachable!() macro

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 4.9.3

### FLS Content

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_s45k21yn4qur` → 4.9.1 Inferred Types
- `fls_XJCXBAJHzP3D` → ? Type Parameters
- `fls_olbj67eyxz2k` → 4.9.4 Parenthesized Types
- `fls_kgvleup5mdhq` → 4.10 Type Aliases

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.3

**Type:** rule
**Title:** Advisory A project should not contain unused type declarations

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 4.9.3

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.4

**Type:** rule
**Title:** A project should not contain unused tag declarations

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | no separate tag name space in Rust |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no separate tag name space in Rust. Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 4.9.3

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.5

**Type:** rule
**Title:** A project should not contain unused macro definitions

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses pub visibility and modules instead of linkage

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 14.2, 14.4.3, 14.7, 4.9.3

### FLS Content

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_gdeyap4or1db` → 14 Entities and Resolution
- `fls_151r19d7xbgz` → 14.1 Entities
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_izl8iuhoz9e0` → 14.4 Scopes
- `fls_6ozthochxz1i` → 14.4.1 Binding Scopes
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope
- `fls_769b4p8v3cwu` → 14.4.4 Label Scope
- `fls_kgbi26212eof` → 14.4.5 Self Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.6

**Type:** rule
**Title:** A function should not contain unused label declarations

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust has no goto; uses labeled loops for complex control flow

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.4.4, 14.2, 14.4.3, 14.7, 4.9.3

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.7

**Type:** rule
**Title:** A function should not contain unused parameters

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust compiler warns about unreachable code; has unreachable!() macro

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 4.9.3

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 2.8

**Type:** rule
**Title:** A project should not contain unused object definitions

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Rust uses pub visibility and modules instead of linkage; Rust compiler warns about unreachable code; has unreachable!() macro

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_98lnexk53ru4` | 4.9.3 | Never Type |

**FLS Sections:** 14.2, 14.4.3, 14.7, 4.9.3

### FLS Content

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_98lnexk53ru4`: Never Type

_File: types-and-traits.rst, Line: 1296_

**Legality Rules:**

- The never type is a type that represents the result of a computation that never completes.
- The never type has no values.

**Undefined Behavior:**

- It is validity invariant to not have a value of the never type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_gdeyap4or1db` → 14 Entities and Resolution
- `fls_151r19d7xbgz` → 14.1 Entities
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_izl8iuhoz9e0` → 14.4 Scopes
- `fls_6ozthochxz1i` → 14.4.1 Binding Scopes
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope
- `fls_769b4p8v3cwu` → 14.4.4 Label Scope
- `fls_kgbi26212eof` → 14.4.5 Self Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 3.1

**Type:** rule
**Title:** The character sequences /* and // shall not be used within a

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| misra_rust_comment | nested comments are fully supported |
| confidence | `medium` |

**Notes:** MISRA ADD-6: nested comments are fully supported. Rust has similar comment syntax plus doc comments

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_q8l2jza7d9xa` | 2.5 | Comments |

**FLS Sections:** 2.5

### FLS Content

#### `fls_q8l2jza7d9xa`: Comments

_File: lexical-elements.rst, Line: 1281_

**Legality Rules:**

- A comment is a lexical element that acts as an annotation or an explanation in program text.
- A block comment is a comment that spans one or more lines.
- A line comment is a comment that spans exactly one line.
- An inner block doc is a block comment that applies to an enclosing non-[comment] construct.
- An inner line doc is a line comment that applies to an enclosing non-[comment] construct.
- _... and 12 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_boyhlu5srp6u` → 2.4.6 String Literals
- `fls_jkab8eevzbte` → 2.4.7 Boolean Literals
- `fls_lish33a1naw5` → 2.6 Keywords
- `fls_mec5cg5aptf8` → 2.6.1 Strict Keywords

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 3.2

**Type:** rule
**Title:** Line-splicing shall not be used in // comments

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar comment syntax plus doc comments

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_q8l2jza7d9xa` | 2.5 | Comments |

**FLS Sections:** 2.5

### FLS Content

#### `fls_q8l2jza7d9xa`: Comments

_File: lexical-elements.rst, Line: 1281_

**Legality Rules:**

- A comment is a lexical element that acts as an annotation or an explanation in program text.
- A block comment is a comment that spans one or more lines.
- A line comment is a comment that spans exactly one line.
- An inner block doc is a block comment that applies to an enclosing non-[comment] construct.
- An inner line doc is a line comment that applies to an enclosing non-[comment] construct.
- _... and 12 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_boyhlu5srp6u` → 2.4.6 String Literals
- `fls_jkab8eevzbte` → 2.4.7 Boolean Literals
- `fls_lish33a1naw5` → 2.6 Keywords
- `fls_mec5cg5aptf8` → 2.6.1 Strict Keywords

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 4.1

**Type:** rule
**Title:** Octal and hexadecimal escape sequences shall be terminated

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has panic! and abort for abnormal termination; Rust has similar literals with type suffixes

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |

**FLS Sections:** 16.1, 16.2, 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2

### FLS Content

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_dzq9cdz4ibsz` → 16 Exceptions and Errors

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 4.2

**Type:** rule
**Title:** Trigraphs should not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar literals with type suffixes

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |

**FLS Sections:** 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2

### FLS Content

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_21vnag69kbwe` → 2.3 Identifiers
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_fqaffyrjob7v` → 2.4.2 Byte String Literals
- `fls_U1gHCy16emVe` → ? C String Literals
- `fls_ypa86oqxhn9u` → 2.4.5 Character Literals
- `fls_boyhlu5srp6u` → 2.4.6 String Literals

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 5.1

**Type:** rule
**Title:** External identifiers shall be distinct

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | no character limit, except in extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no character limit, except in extern “C”. Rust has similar scoping rules with explicit shadowing; Rust uses pub visibility and modules instead of linkage. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uloyjbaso8pz` | 5.1.4 | Path Patterns |
| `fls_yztwtek0y34v` | 21.3 | External Functions |
| `fls_tmoh3y9oyqsy` | 21.2 | External Blocks |
| `fls_pgp7ezcc9lh8` | 13.2.6 | Foreign Function Interface Attributes |

**FLS Sections:** 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2, 14.7, 21, 21.1, 21.2, 13.2.6

### FLS Content

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uloyjbaso8pz`: Path Patterns

_File: patterns.rst, Line: 342_

**Legality Rules:**

- A path pattern is a pattern that matches a constant, a unit enum variant, or a unit struct constant indicated by a path.
- A path pattern expressed as a path expression shall refer to either an associated constant, or a constant.
- When a path pattern refers to an associated constant or a constant, the associated constant or constant shall not be of a union type.
- When a path pattern refers to an associated constant or a constant, the type of the associated constant or constant shall be structurally equal.
- When a path pattern refers to an associated constant or a constant, the constant must not contain any references to mutable statics, statics with interior mutability, or external statics.
- _... and 4 more paragraphs_

**Examples:**

- See :p:`fls_sfyfdxhvhk44` for the declaration of ``x``.

#### `fls_yztwtek0y34v`: External Functions

_File: ffi.rst, Line: 212_

**Legality Rules:**

- An external function is an unchecked import of a foreign function.
- An external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to ItemSafety with keyword ``safe``.
- An external function shall not specify a FunctionQualifierList.
- An external function inherits the ABI of its enclosing external block.
- An external function shall not specify a GenericParameterList containing constant parameters or type parameters.
- _... and 3 more paragraphs_

#### `fls_tmoh3y9oyqsy`: External Blocks

_File: ffi.rst, Line: 155_

**Legality Rules:**

- An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.
- An unsafe external block is an external block subject to keyword ``unsafe``.
- The ABI of an external block is determined as follows:

#### `fls_pgp7ezcc9lh8`: Foreign Function Interface Attributes

_File: attributes.rst, Line: 1118_

**Legality Rules:**

- Attribute :c:`crate_name` shall apply to the crate root module.
- Attribute :dc:`crate_name` shall specify the name of the related crate.
- Attribute :c:`crate_type` shall apply to the crate root module.
- Attribute :dc:`crate_type` shall specify the linkage type of the crate it appears in.
- Attribute :c:`export_name` shall apply to functions and statics.
- _... and 33 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_2i089jvv8j5g` → 2.1 Character Set
- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_nrkd5wpi64oo` → 2.4 Literals
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 5.2

**Type:** rule
**Title:** Identifiers declared in the same scope and name space shall be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| misra_rust_comment | no character limit, but has name spaces |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no character limit, but has name spaces. Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_2i089jvv8j5g` → 2.1 Character Set
- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_nrkd5wpi64oo` → 2.4 Literals
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 5.3

**Type:** rule
**Title:** An identifier declared in an inner scope shall not hide an identifier

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| misra_rust_comment | this also applies to macro names |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this also applies to macro names. Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_2i089jvv8j5g` → 2.1 Character Set
- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_nrkd5wpi64oo` → 2.4 Literals
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 5.5

**Type:** rule
**Title:** Identifiers shall be distinct from macro names

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `advisory` |
| misra_rust_comment | macros and functions use different syntax |
| confidence | `medium` |

**Notes:** MISRA ADD-6: macros and functions use different syntax. Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_2i089jvv8j5g` → 2.1 Character Set
- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_nrkd5wpi64oo` → 2.4 Literals
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 5.6

**Type:** rule
**Title:** A typedef name shall be a unique identifier

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_2i089jvv8j5g` → 2.1 Character Set
- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_nrkd5wpi64oo` → 2.4 Literals
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 5.8

**Type:** rule
**Title:** Required Identifiers that define objects or functions with external linkage shall be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uloyjbaso8pz` | 5.1.4 | Path Patterns |
| `fls_yztwtek0y34v` | 21.3 | External Functions |
| `fls_tmoh3y9oyqsy` | 21.2 | External Blocks |
| `fls_pgp7ezcc9lh8` | 13.2.6 | Foreign Function Interface Attributes |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2, 14.7, 21, 21.1, 21.2, 13.2.6

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uloyjbaso8pz`: Path Patterns

_File: patterns.rst, Line: 342_

**Legality Rules:**

- A path pattern is a pattern that matches a constant, a unit enum variant, or a unit struct constant indicated by a path.
- A path pattern expressed as a path expression shall refer to either an associated constant, or a constant.
- When a path pattern refers to an associated constant or a constant, the associated constant or constant shall not be of a union type.
- When a path pattern refers to an associated constant or a constant, the type of the associated constant or constant shall be structurally equal.
- When a path pattern refers to an associated constant or a constant, the constant must not contain any references to mutable statics, statics with interior mutability, or external statics.
- _... and 4 more paragraphs_

**Examples:**

- See :p:`fls_sfyfdxhvhk44` for the declaration of ``x``.

#### `fls_yztwtek0y34v`: External Functions

_File: ffi.rst, Line: 212_

**Legality Rules:**

- An external function is an unchecked import of a foreign function.
- An external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to ItemSafety with keyword ``safe``.
- An external function shall not specify a FunctionQualifierList.
- An external function inherits the ABI of its enclosing external block.
- An external function shall not specify a GenericParameterList containing constant parameters or type parameters.
- _... and 3 more paragraphs_

#### `fls_tmoh3y9oyqsy`: External Blocks

_File: ffi.rst, Line: 155_

**Legality Rules:**

- An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.
- An unsafe external block is an external block subject to keyword ``unsafe``.
- The ABI of an external block is determined as follows:

#### `fls_pgp7ezcc9lh8`: Foreign Function Interface Attributes

_File: attributes.rst, Line: 1118_

**Legality Rules:**

- Attribute :c:`crate_name` shall apply to the crate root module.
- Attribute :dc:`crate_name` shall specify the name of the related crate.
- Attribute :c:`crate_type` shall apply to the crate root module.
- Attribute :dc:`crate_type` shall specify the linkage type of the crate it appears in.
- Attribute :c:`export_name` shall apply to functions and statics.
- _... and 33 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 5.10

**Type:** rule
**Title:** A reserved identifier or reserved macro name shall not be declared

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `advisory` |
| misra_rust_comment | only possible in some cases. Previously Rule 21.2 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only possible in some cases. Previously Rule 21.2. Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_2i089jvv8j5g` → 2.1 Character Set
- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_nrkd5wpi64oo` → 2.4 Literals
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 6.1

**Type:** rule
**Title:** Bit-fields shall only be declared with an appropriate type

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | only provided as a library feature |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only provided as a library feature. Rust has similar struct semantics; Rust has no native bit-field syntax; use bitflags crate or manual bit manipulation

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_ohhsmifo0urd` | 4.11.2 | Type Representation |

**FLS Sections:** 4.5.2, 4.11.2.2, 4.11, 4.11.1, 6.5.6, 4.11.2

### FLS Content

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_ohhsmifo0urd`: Type Representation

_File: types-and-traits.rst, Line: 1508_

**Legality Rules:**

- Type representation specifies the layout of fields of abstract data types. Type representation changes the bit padding between fields of abstract data types as well as their order, but does not change the layout of the fields themselves.
- Type representation is classified into:
- C representation lays out a type such that the type is interoperable with the C language.
- Default representation makes no guarantees about the layout.
- Primitive representation is the type representation of individual integer types. Primitive representation applies only to an enum type that is not a zero-variant enum type. It is possible to combine C representation and primitive representation.
- _... and 19 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_wdec78luqh5b` → 4.5 Abstract Data Types
- `fls_szibmtfv117b` → 4.5.1 Enum Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_hbbek3z4wtcs` → 4.6 Function Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 6.2

**Type:** rule
**Title:** Single-bit named bit-fields shall not be of a signed type

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has similar struct semantics

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_ohhsmifo0urd` | 4.11.2 | Type Representation |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 4.5.2, 4.11.2.2, 4.11, 4.11.1, 4.11.2, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_ohhsmifo0urd`: Type Representation

_File: types-and-traits.rst, Line: 1508_

**Legality Rules:**

- Type representation specifies the layout of fields of abstract data types. Type representation changes the bit padding between fields of abstract data types as well as their order, but does not change the layout of the fields themselves.
- Type representation is classified into:
- C representation lays out a type such that the type is interoperable with the C language.
- Default representation makes no guarantees about the layout.
- Primitive representation is the type representation of individual integer types. Primitive representation applies only to an enum type that is not a zero-variant enum type. It is possible to combine C representation and primitive representation.
- _... and 19 more paragraphs_

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 6.3

**Type:** rule
**Title:** A bit-field shall not be declared as a member of a union

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has similar struct semantics

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_ohhsmifo0urd` | 4.11.2 | Type Representation |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_3ra8s1v1vbek` | 19.-2.5 | External Static Access |
| `fls_6ipl0xo5qjyl` | 19.-2.6 | Mutable Static Access |
| `fls_ljocmnaz2m49` | 19.-2.8 | Unsafe Function Call |
| `fls_jb6krd90tjmc` | 19.-2.9 | Unsafe Context |
| `fls_ybnpe7ppq1vh` | 19.-2.10 | Unsafe Operation Requirement |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.5.2, 4.11.2.2, 4.11, 4.11.1, 4.5.3, 4.11.2.3, 19, 19.-2.7, 6.5.6, 4.11.2, 19.-2.1, 19.-2.2, 19.-2.3, 19.-2.4, 19.-2.5, 19.-2.6, 19.-2.8, 19.-2.9, 19.-2.10, 6.4.4

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_ohhsmifo0urd`: Type Representation

_File: types-and-traits.rst, Line: 1508_

**Legality Rules:**

- Type representation specifies the layout of fields of abstract data types. Type representation changes the bit padding between fields of abstract data types as well as their order, but does not change the layout of the fields themselves.
- Type representation is classified into:
- C representation lays out a type such that the type is interoperable with the C language.
- Default representation makes no guarantees about the layout.
- Primitive representation is the type representation of individual integer types. Primitive representation applies only to an enum type that is not a zero-variant enum type. It is possible to combine C representation and primitive representation.
- _... and 19 more paragraphs_

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_3ra8s1v1vbek`: _(not found in RST source)_

#### `fls_6ipl0xo5qjyl`: _(not found in RST source)_

#### `fls_ljocmnaz2m49`: _(not found in RST source)_

#### `fls_jb6krd90tjmc`: _(not found in RST source)_

#### `fls_ybnpe7ppq1vh`: _(not found in RST source)_

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 7.1

**Type:** rule
**Title:** Octal constants shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| misra_rust_comment | Rust octals have a distinct prefix from decimals |
| confidence | `medium` |

**Notes:** MISRA ADD-6: Rust octals have a distinct prefix from decimals. Rust has similar literals with type suffixes; Rust uses mut/immutable references; volatile via std::ptr::read/write_volatile (unsafe)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_66m4rnbssgig` | 6.1.2 | Constant Expressions |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |

**FLS Sections:** 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2, 4.7.3, 4.12.5, 6.1.2, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3

### FLS Content

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_66m4rnbssgig`: Constant Expressions

_File: expressions.rst, Line: 155_

**Legality Rules:**

- A constant expression is an expression that can be evaluated statically. The following constructs are constant expressions as long as their operands are also constant expressions and do not involve types that require destruction:
- An expression is not considered a constant expression when it explicitly invokes an associated trait function or uses arithmetic operators of non-builtin types that invoke core::ops traits.
- It is a static error if the size operand of an array repetition constructor or an array type depends on generic parameters.
- A constant context is a construct that requires a constant expression. The following constructs are constant contexts:
- An invocation of the core::ptr::addr_of macro expands to a constant expression allowed in any constant context and constant function, subject to the same restrictions as a immutable borrow expression.
- _... and 5 more paragraphs_

**Dynamic Semantics:**

- The invocation of a constant function follows the dynamic semantics of a non-[constant function] invocation.

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_21vnag69kbwe` → 2.3 Identifiers
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_fqaffyrjob7v` → 2.4.2 Byte String Literals
- `fls_U1gHCy16emVe` → ? C String Literals
- `fls_ypa86oqxhn9u` → 2.4.5 Character Literals
- `fls_boyhlu5srp6u` → 2.4.6 String Literals

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 7.2

**Type:** rule
**Title:** A “u” or “U” suffix shall be applied to all integer constants that are

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| misra_rust_comment | this is an error by default but can be enabled |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this is an error by default but can be enabled. Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has similar literals with type suffixes

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_66m4rnbssgig` | 6.1.2 | Constant Expressions |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2, 4.7.3, 4.12.5, 6.1.2

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_66m4rnbssgig`: Constant Expressions

_File: expressions.rst, Line: 155_

**Legality Rules:**

- A constant expression is an expression that can be evaluated statically. The following constructs are constant expressions as long as their operands are also constant expressions and do not involve types that require destruction:
- An expression is not considered a constant expression when it explicitly invokes an associated trait function or uses arithmetic operators of non-builtin types that invoke core::ops traits.
- It is a static error if the size operand of an array repetition constructor or an array type depends on generic parameters.
- A constant context is a construct that requires a constant expression. The following constructs are constant contexts:
- An invocation of the core::ptr::addr_of macro expands to a constant expression allowed in any constant context and constant function, subject to the same restrictions as a immutable borrow expression.
- _... and 5 more paragraphs_

**Dynamic Semantics:**

- The invocation of a constant function follows the dynamic semantics of a non-[constant function] invocation.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 7.3

**Type:** rule
**Title:** The lowercase character “l” shall not be used in a literal suffix

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 5.4.5, 5.2, 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 7.4

**Type:** rule
**Title:** A string literal shall not be assigned to an object unless the object’s

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Safe Rust String/str types prevent buffer overflows and ensure valid UTF-8; unsafe can use raw pointers

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2, 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 7.5

**Type:** rule
**Title:** The argument of an integer constant macro shall have an appropriate

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_66m4rnbssgig` | 6.1.2 | Constant Expressions |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2, 4.7.3, 4.12.5, 6.1.2

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_66m4rnbssgig`: Constant Expressions

_File: expressions.rst, Line: 155_

**Legality Rules:**

- A constant expression is an expression that can be evaluated statically. The following constructs are constant expressions as long as their operands are also constant expressions and do not involve types that require destruction:
- An expression is not considered a constant expression when it explicitly invokes an associated trait function or uses arithmetic operators of non-builtin types that invoke core::ops traits.
- It is a static error if the size operand of an array repetition constructor or an array type depends on generic parameters.
- A constant context is a construct that requires a constant expression. The following constructs are constant contexts:
- An invocation of the core::ptr::addr_of macro expands to a constant expression allowed in any constant context and constant function, subject to the same restrictions as a immutable borrow expression.
- _... and 5 more paragraphs_

**Dynamic Semantics:**

- The invocation of a constant function follows the dynamic semantics of a non-[constant function] invocation.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.1

**Type:** rule
**Title:** Types shall be explicitly specified

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.3

**Type:** rule
**Title:** All declarations of an object or function shall use the same names and

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | an extern declaration shall have a type compatible with the C declaration |
| confidence | `medium` |

**Notes:** MISRA ADD-6: an extern declaration shall have a type compatible with the C declaration. Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_maw4u1o8q37u` | 18.3 | Crates |
| `fls_gklst7joeo33` | 18.4 | Crate Imports |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2, 14.7, 18, 18.1, 18.2, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_maw4u1o8q37u`: Crates

_File: program-structure-and-compilation.rst, Line: 107_

**Legality Rules:**

- A crate is a unit of compilation and linking that contains a tree of nested modules.
- The crate type of a crate is the value of the attribute ``crate_type`` of a crate or the value of ``--crate-type`` flag passed to the tool compiling the crate.
- The crate type of a crate if not specified is ``bin``.
- A crate may be subject to multiple crate types, treating each type as a separate crate.
- A binary crate is a crate whose crate type is ``bin``.
- _... and 6 more paragraphs_

#### `fls_gklst7joeo33`: Crate Imports

_File: program-structure-and-compilation.rst, Line: 158_

**Legality Rules:**

- A crate import specifies a required dependency on an external crate.
- A crate indication is a construct that indicates a crate.
- A crate import binds an external crate to its crate indication.
- Crate indication ``self`` shall require a renaming.
- A crate import with a renaming with an identifier binds the external crate to a local name and introduces the local name into the enclosing scope.
- _... and 2 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.4

**Type:** rule
**Title:** A compatible declaration shall be visible when an object or function

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.5

**Type:** rule
**Title:** An external object or function shall be declared once in one and only

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `advisory` |
| misra_rust_comment | may affect extern “C” declarations |
| confidence | `medium` |

**Notes:** MISRA ADD-6: may affect extern “C” declarations. Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uloyjbaso8pz` | 5.1.4 | Path Patterns |
| `fls_yztwtek0y34v` | 21.3 | External Functions |
| `fls_tmoh3y9oyqsy` | 21.2 | External Blocks |
| `fls_pgp7ezcc9lh8` | 13.2.6 | Foreign Function Interface Attributes |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 21, 21.1, 21.2, 13.2.6, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uloyjbaso8pz`: Path Patterns

_File: patterns.rst, Line: 342_

**Legality Rules:**

- A path pattern is a pattern that matches a constant, a unit enum variant, or a unit struct constant indicated by a path.
- A path pattern expressed as a path expression shall refer to either an associated constant, or a constant.
- When a path pattern refers to an associated constant or a constant, the associated constant or constant shall not be of a union type.
- When a path pattern refers to an associated constant or a constant, the type of the associated constant or constant shall be structurally equal.
- When a path pattern refers to an associated constant or a constant, the constant must not contain any references to mutable statics, statics with interior mutability, or external statics.
- _... and 4 more paragraphs_

**Examples:**

- See :p:`fls_sfyfdxhvhk44` for the declaration of ``x``.

#### `fls_yztwtek0y34v`: External Functions

_File: ffi.rst, Line: 212_

**Legality Rules:**

- An external function is an unchecked import of a foreign function.
- An external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to ItemSafety with keyword ``safe``.
- An external function shall not specify a FunctionQualifierList.
- An external function inherits the ABI of its enclosing external block.
- An external function shall not specify a GenericParameterList containing constant parameters or type parameters.
- _... and 3 more paragraphs_

#### `fls_tmoh3y9oyqsy`: External Blocks

_File: ffi.rst, Line: 155_

**Legality Rules:**

- An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.
- An unsafe external block is an external block subject to keyword ``unsafe``.
- The ABI of an external block is determined as follows:

#### `fls_pgp7ezcc9lh8`: Foreign Function Interface Attributes

_File: attributes.rst, Line: 1118_

**Legality Rules:**

- Attribute :c:`crate_name` shall apply to the crate root module.
- Attribute :dc:`crate_name` shall specify the name of the related crate.
- Attribute :c:`crate_type` shall apply to the crate root module.
- Attribute :dc:`crate_type` shall specify the linkage type of the crate it appears in.
- Attribute :c:`export_name` shall apply to functions and statics.
- _... and 33 more paragraphs_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.6

**Type:** rule
**Title:** 5.3 Comments

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | may affect extern “C” declarations |
| confidence | `medium` |

**Notes:** MISRA ADD-6: may affect extern “C” declarations. Rust has similar comment syntax plus doc comments; Similar function semantics with stronger type checking. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_q8l2jza7d9xa` | 2.5 | Comments |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 2.5, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_q8l2jza7d9xa`: Comments

_File: lexical-elements.rst, Line: 1281_

**Legality Rules:**

- A comment is a lexical element that acts as an annotation or an explanation in program text.
- A block comment is a comment that spans one or more lines.
- A line comment is a comment that spans exactly one line.
- An inner block doc is a block comment that applies to an enclosing non-[comment] construct.
- An inner line doc is a line comment that applies to an enclosing non-[comment] construct.
- _... and 12 more paragraphs_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_boyhlu5srp6u` → 2.4.6 String Literals
- `fls_jkab8eevzbte` → 2.4.7 Boolean Literals
- `fls_lish33a1naw5` → 2.6 Keywords
- `fls_mec5cg5aptf8` → 2.6.1 Strict Keywords
- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.7

**Type:** rule
**Title:** Advisory Functions and objects should not be defined with external linkage if they

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| misra_rust_comment | items should not be declared pub if referenced in only one crate |
| confidence | `medium` |

**Notes:** MISRA ADD-6: items should not be declared pub if referenced in only one crate. Similar function semantics with stronger type checking; Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uloyjbaso8pz` | 5.1.4 | Path Patterns |
| `fls_yztwtek0y34v` | 21.3 | External Functions |
| `fls_tmoh3y9oyqsy` | 21.2 | External Blocks |
| `fls_pgp7ezcc9lh8` | 13.2.6 | Foreign Function Interface Attributes |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 14.2, 14.4.3, 14.7, 21, 21.1, 21.2, 13.2.6, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uloyjbaso8pz`: Path Patterns

_File: patterns.rst, Line: 342_

**Legality Rules:**

- A path pattern is a pattern that matches a constant, a unit enum variant, or a unit struct constant indicated by a path.
- A path pattern expressed as a path expression shall refer to either an associated constant, or a constant.
- When a path pattern refers to an associated constant or a constant, the associated constant or constant shall not be of a union type.
- When a path pattern refers to an associated constant or a constant, the type of the associated constant or constant shall be structurally equal.
- When a path pattern refers to an associated constant or a constant, the constant must not contain any references to mutable statics, statics with interior mutability, or external statics.
- _... and 4 more paragraphs_

**Examples:**

- See :p:`fls_sfyfdxhvhk44` for the declaration of ``x``.

#### `fls_yztwtek0y34v`: External Functions

_File: ffi.rst, Line: 212_

**Legality Rules:**

- An external function is an unchecked import of a foreign function.
- An external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to ItemSafety with keyword ``safe``.
- An external function shall not specify a FunctionQualifierList.
- An external function inherits the ABI of its enclosing external block.
- An external function shall not specify a GenericParameterList containing constant parameters or type parameters.
- _... and 3 more paragraphs_

#### `fls_tmoh3y9oyqsy`: External Blocks

_File: ffi.rst, Line: 155_

**Legality Rules:**

- An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.
- An unsafe external block is an external block subject to keyword ``unsafe``.
- The ABI of an external block is determined as follows:

#### `fls_pgp7ezcc9lh8`: Foreign Function Interface Attributes

_File: attributes.rst, Line: 1118_

**Legality Rules:**

- Attribute :c:`crate_name` shall apply to the crate root module.
- Attribute :dc:`crate_name` shall specify the name of the related crate.
- Attribute :c:`crate_type` shall apply to the crate root module.
- Attribute :dc:`crate_type` shall specify the linkage type of the crate it appears in.
- Attribute :c:`export_name` shall apply to functions and statics.
- _... and 33 more paragraphs_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.8

**Type:** rule
**Title:** The static storage class specifier shall be used in all declarations of

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust unions require unsafe to read; safe Rust should use enums for tagged unions; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |

**FLS Sections:** 4.5.3, 4.11.2.3, 19, 19.-2.7, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15.1, 15.8, 15.8.1, 14.2, 14.4.3, 14.7

### FLS Content

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_szibmtfv117b` → 4.5.1 Enum Types
- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.9

**Type:** rule
**Title:** Advisory An object should be declared at block scope if its identifier only appears

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust has Mutex<T> and RwLock<T> with RAII guards

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 17, 17.1, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.10

**Type:** rule
**Title:** Section 5: Rules

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.11

**Type:** rule
**Title:** Advisory When an array with external linkage is declared, its size should be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Rust uses pub visibility and modules instead of linkage

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uloyjbaso8pz` | 5.1.4 | Path Patterns |
| `fls_yztwtek0y34v` | 21.3 | External Functions |
| `fls_tmoh3y9oyqsy` | 21.2 | External Blocks |
| `fls_pgp7ezcc9lh8` | 13.2.6 | Foreign Function Interface Attributes |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.4.1, 4.4.2, 6.8.1, 6.8.2, 14.2, 14.4.3, 14.7, 21, 21.1, 21.2, 13.2.6, 4.11.1, 4.11, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uloyjbaso8pz`: Path Patterns

_File: patterns.rst, Line: 342_

**Legality Rules:**

- A path pattern is a pattern that matches a constant, a unit enum variant, or a unit struct constant indicated by a path.
- A path pattern expressed as a path expression shall refer to either an associated constant, or a constant.
- When a path pattern refers to an associated constant or a constant, the associated constant or constant shall not be of a union type.
- When a path pattern refers to an associated constant or a constant, the type of the associated constant or constant shall be structurally equal.
- When a path pattern refers to an associated constant or a constant, the constant must not contain any references to mutable statics, statics with interior mutability, or external statics.
- _... and 4 more paragraphs_

**Examples:**

- See :p:`fls_sfyfdxhvhk44` for the declaration of ``x``.

#### `fls_yztwtek0y34v`: External Functions

_File: ffi.rst, Line: 212_

**Legality Rules:**

- An external function is an unchecked import of a foreign function.
- An external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to ItemSafety with keyword ``safe``.
- An external function shall not specify a FunctionQualifierList.
- An external function inherits the ABI of its enclosing external block.
- An external function shall not specify a GenericParameterList containing constant parameters or type parameters.
- _... and 3 more paragraphs_

#### `fls_tmoh3y9oyqsy`: External Blocks

_File: ffi.rst, Line: 155_

**Legality Rules:**

- An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.
- An unsafe external block is an external block subject to keyword ``unsafe``.
- The ABI of an external block is determined as follows:

#### `fls_pgp7ezcc9lh8`: Foreign Function Interface Attributes

_File: attributes.rst, Line: 1118_

**Legality Rules:**

- Attribute :c:`crate_name` shall apply to the crate root module.
- Attribute :dc:`crate_name` shall specify the name of the related crate.
- Attribute :c:`crate_type` shall apply to the crate root module.
- Attribute :dc:`crate_type` shall specify the linkage type of the crate it appears in.
- Attribute :c:`export_name` shall apply to functions and statics.
- _... and 33 more paragraphs_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qwljwqr07slp` → 4.3.3 Numeric Types
- `fls_fbchw64p6n2x` → 4.4 Sequence Types
- `fls_4agmmu5al6gt` → 4.4.3 Str Type
- `fls_4ckl3n2ko3i4` → 4.4.4 Tuple Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.12

**Type:** rule
**Title:** Within an enumerator list, the value of an implicitly-specified

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust enums are more powerful (algebraic data types)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_szibmtfv117b` | 4.5.1 | Enum Types |
| `fls_xc1hof4qbf6p` | 4.11.2.1 | Enum Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_85vx1qfa061i` | 4.13 | Traits |
| `fls_4ikc07mfrez5` | 4.13.1 | Object Safety |
| `fls_jeoas4n6su4` | 4.14 | Trait and Lifetime Bounds |
| `fls_1ompd93w7c9f` | 4.8 | Trait Types |
| `fls_3xqobbu7wfsf` | 4.8.1 | Impl Trait Types |
| `fls_qa98qdi42orq` | 4.8.2 | Trait Object Types |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.5.1, 4.11.2.1, 4.11, 4.13, 4.13.1, 4.14, 4.8, 4.8.1, 4.8.2, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_szibmtfv117b`: Enum Types

_File: types-and-traits.rst, Line: 611_

**Legality Rules:**

- An enum type is an abstract data type that contains enum variants.
- A zero-variant enum type has no values.
- An enum variant is a construct that declares one of the possible variations of an enum.
- The name of an enum variant shall be unique within the related EnumDeclaration.
- A discriminant is an opaque integer that identifies an enum variant.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is a validity invariant for a value of an enum type to have a discriminant specified by the enum type.

#### `fls_xc1hof4qbf6p`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_85vx1qfa061i`: Traits

_File: types-and-traits.rst, Line: 2705_

**Legality Rules:**

- A trait is an item that describes an interface a type can implement.
- A trait body is a construct that encapsulates the associated items, inner attributes, and inner doc comments of a trait.
- Within a trait, the type :c:`Self` acts as a placeholder for a type implementing the trait, and behaves like a type parameter.
- A local trait is a trait that is defined in the current crate.
- A subtrait is a trait with a supertrait.
- _... and 9 more paragraphs_

**Examples:**

- Shape is a supertrait of Circle.
- Circle is a subtrait of Shape.

#### `fls_4ikc07mfrez5`: Object Safety

_File: types-and-traits.rst, Line: 2829_

**Legality Rules:**

- A trait is object safe when:
- An associated function is object safe when it is either an object safe dispatchable function or an object safe non-dispatchable function.
- A dispatchable function is object safe when:
- A function is object safe when it specifies a core::marker::Sized [trait bound] for :c:`Self` in a type bound predicate.

#### `fls_jeoas4n6su4`: Trait and Lifetime Bounds

_File: types-and-traits.rst, Line: 2882_

**Legality Rules:**

- A bound imposes a constraint on a generic parameter by limiting the set of possible generic substitutions.
- A bound does not impose a constraint on a generic parameter of a type alias unless it is an associated item.
- A lifetime bound is a bound that imposes a constraint on the lifetimes of generic parameters.
- A trait bound is a bound that imposes a constraint on the traits of generic parameters.
- A ForGenericParameterList shall not specify ConstantParameters or TypeParameters.
- _... and 10 more paragraphs_

#### `fls_1ompd93w7c9f`: Trait Types

_File: types-and-traits.rst, Line: 1103_

#### `fls_3xqobbu7wfsf`: Impl Trait Types

_File: types-and-traits.rst, Line: 1108_

**Legality Rules:**

- An impl trait type is a type that implements a trait, where the type is known at compile time.
- An impl trait type shall appear only within a function parameter or the return type of a function.
- An anonymous return type is an impl trait type ascribed to a function return type.
- An anonymous return type behaves as if it contained all declared type parameters of the return type's function and its parent trait or implementation.
- An anonymous return type derived from an async function behaves as if it contained all declared type parameters and lifetime parameters of the return type's function and its parent trait or implementation.
- _... and 4 more paragraphs_

#### `fls_qa98qdi42orq`: Trait Object Types

_File: types-and-traits.rst, Line: 1179_

**Legality Rules:**

- A trait object type is a type that implements a trait, where the type is not known at compile time.
- The principal trait of trait object type is the first trait bound.
- The principal trait shall denote an object safe trait.
- All non-principal trait trait bounds shall denote auto traits.
- A trait object type shall not contain opt-out trait bounds.
- _... and 2 more paragraphs_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.13

**Type:** rule
**Title:** A pointer should point to a const-qualified type whenever possible

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust uses mut/immutable references; volatile via std::ptr::read/write_volatile (unsafe)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_66m4rnbssgig` | 6.1.2 | Constant Expressions |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.12.5, 6.1.2, 6.2, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_66m4rnbssgig`: Constant Expressions

_File: expressions.rst, Line: 155_

**Legality Rules:**

- A constant expression is an expression that can be evaluated statically. The following constructs are constant expressions as long as their operands are also constant expressions and do not involve types that require destruction:
- An expression is not considered a constant expression when it explicitly invokes an associated trait function or uses arithmetic operators of non-builtin types that invoke core::ops traits.
- It is a static error if the size operand of an array repetition constructor or an array type depends on generic parameters.
- A constant context is a construct that requires a constant expression. The following constructs are constant contexts:
- An invocation of the core::ptr::addr_of macro expands to a constant expression allowed in any constant context and constant function, subject to the same restrictions as a immutable borrow expression.
- _... and 5 more paragraphs_

**Dynamic Semantics:**

- The invocation of a constant function follows the dynamic semantics of a non-[constant function] invocation.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.14

**Type:** rule
**Title:** The restrict type qualifier shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust uses mut/immutable references; volatile via std::ptr::read/write_volatile (unsafe); Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.7.3, 4.12.5, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types
- `fls_3xqobbu7wfsf` → 4.8.1 Impl Trait Types
- `fls_dw33yt5g6m0k` → 4.12.3 Type Coercion
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_mcxF9y5u66sZ` → ? Visible Emptiness
- `fls_lv7w7aalpwm5` → 4.12.7 Type Inference

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.16

**Type:** rule
**Title:** The alignment specification of zero should not appear in an object

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | cannot be explicitly specified. Only ZSTs have this alignment |
| confidence | `medium` |

**Notes:** MISRA ADD-6: cannot be explicitly specified. Only ZSTs have this alignment. Rust has #[repr(align(N))] and std::mem::align_of; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.11.1, 4.11, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_kgvleup5mdhq` → 4.10 Type Aliases
- `fls_ohhsmifo0urd` → 4.11.2 Type Representation
- `fls_j02707n615z0` → 4.12 Type Model
- `fls_olbj67eyxz2k` → 4.9.4 Parenthesized Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.17

**Type:** rule
**Title:** At most one explicit alignment specifier should appear in an object

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has #[repr(align(N))] and std::mem::align_of

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.11.1, 4.11, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.18

**Type:** rule
**Title:** There shall be no tentative definitions in a header file

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust uses pub visibility and modules instead of linkage; Rust uses std::io and std::fs; different API design

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 14.2, 14.4.3, 14.7, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_gdeyap4or1db` → 14 Entities and Resolution
- `fls_151r19d7xbgz` → 14.1 Entities
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_izl8iuhoz9e0` → 14.4 Scopes
- `fls_6ozthochxz1i` → 14.4.1 Binding Scopes
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope
- `fls_769b4p8v3cwu` → 14.4.4 Label Scope
- `fls_kgbi26212eof` → 14.4.5 Self Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 8.19

**Type:** rule
**Title:** There should be no external declarations in a source file

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust uses pub visibility and modules instead of linkage

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uloyjbaso8pz` | 5.1.4 | Path Patterns |
| `fls_yztwtek0y34v` | 21.3 | External Functions |
| `fls_tmoh3y9oyqsy` | 21.2 | External Blocks |
| `fls_pgp7ezcc9lh8` | 13.2.6 | Foreign Function Interface Attributes |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 21, 21.1, 21.2, 13.2.6, 15.1, 15.8, 15.8.1

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uloyjbaso8pz`: Path Patterns

_File: patterns.rst, Line: 342_

**Legality Rules:**

- A path pattern is a pattern that matches a constant, a unit enum variant, or a unit struct constant indicated by a path.
- A path pattern expressed as a path expression shall refer to either an associated constant, or a constant.
- When a path pattern refers to an associated constant or a constant, the associated constant or constant shall not be of a union type.
- When a path pattern refers to an associated constant or a constant, the type of the associated constant or constant shall be structurally equal.
- When a path pattern refers to an associated constant or a constant, the constant must not contain any references to mutable statics, statics with interior mutability, or external statics.
- _... and 4 more paragraphs_

**Examples:**

- See :p:`fls_sfyfdxhvhk44` for the declaration of ``x``.

#### `fls_yztwtek0y34v`: External Functions

_File: ffi.rst, Line: 212_

**Legality Rules:**

- An external function is an unchecked import of a foreign function.
- An external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to ItemSafety with keyword ``safe``.
- An external function shall not specify a FunctionQualifierList.
- An external function inherits the ABI of its enclosing external block.
- An external function shall not specify a GenericParameterList containing constant parameters or type parameters.
- _... and 3 more paragraphs_

#### `fls_tmoh3y9oyqsy`: External Blocks

_File: ffi.rst, Line: 155_

**Legality Rules:**

- An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.
- An unsafe external block is an external block subject to keyword ``unsafe``.
- The ABI of an external block is determined as follows:

#### `fls_pgp7ezcc9lh8`: Foreign Function Interface Attributes

_File: attributes.rst, Line: 1118_

**Legality Rules:**

- Attribute :c:`crate_name` shall apply to the crate root module.
- Attribute :dc:`crate_name` shall specify the name of the related crate.
- Attribute :c:`crate_type` shall apply to the crate root module.
- Attribute :dc:`crate_type` shall specify the linkage type of the crate it appears in.
- Attribute :c:`export_name` shall apply to functions and statics.
- _... and 33 more paragraphs_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 9.1

**Type:** rule
**Title:** The value of an object with automatic storage duration shall not be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| misra_rust_comment | enforced by rustc but can be bypassed by unsafe |
| confidence | `medium` |

**Notes:** MISRA ADD-6: enforced by rustc but can be bypassed by unsafe. Rust unions require unsafe to read; safe Rust should use enums for tagged unions; Rust has ownership-based lifetimes and static/const items

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |

**FLS Sections:** 4.5.3, 4.11.2.3, 19, 19.-2.7, 15.1, 15.8, 15.8.1, 15.2, 6.4.4

### FLS Content

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_szibmtfv117b` → 4.5.1 Enum Types
- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_hbbek3z4wtcs` → 4.6 Function Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 9.2

**Type:** rule
**Title:** The initializer for an aggregate or union shall be enclosed in braces

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust requires initialization before use; unsafe can use MaybeUninit; Rust unions require unsafe to read; safe Rust should use enums for tagged unions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_3ra8s1v1vbek` | 19.-2.5 | External Static Access |
| `fls_6ipl0xo5qjyl` | 19.-2.6 | Mutable Static Access |
| `fls_ljocmnaz2m49` | 19.-2.8 | Unsafe Function Call |
| `fls_jb6krd90tjmc` | 19.-2.9 | Unsafe Context |
| `fls_ybnpe7ppq1vh` | 19.-2.10 | Unsafe Operation Requirement |

**FLS Sections:** 15.2, 15.1, 6.4.4, 19, 4.5.3, 4.11.2.3, 19.-2.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 17, 17.1, 17.2, 19.-2.1, 19.-2.2, 19.-2.3, 19.-2.4, 19.-2.5, 19.-2.6, 19.-2.8, 19.-2.9, 19.-2.10

### FLS Content

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_3ra8s1v1vbek`: _(not found in RST source)_

#### `fls_6ipl0xo5qjyl`: _(not found in RST source)_

#### `fls_ljocmnaz2m49`: _(not found in RST source)_

#### `fls_jb6krd90tjmc`: _(not found in RST source)_

#### `fls_ybnpe7ppq1vh`: _(not found in RST source)_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ronnwodjjjsh` → 15 Ownership and Destruction
- `fls_v5x85lt5ulva` → 15.3 References
- `fls_a14slch83hzn` → 15.4 Borrowing

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 9.3

**Type:** rule
**Title:** Arrays shall not be partially initialized

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Safe Rust requires initialization before use; unsafe can use MaybeUninit

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |

**FLS Sections:** 4.4.1, 4.4.2, 6.8.1, 6.8.2, 15.2, 15.1, 6.4.4, 19

### FLS Content

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qwljwqr07slp` → 4.3.3 Numeric Types
- `fls_fbchw64p6n2x` → 4.4 Sequence Types
- `fls_4agmmu5al6gt` → 4.4.3 Str Type
- `fls_4ckl3n2ko3i4` → 4.4.4 Tuple Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 9.4

**Type:** rule
**Title:** An element of an object shall not be initialized more than once

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| misra_rust_comment | enforced by rustc |
| confidence | `medium` |

**Notes:** MISRA ADD-6: enforced by rustc. Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Safe Rust requires initialization before use; unsafe can use MaybeUninit

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |

**FLS Sections:** 4.4.1, 4.4.2, 6.8.1, 6.8.2, 15.2, 15.1, 6.4.4, 19

### FLS Content

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qwljwqr07slp` → 4.3.3 Numeric Types
- `fls_fbchw64p6n2x` → 4.4 Sequence Types
- `fls_4agmmu5al6gt` → 4.4.3 Str Type
- `fls_4ckl3n2ko3i4` → 4.4.4 Tuple Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 9.5

**Type:** rule
**Title:** Required Where designated initializers are used to initialize an array object the

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Safe Rust requires initialization before use; unsafe can use MaybeUninit

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_85vx1qfa061i` | 4.13 | Traits |
| `fls_4ikc07mfrez5` | 4.13.1 | Object Safety |
| `fls_jeoas4n6su4` | 4.14 | Trait and Lifetime Bounds |
| `fls_1ompd93w7c9f` | 4.8 | Trait Types |
| `fls_3xqobbu7wfsf` | 4.8.1 | Impl Trait Types |
| `fls_qa98qdi42orq` | 4.8.2 | Trait Object Types |

**FLS Sections:** 4.4.1, 4.4.2, 6.8.1, 6.8.2, 15.2, 15.1, 6.4.4, 19, 4.13, 4.13.1, 4.14, 4.8, 4.8.1, 4.8.2

### FLS Content

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_85vx1qfa061i`: Traits

_File: types-and-traits.rst, Line: 2705_

**Legality Rules:**

- A trait is an item that describes an interface a type can implement.
- A trait body is a construct that encapsulates the associated items, inner attributes, and inner doc comments of a trait.
- Within a trait, the type :c:`Self` acts as a placeholder for a type implementing the trait, and behaves like a type parameter.
- A local trait is a trait that is defined in the current crate.
- A subtrait is a trait with a supertrait.
- _... and 9 more paragraphs_

**Examples:**

- Shape is a supertrait of Circle.
- Circle is a subtrait of Shape.

#### `fls_4ikc07mfrez5`: Object Safety

_File: types-and-traits.rst, Line: 2829_

**Legality Rules:**

- A trait is object safe when:
- An associated function is object safe when it is either an object safe dispatchable function or an object safe non-dispatchable function.
- A dispatchable function is object safe when:
- A function is object safe when it specifies a core::marker::Sized [trait bound] for :c:`Self` in a type bound predicate.

#### `fls_jeoas4n6su4`: Trait and Lifetime Bounds

_File: types-and-traits.rst, Line: 2882_

**Legality Rules:**

- A bound imposes a constraint on a generic parameter by limiting the set of possible generic substitutions.
- A bound does not impose a constraint on a generic parameter of a type alias unless it is an associated item.
- A lifetime bound is a bound that imposes a constraint on the lifetimes of generic parameters.
- A trait bound is a bound that imposes a constraint on the traits of generic parameters.
- A ForGenericParameterList shall not specify ConstantParameters or TypeParameters.
- _... and 10 more paragraphs_

#### `fls_1ompd93w7c9f`: Trait Types

_File: types-and-traits.rst, Line: 1103_

#### `fls_3xqobbu7wfsf`: Impl Trait Types

_File: types-and-traits.rst, Line: 1108_

**Legality Rules:**

- An impl trait type is a type that implements a trait, where the type is known at compile time.
- An impl trait type shall appear only within a function parameter or the return type of a function.
- An anonymous return type is an impl trait type ascribed to a function return type.
- An anonymous return type behaves as if it contained all declared type parameters of the return type's function and its parent trait or implementation.
- An anonymous return type derived from an async function behaves as if it contained all declared type parameters and lifetime parameters of the return type's function and its parent trait or implementation.
- _... and 4 more paragraphs_

#### `fls_qa98qdi42orq`: Trait Object Types

_File: types-and-traits.rst, Line: 1179_

**Legality Rules:**

- A trait object type is a type that implements a trait, where the type is not known at compile time.
- The principal trait of trait object type is the first trait bound.
- The principal trait shall denote an object safe trait.
- All non-principal trait trait bounds shall denote auto traits.
- A trait object type shall not contain opt-out trait bounds.
- _... and 2 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qwljwqr07slp` → 4.3.3 Numeric Types
- `fls_fbchw64p6n2x` → 4.4 Sequence Types
- `fls_4agmmu5al6gt` → 4.4.3 Str Type
- `fls_4ckl3n2ko3i4` → 4.4.4 Tuple Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 9.6

**Type:** rule
**Title:** Section 5: Rules

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust requires initialization before use; unsafe can use MaybeUninit

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |

**FLS Sections:** 15.2, 15.1, 6.4.4, 19

### FLS Content

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ronnwodjjjsh` → 15 Ownership and Destruction
- `fls_v5x85lt5ulva` → 15.3 References
- `fls_a14slch83hzn` → 15.4 Borrowing

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 9.7

**Type:** rule
**Title:** Atomic objects shall be appropriately initialized before being accessed

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust requires initialization before use; unsafe can use MaybeUninit; Rust has std::sync::atomic with similar memory ordering. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |

**FLS Sections:** 15.2, 15.1, 6.4.4, 19, 17.2, 17.1

### FLS Content

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ronnwodjjjsh` → 15 Ownership and Destruction
- `fls_v5x85lt5ulva` → 15.3 References
- `fls_a14slch83hzn` → 15.4 Borrowing

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 10.1

**Type:** rule
**Title:** Operands shall not be of an inappropriate essential type

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 10.2

**Type:** rule
**Title:** Expressions of essentially character type shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |

**FLS Sections:** 6, 6.1, 6.5, 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 10.4

**Type:** rule
**Title:** Both operands of an operator in which the usual arithmetic

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 10.5

**Type:** rule
**Title:** The value of an expression should not be cast to an inappropriate

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `recommended` |
| misra_rust_comment | includes both safe `as` and unsafe `transmute` operations |
| confidence | `medium` |

**Notes:** MISRA ADD-6: includes both safe `as` and unsafe `transmute` operations. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 6, 6.1, 6.5, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 10.6

**Type:** rule
**Title:** The value of a composite expression shall not be assigned to an object

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 6, 6.1, 6.5, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 10.7

**Type:** rule
**Title:** If a composite expression is used as one operand of an operator in

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 6, 6.1, 6.5, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 10.8

**Type:** rule
**Title:** The value of a composite expression shall not be cast to a different

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `advisory` |
| misra_rust_comment | includes both safe `as` and unsafe `transmute` operations |
| confidence | `medium` |

**Notes:** MISRA ADD-6: includes both safe `as` and unsafe `transmute` operations. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 6, 6.1, 6.5, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.1

**Type:** rule
**Title:** Conversions shall not be performed between a pointer to a function

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| misra_rust_comment | includes both safe `as` and unsafe `transmute` operations |
| confidence | `medium` |

**Notes:** MISRA ADD-6: includes both safe `as` and unsafe `transmute` operations. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.2

**Type:** rule
**Title:** Conversions shall not be performed between a pointer to an

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.3

**Type:** rule
**Title:** Required A conversion shall not be performed between a pointer to object type

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.4

**Type:** rule
**Title:** A conversion shall not be performed between a pointer to object and

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.6

**Type:** rule
**Title:** A cast shall not be performed between pointer to void and an

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.7

**Type:** rule
**Title:** Combined with Rule 11.4 MISRA C:2025

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | merged into Rule 11.4 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: merged into Rule 11.4. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.9

**Type:** rule
**Title:** The macro NULL shall be the only permitted form of integer null

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | Rust does not have a null pointer constant |
| confidence | `medium` |

**Notes:** MISRA ADD-6: Rust does not have a null pointer constant. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_szibmtfv117b` | 4.5.1 | Enum Types |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 4.5.1, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_szibmtfv117b`: Enum Types

_File: types-and-traits.rst, Line: 611_

**Legality Rules:**

- An enum type is an abstract data type that contains enum variants.
- A zero-variant enum type has no values.
- An enum variant is a construct that declares one of the possible variations of an enum.
- The name of an enum variant shall be unique within the related EnumDeclaration.
- A discriminant is an opaque integer that identifies an enum variant.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is a validity invariant for a value of an enum type to have a discriminant specified by the enum type.

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.10

**Type:** rule
**Title:** Required The _Atomic qualifier shall not be applied to the incomplete type void

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has std::sync::atomic with similar memory ordering; Rust uses mut/immutable references; volatile via std::ptr::read/write_volatile (unsafe)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |

**FLS Sections:** 17.2, 17.1, 4.7.3, 4.12.5, 4.7, 4.7.2, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7

### FLS Content

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3v733mnewssy` → 17 Concurrency
- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 11.11

**Type:** rule
**Title:** Required Pointers shall not be implicitly compared to NULL

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `rust_prevents` |
| applicability_safe_rust | `rust_prevents` |
| misra_rust_category | `implicit` |
| misra_rust_comment | enforced by rustc |
| confidence | `medium` |

**Notes:** MISRA ADD-6: enforced by rustc. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_85vx1qfa061i` | 4.13 | Traits |
| `fls_4ikc07mfrez5` | 4.13.1 | Object Safety |
| `fls_jeoas4n6su4` | 4.14 | Trait and Lifetime Bounds |
| `fls_1ompd93w7c9f` | 4.8 | Trait Types |
| `fls_3xqobbu7wfsf` | 4.8.1 | Impl Trait Types |
| `fls_qa98qdi42orq` | 4.8.2 | Trait Object Types |
| `fls_szibmtfv117b` | 4.5.1 | Enum Types |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.13, 4.13.1, 4.14, 4.8, 4.8.1, 4.8.2, 4.5.1

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_85vx1qfa061i`: Traits

_File: types-and-traits.rst, Line: 2705_

**Legality Rules:**

- A trait is an item that describes an interface a type can implement.
- A trait body is a construct that encapsulates the associated items, inner attributes, and inner doc comments of a trait.
- Within a trait, the type :c:`Self` acts as a placeholder for a type implementing the trait, and behaves like a type parameter.
- A local trait is a trait that is defined in the current crate.
- A subtrait is a trait with a supertrait.
- _... and 9 more paragraphs_

**Examples:**

- Shape is a supertrait of Circle.
- Circle is a subtrait of Shape.

#### `fls_4ikc07mfrez5`: Object Safety

_File: types-and-traits.rst, Line: 2829_

**Legality Rules:**

- A trait is object safe when:
- An associated function is object safe when it is either an object safe dispatchable function or an object safe non-dispatchable function.
- A dispatchable function is object safe when:
- A function is object safe when it specifies a core::marker::Sized [trait bound] for :c:`Self` in a type bound predicate.

#### `fls_jeoas4n6su4`: Trait and Lifetime Bounds

_File: types-and-traits.rst, Line: 2882_

**Legality Rules:**

- A bound imposes a constraint on a generic parameter by limiting the set of possible generic substitutions.
- A bound does not impose a constraint on a generic parameter of a type alias unless it is an associated item.
- A lifetime bound is a bound that imposes a constraint on the lifetimes of generic parameters.
- A trait bound is a bound that imposes a constraint on the traits of generic parameters.
- A ForGenericParameterList shall not specify ConstantParameters or TypeParameters.
- _... and 10 more paragraphs_

#### `fls_1ompd93w7c9f`: Trait Types

_File: types-and-traits.rst, Line: 1103_

#### `fls_3xqobbu7wfsf`: Impl Trait Types

_File: types-and-traits.rst, Line: 1108_

**Legality Rules:**

- An impl trait type is a type that implements a trait, where the type is known at compile time.
- An impl trait type shall appear only within a function parameter or the return type of a function.
- An anonymous return type is an impl trait type ascribed to a function return type.
- An anonymous return type behaves as if it contained all declared type parameters of the return type's function and its parent trait or implementation.
- An anonymous return type derived from an async function behaves as if it contained all declared type parameters and lifetime parameters of the return type's function and its parent trait or implementation.
- _... and 4 more paragraphs_

#### `fls_qa98qdi42orq`: Trait Object Types

_File: types-and-traits.rst, Line: 1179_

**Legality Rules:**

- A trait object type is a type that implements a trait, where the type is not known at compile time.
- The principal trait of trait object type is the first trait bound.
- The principal trait shall denote an object safe trait.
- All non-principal trait trait bounds shall denote auto traits.
- A trait object type shall not contain opt-out trait bounds.
- _... and 2 more paragraphs_

#### `fls_szibmtfv117b`: Enum Types

_File: types-and-traits.rst, Line: 611_

**Legality Rules:**

- An enum type is an abstract data type that contains enum variants.
- A zero-variant enum type has no values.
- An enum variant is a construct that declares one of the possible variations of an enum.
- The name of an enum variant shall be unique within the related EnumDeclaration.
- A discriminant is an opaque integer that identifies an enum variant.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is a validity invariant for a value of an enum type to have a discriminant specified by the enum type.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 12.1

**Type:** rule
**Title:** The precedence of operators within expressions should be made

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6, 6.1, 6.5

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 12.2

**Type:** rule
**Title:** The right hand operand of a shift operator shall lie in the range zero

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6, 6.1, 6.5

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 12.3

**Type:** rule
**Title:** The comma operator should not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6, 6.1, 6.5

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 12.4

**Type:** rule
**Title:** Evaluation of constant expressions should not lead to unsigned integer

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `advisory` |
| misra_rust_comment | this is either well-defined or will not occur |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this is either well-defined or will not occur. Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust has well-defined evaluation order in most cases. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_nrkd5wpi64oo` | 2.4 | Literals |
| `fls_hv9jtycp0o1y` | 2.4.4 | Numeric Literals |
| `fls_2ed4axpsy9u0` | 2.4.4.1 | Integer Literals |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_jkab8eevzbte` | 2.4.7 | Boolean Literals |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_66m4rnbssgig` | 6.1.2 | Constant Expressions |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 6, 6.1, 6.5, 2.4, 2.4.4, 2.4.4.1, 2.4.4.2, 2.4.7, 6.2, 4.7.3, 4.12.5, 6.1.2

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_nrkd5wpi64oo`: Literals

_File: lexical-elements.rst, Line: 539_

**Legality Rules:**

- A literal is a fixed value in program text.

#### `fls_hv9jtycp0o1y`: Numeric Literals

_File: lexical-elements.rst, Line: 817_

**Legality Rules:**

- A numeric literal is a literal that denotes a number.
- An integer literal is a numeric literal that denotes a whole number.
- A binary literal is an integer literal in base 2.
- A decimal literal is an integer literal in base 10.
- A hexadecimal literal is an integer literal in base 16.
- _... and 12 more paragraphs_

#### `fls_2ed4axpsy9u0`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_jkab8eevzbte`: Boolean Literals

_File: lexical-elements.rst, Line: 1253_

**Legality Rules:**

- A boolean literal is a literal that denotes the truth values of logic and Boolean algebra.
- The type of a boolean literal is :c:`bool`.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_66m4rnbssgig`: Constant Expressions

_File: expressions.rst, Line: 155_

**Legality Rules:**

- A constant expression is an expression that can be evaluated statically. The following constructs are constant expressions as long as their operands are also constant expressions and do not involve types that require destruction:
- An expression is not considered a constant expression when it explicitly invokes an associated trait function or uses arithmetic operators of non-builtin types that invoke core::ops traits.
- It is a static error if the size operand of an array repetition constructor or an array type depends on generic parameters.
- A constant context is a construct that requires a constant expression. The following constructs are constant contexts:
- An invocation of the core::ptr::addr_of macro expands to a constant expression allowed in any constant context and constant function, subject to the same restrictions as a immutable borrow expression.
- _... and 5 more paragraphs_

**Dynamic Semantics:**

- The invocation of a constant function follows the dynamic semantics of a non-[constant function] invocation.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 12.5

**Type:** rule
**Title:** The sizeof operator shall not have an operand which is a function

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust has std::mem::size_of

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 4.11.1, 4.11, 6, 6.1, 6.5

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 12.6

**Type:** rule
**Title:** Structure and union members of atomic objects shall not be directly

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar struct semantics; Rust unions require unsafe to read; safe Rust should use enums for tagged unions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_3ra8s1v1vbek` | 19.-2.5 | External Static Access |
| `fls_6ipl0xo5qjyl` | 19.-2.6 | Mutable Static Access |
| `fls_ljocmnaz2m49` | 19.-2.8 | Unsafe Function Call |
| `fls_jb6krd90tjmc` | 19.-2.9 | Unsafe Context |
| `fls_ybnpe7ppq1vh` | 19.-2.10 | Unsafe Operation Requirement |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 4.5.2, 4.11.2.2, 4.11, 4.11.1, 4.5.3, 4.11.2.3, 19, 19.-2.7, 17.2, 17.1, 19.-2.1, 19.-2.2, 19.-2.3, 19.-2.4, 19.-2.5, 19.-2.6, 19.-2.8, 19.-2.9, 19.-2.10, 6.4.4, 6, 6.1, 6.5

### FLS Content

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_3ra8s1v1vbek`: _(not found in RST source)_

#### `fls_6ipl0xo5qjyl`: _(not found in RST source)_

#### `fls_ljocmnaz2m49`: _(not found in RST source)_

#### `fls_jb6krd90tjmc`: _(not found in RST source)_

#### `fls_ybnpe7ppq1vh`: _(not found in RST source)_

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_wdec78luqh5b` → 4.5 Abstract Data Types
- `fls_szibmtfv117b` → 4.5.1 Enum Types
- `fls_hbbek3z4wtcs` → 4.6 Function Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 13.1

**Type:** rule
**Title:** Initializer lists shall not contain persistent side effects

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| misra_rust_comment | order of evaluation is strict in Rust |
| confidence | `medium` |

**Notes:** MISRA ADD-6: order of evaluation is strict in Rust. Safe Rust requires initialization before use; unsafe can use MaybeUninit; Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 15.2, 15.1, 6.4.4, 19, 6, 6.1, 6.5

### FLS Content

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ronnwodjjjsh` → 15 Ownership and Destruction
- `fls_v5x85lt5ulva` → 15.3 References
- `fls_a14slch83hzn` → 15.4 Borrowing

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 13.3

**Type:** rule
**Title:** A full expression containing an increment (++) or decrement (--)

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6, 6.1, 6.5

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 13.4

**Type:** rule
**Title:** Advisory The result of an assignment operator should not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust uses Result<T, E> type instead of errno; Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 16, 16.1, 16.2, 6.5.3, 6, 6.1, 6.5

### FLS Content

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 13.5

**Type:** rule
**Title:** Required The right hand operand of a logical && or || operator shall not contain

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6, 6.1, 6.5

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 13.6

**Type:** rule
**Title:** The operand of the sizeof operator shall not contain any expression

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | this is not an expression operator in Rust |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this is not an expression operator in Rust. Rust has well-defined evaluation order in most cases; Rust has std::mem::size_of

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_7pby13muw48o` | 4.11 | Representation |

**FLS Sections:** 6, 6.1, 6.5, 4.11.1, 4.11

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 14.1

**Type:** rule
**Title:** A loop counter shall not have essentially floating type

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| misra_rust_comment | applies to while loops only |
| confidence | `medium` |

**Notes:** MISRA ADD-6: applies to while loops only. Rust has similar floating point semantics to C (IEEE 754); Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_b4xporvr64s` | 4.3.3.1 | Floating Point Types |
| `fls_29tlg1vyqay2` | 2.4.4.2 | Float Literals |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |

**FLS Sections:** 4.3.3.1, 2.4.4.2, 6.5.5, 6.5.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14

### FLS Content

#### `fls_b4xporvr64s`: _(not found in RST source)_

#### `fls_29tlg1vyqay2`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 14.3

**Type:** rule
**Title:** Controlling expressions shall not be invariant

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust unions require unsafe to read; safe Rust should use enums for tagged unions; Rust enums are more powerful (algebraic data types)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_szibmtfv117b` | 4.5.1 | Enum Types |
| `fls_xc1hof4qbf6p` | 4.11.2.1 | Enum Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |

**FLS Sections:** 4.5.3, 4.11.2.3, 19, 19.-2.7, 4.5.1, 4.11.2.1, 4.11, 6, 6.1, 6.5, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14

### FLS Content

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_szibmtfv117b`: Enum Types

_File: types-and-traits.rst, Line: 611_

**Legality Rules:**

- An enum type is an abstract data type that contains enum variants.
- A zero-variant enum type has no values.
- An enum variant is a construct that declares one of the possible variations of an enum.
- The name of an enum variant shall be unique within the related EnumDeclaration.
- A discriminant is an opaque integer that identifies an enum variant.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is a validity invariant for a value of an enum type to have a discriminant specified by the enum type.

#### `fls_xc1hof4qbf6p`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_hbbek3z4wtcs` → 4.6 Function Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 14.4

**Type:** rule
**Title:** The controlling expression of an if statement and the controlling

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `rust_prevents` |
| applicability_safe_rust | `rust_prevents` |
| misra_rust_category | `implicit` |
| misra_rust_comment | enforced by rustc |
| confidence | `medium` |

**Notes:** MISRA ADD-6: enforced by rustc. Rust has similar control flow with expressions; Rust has well-defined evaluation order in most cases

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 6, 6.1, 6.5

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 15.1

**Type:** rule
**Title:** The goto statement should not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no goto; uses labeled loops for complex control flow; Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |

**FLS Sections:** 14.4.4, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14

### FLS Content

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope
- `fls_m0z7omni9hp0` → 14.4.3 Item Scope
- `fls_kgbi26212eof` → 14.4.5 Self Scope
- `fls_octf6sf7yso` → 14.4.6 Textual Macro Scope
- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 15.2

**Type:** rule
**Title:** The goto statement shall jump to a label declared later in the same

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no goto; uses labeled loops for complex control flow; Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |

**FLS Sections:** 14.4.4, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14

### FLS Content

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope
- `fls_m0z7omni9hp0` → 14.4.3 Item Scope
- `fls_kgbi26212eof` → 14.4.5 Self Scope
- `fls_octf6sf7yso` → 14.4.6 Textual Macro Scope
- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 15.3

**Type:** rule
**Title:** Any label referenced by a goto statement shall be declared in the

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Core Rust concept for safe memory access, applies to all Rust; Rust has no goto; uses labeled loops for complex control flow

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |

**FLS Sections:** 4.7.3, 15.3, 15.4, 6.5.1, 6.5.2, 14.4.4, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14

### FLS Content

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types
- `fls_3xqobbu7wfsf` → 4.8.1 Impl Trait Types
- `fls_svkx6szhr472` → 15.1 Ownership
- `fls_3xvm61x0t251` → 15.2 Initialization
- `fls_77scxuomlbgs` → 15.5 Passing Conventions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 15.4

**Type:** rule
**Title:** There should be no more than one break or goto statement used to

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust has no goto; uses labeled loops for complex control flow

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 14.4.4

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 15.5

**Type:** rule
**Title:** A function should have a single point of exit at the end

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `disapplied` |
| misra_rust_comment | no longer endorsed by MISRA |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no longer endorsed by MISRA. Similar function semantics with stronger type checking; Rust has panic! and abort for abnormal termination

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 16.1, 16.2, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 14.4.4

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 15.6

**Type:** rule
**Title:** Required The body of an iteration-statement or a selection-statement shall be a

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust has no goto; uses labeled loops for complex control flow

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 14.4.4

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 15.7

**Type:** rule
**Title:** All if … else if constructs shall be terminated with an else statement

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `advisory` |
| confidence | `medium` |

**Notes:** Rust has similar struct semantics; Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_omaq7psg83n3` | 4.12.5 | Interior Mutability |
| `fls_66m4rnbssgig` | 6.1.2 | Constant Expressions |
| `fls_h0dvogc64tfh` | 6.2 | Literal Expressions |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |

**FLS Sections:** 4.5.2, 4.11.2.2, 4.11, 4.11.1, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 16.1, 16.2, 4.7.3, 4.12.5, 6.1.2, 6.2, 14.4.4

### FLS Content

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_omaq7psg83n3`: Interior Mutability

_File: types-and-traits.rst, Line: 2194_

**Legality Rules:**

- Interior mutability is a property of types whose values can be modified through immutable references.
- A type is subject to interior mutability when it contains a core::cell::UnsafeCell.

#### `fls_66m4rnbssgig`: Constant Expressions

_File: expressions.rst, Line: 155_

**Legality Rules:**

- A constant expression is an expression that can be evaluated statically. The following constructs are constant expressions as long as their operands are also constant expressions and do not involve types that require destruction:
- An expression is not considered a constant expression when it explicitly invokes an associated trait function or uses arithmetic operators of non-builtin types that invoke core::ops traits.
- It is a static error if the size operand of an array repetition constructor or an array type depends on generic parameters.
- A constant context is a construct that requires a constant expression. The following constructs are constant contexts:
- An invocation of the core::ptr::addr_of macro expands to a constant expression allowed in any constant context and constant function, subject to the same restrictions as a immutable borrow expression.
- _... and 5 more paragraphs_

**Dynamic Semantics:**

- The invocation of a constant function follows the dynamic semantics of a non-[constant function] invocation.

#### `fls_h0dvogc64tfh`: Literal Expressions

_File: expressions.rst, Line: 567_

**Legality Rules:**

- A literal expression is an expression that denotes a literal.
- The type of a literal expression is the type of the corresponding literal.
- The value of a literal expression is the value of the corresponding literal.

**Dynamic Semantics:**

- The evaluation of a literal expression has no effect.

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_wdec78luqh5b` → 4.5 Abstract Data Types
- `fls_szibmtfv117b` → 4.5.1 Enum Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_hbbek3z4wtcs` → 4.6 Function Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 16.1

**Type:** rule
**Title:** All switch statements shall be well-formed

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 5.4.5, 5.2

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 16.2

**Type:** rule
**Title:** A switch label shall only be used when the most closely-enclosing

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust has no goto; uses labeled loops for complex control flow

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 14.4.4, 5.4.5, 5.2

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 16.3

**Type:** rule
**Title:** Every switch-clause shall be appropriately terminated

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 5.4.5, 5.2, 16.1, 16.2

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 16.4

**Type:** rule
**Title:** Section 5: Rules

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | a corresponding match expression must be complete |
| confidence | `medium` |

**Notes:** MISRA ADD-6: a corresponding match expression must be complete. Rust match is exhaustive and more powerful than C switch

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |

**FLS Sections:** 6.14, 5.4.5, 5.2

### FLS Content

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mkut7gut49gi` → 6.17.1 If Expressions
- `fls_p0t1ch115tra` → 6.17.2 If Let Expressions
- `fls_8l74abhlxzdl` → 6.19 Return Expressions
- `fls_hyrbmfmf6r8g` → 6.20 Await Expressions
- `fls_5loglxds6zik` → 5.4.3 Parenthesized Pattern Matching
- `fls_d44aflefat88` → 5.4.4 Path Pattern Matching
- `fls_org6hqv397fp` → 5.4.6 Reference Pattern Matching
- `fls_57ic33pwdvp3` → 5.4.7 Slice Pattern Matching

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 16.5

**Type:** rule
**Title:** A default label shall appear as either the first or the last switch label of

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | irrefutable pattern causes a subsequent refutable one to be unreachable |
| confidence | `medium` |

**Notes:** MISRA ADD-6: irrefutable pattern causes a subsequent refutable one to be unreachable. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has similar control flow with expressions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_769b4p8v3cwu` | 14.4.4 | Label Scope |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 14.4.4, 5.4.5, 5.2

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_769b4p8v3cwu`: Label Scope

_File: entities-and-resolution.rst, Line: 578_

**Legality Rules:**

- A label scope is a scope for labels.
- A label is in scope within the block expression of the related loop expression.
- A label is not in scope within nested async blocks, closure expressions, constant contexts, and items.

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 16.6

**Type:** rule
**Title:** Every switch statement shall have at least two switch-clauses

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 5.4.5, 5.2

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 16.7

**Type:** rule
**Title:** A switch-expression shall not have essentially Boolean type

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust match is exhaustive and more powerful than C switch

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 5.4.5, 5.2, 6, 6.1, 6.5

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.1

**Type:** rule
**Title:** The standard header file <stdarg.h> shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style variadic functions; use generics or extern for FFI; Rust uses std::io and std::fs; different API design

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.2

**Type:** rule
**Title:** Functions shall not call themselves, either directly or indirectly

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust allows recursion; stack overflow is runtime behavior

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_3gapgqys3ceb` | 4.12.1 | Recursive Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 4.12.1

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_3gapgqys3ceb`: Recursive Types

_File: types-and-traits.rst, Line: 1717_

**Legality Rules:**

- A recursive type is a type whose contained types refer back to the containing type, either directly or by referring to another type which refers back to the original recursive type.
- A type that is not an abstract data type shall not be recursive.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.3

**Type:** rule
**Title:** A function shall not be declared implicitly

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_85vx1qfa061i` | 4.13 | Traits |
| `fls_4ikc07mfrez5` | 4.13.1 | Object Safety |
| `fls_jeoas4n6su4` | 4.14 | Trait and Lifetime Bounds |
| `fls_1ompd93w7c9f` | 4.8 | Trait Types |
| `fls_3xqobbu7wfsf` | 4.8.1 | Impl Trait Types |
| `fls_qa98qdi42orq` | 4.8.2 | Trait Object Types |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 4.13, 4.13.1, 4.14, 4.8, 4.8.1, 4.8.2

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_85vx1qfa061i`: Traits

_File: types-and-traits.rst, Line: 2705_

**Legality Rules:**

- A trait is an item that describes an interface a type can implement.
- A trait body is a construct that encapsulates the associated items, inner attributes, and inner doc comments of a trait.
- Within a trait, the type :c:`Self` acts as a placeholder for a type implementing the trait, and behaves like a type parameter.
- A local trait is a trait that is defined in the current crate.
- A subtrait is a trait with a supertrait.
- _... and 9 more paragraphs_

**Examples:**

- Shape is a supertrait of Circle.
- Circle is a subtrait of Shape.

#### `fls_4ikc07mfrez5`: Object Safety

_File: types-and-traits.rst, Line: 2829_

**Legality Rules:**

- A trait is object safe when:
- An associated function is object safe when it is either an object safe dispatchable function or an object safe non-dispatchable function.
- A dispatchable function is object safe when:
- A function is object safe when it specifies a core::marker::Sized [trait bound] for :c:`Self` in a type bound predicate.

#### `fls_jeoas4n6su4`: Trait and Lifetime Bounds

_File: types-and-traits.rst, Line: 2882_

**Legality Rules:**

- A bound imposes a constraint on a generic parameter by limiting the set of possible generic substitutions.
- A bound does not impose a constraint on a generic parameter of a type alias unless it is an associated item.
- A lifetime bound is a bound that imposes a constraint on the lifetimes of generic parameters.
- A trait bound is a bound that imposes a constraint on the traits of generic parameters.
- A ForGenericParameterList shall not specify ConstantParameters or TypeParameters.
- _... and 10 more paragraphs_

#### `fls_1ompd93w7c9f`: Trait Types

_File: types-and-traits.rst, Line: 1103_

#### `fls_3xqobbu7wfsf`: Impl Trait Types

_File: types-and-traits.rst, Line: 1108_

**Legality Rules:**

- An impl trait type is a type that implements a trait, where the type is known at compile time.
- An impl trait type shall appear only within a function parameter or the return type of a function.
- An anonymous return type is an impl trait type ascribed to a function return type.
- An anonymous return type behaves as if it contained all declared type parameters of the return type's function and its parent trait or implementation.
- An anonymous return type derived from an async function behaves as if it contained all declared type parameters and lifetime parameters of the return type's function and its parent trait or implementation.
- _... and 4 more paragraphs_

#### `fls_qa98qdi42orq`: Trait Object Types

_File: types-and-traits.rst, Line: 1179_

**Legality Rules:**

- A trait object type is a type that implements a trait, where the type is not known at compile time.
- The principal trait of trait object type is the first trait bound.
- The principal trait shall denote an object safe trait.
- All non-principal trait trait bounds shall denote auto traits.
- A trait object type shall not contain opt-out trait bounds.
- _... and 2 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.5

**Type:** rule
**Title:** The function argument corresponding to a parameter declared to

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.6

**Type:** rule
**Title:** Combined with Rule 17.5 MISRA C:2025

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | no longer endorsed by MISRA |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no longer endorsed by MISRA. Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.8

**Type:** rule
**Title:** A function parameter should not be modified

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `disapplied` |
| misra_rust_comment | this cannot be done accidentally without declaring parameters `mut` |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this cannot be done accidentally without declaring parameters `mut`. Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.9

**Type:** rule
**Title:** A function declared with a _Noreturn function specifier shall not return

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | this is expressed with the `!` (Never) type, and enforced by rustc |
| confidence | `medium` |

**Notes:** MISRA ADD-6: this is expressed with the `!` (Never) type, and enforced by rustc. Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.10

**Type:** rule
**Title:** Required A function declared with a _Noreturn function specifier shall have void

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.12

**Type:** rule
**Title:** Advisory A function identifier should only be used with either a preceding &, or

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 17.13

**Type:** rule
**Title:** A function type shall not be type qualified

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Similar function semantics with stronger type checking; Rust has no C-style variadic functions; use generics or extern for FFI

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.1

**Type:** rule
**Title:** A pointer resulting from arithmetic on a pointer operand shall address

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | by unsafe API |
| confidence | `medium` |

**Notes:** MISRA ADD-6: by unsafe API. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust uses bounds-checked indexing; pointer arithmetic requires unsafe. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.4.1, 4.4.2, 6.5.5, 4.3.3.2, 6.5.6, 6.5.7, 4.3, 16, 16.1, 16.2, 6.5.3, 6.8.1, 6.8.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.2

**Type:** rule
**Title:** Subtraction between pointers shall only be applied to pointers that

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | by unsafe API |
| confidence | `medium` |

**Notes:** MISRA ADD-6: by unsafe API. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust uses bounds-checked indexing; pointer arithmetic requires unsafe. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.4.1, 4.4.2, 6.5.5, 6.8.1, 6.8.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.3

**Type:** rule
**Title:** The relational operators >, >=, < and <= shall not be applied to

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust uses bounds-checked indexing; pointer arithmetic requires unsafe

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.4.1, 4.4.2, 6.5.5, 6.8.1, 6.8.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.4

**Type:** rule
**Title:** The +, -, += and -= operators should not be applied to an expression

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `advisory` |
| misra_rust_comment | applies to use of the unsafe API |
| confidence | `medium` |

**Notes:** MISRA ADD-6: applies to use of the unsafe API. Rust has well-defined evaluation order in most cases; Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |

**FLS Sections:** 6, 6.1, 6.5, 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.4.1, 4.4.2, 6.5.5, 6.8.1, 6.8.2

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.5

**Type:** rule
**Title:** Declarations should contain no more than two levels of pointer

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `recommended` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_9gprp17h6t1q` | 14.7 | Use Imports |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 14.2, 14.4.3, 14.7, 4.4.1, 4.4.2, 6.5.5, 6.8.1, 6.8.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_9gprp17h6t1q`: Use Imports

_File: entities-and-resolution.rst, Line: 983_

**Legality Rules:**

- A use import brings entities <entity> in scope within the block expression of an expression-with-block or module where the use import resides.
- A simple path prefix is the leading simple path of a glob import or a nesting import.
- An import path prefix is the fully constructed path prefix of a use import. An import path prefix for a given simple import or glob import is constructed as follows:
- A simple import is a use import that brings all entities <entity> it refers to into scope, optionally with a different name than they are declared with by using a renaming.
- A glob import is a use import that brings all entities <entity> exported by the module or enum its import path prefix resolves to into scope.
- _... and 11 more paragraphs_

**Examples:**

- The following is a glob import. See :p:`fls_jdknpu3kf865` for the declaration of modules and functions. The imported functions are ``create_visible_function``, ``outer_module_visible_function``, ``visible_function``.
- The following is a renaming import. The imported function is ``visible_function`` under the name ``f``.
- The following is a selective import. The imported functions are ``crate_visible_function`` and ``visible_function``.

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.6

**Type:** rule
**Title:** The address of an object with automatic or thread-local storage shall

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust unions require unsafe to read; safe Rust should use enums for tagged unions. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.5.3, 4.11.2.3, 19.-2.7, 17, 17.1, 17.2, 15.1, 15.8, 15.8.1, 4.4.1, 4.4.2, 6.5.5, 6.8.1, 6.8.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.7

**Type:** rule
**Title:** Flexible array members shall not be declared

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust performs bounds checking on array access; unsafe can use unchecked access; Rust has similar struct semantics

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |

**FLS Sections:** 4.4.1, 4.4.2, 6.8.1, 6.8.2, 4.5.2, 4.11.2.2, 4.11, 4.11.1, 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 6.5.5

### FLS Content

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qwljwqr07slp` → 4.3.3 Numeric Types
- `fls_fbchw64p6n2x` → 4.4 Sequence Types
- `fls_4agmmu5al6gt` → 4.4.3 Str Type
- `fls_4ckl3n2ko3i4` → 4.4.4 Tuple Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.8

**Type:** rule
**Title:** 5.14 Control statement expressions

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases; Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |

**FLS Sections:** 6, 6.1, 6.5, 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.4.1, 4.4.2, 6.5.5, 6.8.1, 6.8.2

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.9

**Type:** rule
**Title:** An object with temporary lifetime shall not undergo array-to-pointer

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust performs bounds checking on array access; unsafe can use unchecked access

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.4.1, 4.4.2, 6.8.1, 6.8.2, 15.1, 15.8, 15.8.1, 6.5.5

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 18.10

**Type:** rule
**Title:** Pointers to variably-modified array types shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Safe Rust performs bounds checking on array access; unsafe can use unchecked access

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_uj0kpjwyld60` | 4.4.1 | Array Types |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_xinykul167l` | 6.8 | Array Expressions |
| `fls_qfsfnql1t7m` | 5.2.4 | Underscore Patterns |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.4.1, 4.4.2, 6.8.1, 6.8.2, 6.5.5

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_uj0kpjwyld60`: Array Types

_File: types-and-traits.rst, Line: 471_

**Legality Rules:**

- An array type is a sequence type that represents a fixed sequence of elements.
- The element type shall be a fixed sized type.
- The size operand shall be a constant expression or an inferred constant.
- The type of the size operand is type :c:`usize`.

**Examples:**

- An array type in the context of a let statement:

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_xinykul167l`: Array Expressions

_File: expressions.rst, Line: 2832_

**Legality Rules:**

- An array expression is an expression that constructs an array.
- An array element constructor is an array expression that lists all elements of the array being constructed.
- An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.
- A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.
- A size operand is an operand that specifies the size of an array or an array type.
- _... and 6 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.
- The evaluation of an array expression with an array repetition constructor proceeds as follows:

**Examples:**

- Two dimensional array.
- An array of nine 42s.

#### `fls_qfsfnql1t7m`: Underscore Patterns

_File: patterns.rst, Line: 1169_

**Legality Rules:**

- An underscore pattern is a pattern that matches any single value.
- An underscore pattern is an irrefutable pattern.
- The type of an underscore pattern is the type of the value it matches.

**Examples:**

- An underscore pattern in the context of a let statement. See :p:`fls_8r81vtv5hnrd` for the declaration of ``pair``.

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 19.1

**Type:** rule
**Title:** An object shall not be assigned or copied to an overlapping object

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust has checked arithmetic in debug mode, wrapping/saturating methods; overflow behavior differs from C; Rust unions require unsafe to read; safe Rust should use enums for tagged unions. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3qnpv2z7yjil` | 4.3.3.2 | Integer Types |
| `fls_1k9mkv7rbezi` | 6.5.5 | Arithmetic Expressions |
| `fls_abp6tjbz8tpn` | 6.5.6 | Bit Expressions |
| `fls_nsvzzbldhq53` | 6.5.7 | Comparison Expressions |
| `fls_id66vnaqw0zt` | 4.3 | Scalar Types |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |

**FLS Sections:** 4.3.3.2, 6.5.5, 6.5.6, 6.5.7, 4.3, 4.5.3, 4.11.2.3, 19, 19.-2.7

### FLS Content

#### `fls_3qnpv2z7yjil`: _(not found in RST source)_

#### `fls_1k9mkv7rbezi`: Arithmetic Expressions

_File: expressions.rst, Line: 1296_

**Legality Rules:**

- An arithmetic expression is an expression that computes a value from two operands using arithmetic.
- An addition expression is an arithmetic expression that uses addition.
- The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.
- The type of an addition expression is associated type core::ops::Add::Output.
- The value of an addition expression is the result of ``core::ops::Add::add(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an addition expression proceeds as follows:
- The evaluation of a division expression proceeds as follows:
- The evaluation of a multiplication expression proceeds as follows:
- The evaluation of a remainder expression proceeds as follows:
- The evaluation of a subtraction expression proceeds as follows:

#### `fls_abp6tjbz8tpn`: Bit Expressions

_File: expressions.rst, Line: 1553_

**Legality Rules:**

- A bit expression is an expression that computes a value from two operands using bit arithmetic.
- A bit and expression is a bit expression that uses bit and arithmetic.
- The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.
- The type of a bit and expression is associated type core::ops::BitAnd::Output.
- The value of a bit and expression is the result of ``core::ops::BitAnd::bitand(left_operand, right_operand)``.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a bit and expression proceeds as follows:
- The evaluation of a bit or expression proceeds as follows:
- The evaluation of a bit xor expression proceeds as follows:
- The evaluation of a shift left expression proceeds as follows:
- The evaluation of a shift right expression proceeds as follows:

#### `fls_nsvzzbldhq53`: Comparison Expressions

_File: expressions.rst, Line: 1767_

**Legality Rules:**

- A comparison expression is an expression that compares the values of two operands.
- A comparison expression implicitly takes shared borrows of its operands.
- The type of a comparison expression is type :c:`bool`.
- An equals expression is a comparison expression that tests equality.
- The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.
- _... and 16 more paragraphs_

**Dynamic Semantics:**

- The evaluation of an equals expression proceeds as follows:
- The evaluation of a greater-than expression proceeds as follows:
- The evaluation of a greater-than-or-equals expression proceeds as follows:
- The evaluation of a less-than expression proceeds as follows:
- The evaluation of a less-than-or-equals expression proceeds as follows:
- _... and 1 more paragraphs_

#### `fls_id66vnaqw0zt`: Scalar Types

_File: types-and-traits.rst, Line: 157_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_pocsh1neugpc` → 6.5.3 Error Propagation Expression
- `fls_wrecura8u5ar` → 6.5.4 Negation Expression

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 19.3

**Type:** rule
**Title:** Required A union member shall not be read unless it has been previously set

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust has similar struct semantics; Rust unions require unsafe to read; safe Rust should use enums for tagged unions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_9ucqbbd0s2yo` | 4.5.2 | Struct Types |
| `fls_rjxpof29a3nl` | 4.11.2.2 | Struct Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_g1z6bpyjqxkz` | 4.11.1 | Type Layout |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_3ra8s1v1vbek` | 19.-2.5 | External Static Access |
| `fls_6ipl0xo5qjyl` | 19.-2.6 | Mutable Static Access |
| `fls_ljocmnaz2m49` | 19.-2.8 | Unsafe Function Call |
| `fls_jb6krd90tjmc` | 19.-2.9 | Unsafe Context |
| `fls_ybnpe7ppq1vh` | 19.-2.10 | Unsafe Operation Requirement |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |

**FLS Sections:** 4.5.2, 4.11.2.2, 4.11, 4.11.1, 4.5.3, 4.11.2.3, 19, 19.-2.7, 19.-2.1, 19.-2.2, 19.-2.3, 19.-2.4, 19.-2.5, 19.-2.6, 19.-2.8, 19.-2.9, 19.-2.10, 6.4.4

### FLS Content

#### `fls_9ucqbbd0s2yo`: Struct Types

_File: types-and-traits.rst, Line: 728_

**Legality Rules:**

- A struct type is an abstract data type that is a product of other types.
- The name of a record struct field shall be unique within the related RecordStructDeclaration.
- If the type of a record struct field is a dynamically sized type, then the record struct field shall be the last record struct field in the RecordStructFieldList.
- If the type of a tuple struct field is a dynamically sized type, then the tuple struct field shall be the last tuple struct field in the TupleStructFieldList.

#### `fls_rjxpof29a3nl`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_g1z6bpyjqxkz`: Type Layout

_File: types-and-traits.rst, Line: 1392_

**Legality Rules:**

- All values have an alignment and a size.
- A dynamically sized type is a type that does not implement the core::marker::Sized trait.
- A fat pointer type is an indirection type whose contained type specification is a dynamically sized type.
- The alignment of a value specifies which addresses are valid for storing the value. Alignment is measured in bytes, is at least one, and always a power of two. A value of alignment ``N`` is stored at an address that is a multiple of ``N``.
- The size of a type is the offset in bytes between successive elements in array type ``[T, N]`` where ``T`` is the type of the value, including any padding for alignment. Size is a multiple of the alignment.
- _... and 14 more paragraphs_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_3ra8s1v1vbek`: _(not found in RST source)_

#### `fls_6ipl0xo5qjyl`: _(not found in RST source)_

#### `fls_ljocmnaz2m49`: _(not found in RST source)_

#### `fls_jb6krd90tjmc`: _(not found in RST source)_

#### `fls_ybnpe7ppq1vh`: _(not found in RST source)_

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_wdec78luqh5b` → 4.5 Abstract Data Types
- `fls_szibmtfv117b` → 4.5.1 Enum Types
- `fls_hbbek3z4wtcs` → 4.6 Function Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.1

**Type:** rule
**Title:** #include directives should only be preceded by preprocessor

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | rules specific to the C preprocessor do not apply to Rust |
| confidence | `medium` |

**Notes:** MISRA ADD-6: rules specific to the C preprocessor do not apply to Rust. Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.2

**Type:** rule
**Title:** The ', " or \ characters and the /* or // character sequences shall

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.3

**Type:** rule
**Title:** The #include directive shall be followed by either a <filename> or

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_2i089jvv8j5g` → 2.1 Character Set
- `fls_fgnllgz5k3e6` → 2.2 Lexical Elements, Separators, and Punctuation
- `fls_nrkd5wpi64oo` → 2.4 Literals
- `fls_2ifjqwnw03ms` → 2.4.1 Byte Literals
- `fls_9i5msiuuyihf` → 14.3 Paths
- `fls_ftphlagzd2te` → 14.4.2 Generic Parameter Scope

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.4

**Type:** rule
**Title:** A macro shall not be defined with the same name as a keyword

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `partial` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| misra_rust_comment | possible with raw identifiers but the compiler prevents visual conflicts |
| confidence | `medium` |

**Notes:** MISRA ADD-6: possible with raw identifiers but the compiler prevents visual conflicts. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.5

**Type:** rule
**Title:** #undef should not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.6

**Type:** rule
**Title:** Tokens that look like a preprocessing directive shall not occur within a

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.7

**Type:** rule
**Title:** Expressions resulting from the expansion of macro parameters shall

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `partial` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `advisory` |
| misra_rust_comment | possible to express with procedural macros only, not macro_rules |
| confidence | `medium` |

**Notes:** MISRA ADD-6: possible to express with procedural macros only, not macro_rules. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 6, 6.1, 6.5, 16, 16.1, 16.2, 6.5.3

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.8

**Type:** rule
**Title:** The controlling expression of a #if or #elif preprocessing directive

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 6, 6.1, 6.5

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.9

**Type:** rule
**Title:** Required All identifiers used in the controlling expression of #if or #elif

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust has similar scoping rules with explicit shadowing

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_21vnag69kbwe` | 2.3 | Identifiers |
| `fls_izl8iuhoz9e0` | 14.4 | Scopes |
| `fls_6ozthochxz1i` | 14.4.1 | Binding Scopes |
| `fls_m0z7omni9hp0` | 14.4.3 | Item Scope |
| `fls_ydmnb7qnmzzq` | 14.8 | Shadowing |
| `fls_jdknpu3kf865` | 14.2 | Visibility |
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 2.3, 14.4, 14.4.1, 14.4.3, 14.8, 14.2, 6, 6.1, 6.5

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_21vnag69kbwe`: Identifiers

_File: lexical-elements.rst, Line: 428_

**Syntax:**

- A RawIdentifierKeyword is any keyword in category Keyword, except ``crate``, ``self``, ``Self``, and ``super``.
- XID_Start and XID_Continue are defined in Unicode Standard Annex #31.

**Legality Rules:**

- An identifier is a lexical element that refers to a name.
- A pure identifier is an identifier that does not include weak keywords.
- A pure identifier shall follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the following profile:
- Characters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall not appear in a pure identifier.
- A pure identifier shall be restricted to characters in category AsciiCharacter in the following contexts:
- _... and 3 more paragraphs_

#### `fls_izl8iuhoz9e0`: Scopes

_File: entities-and-resolution.rst, Line: 455_

**Legality Rules:**

- A scope is a region of program text where an entity can be referred to. An entity is in scope when it can be referred to.

#### `fls_6ozthochxz1i`: Binding Scopes

_File: entities-and-resolution.rst, Line: 466_

**Legality Rules:**

- A binding scope is a scope for bindings.
- The binding of a closure parameter is in scope within the related closure body.
- The binding of a function parameter is in scope within the related function body.
- The binding of a for loop or a while let loop is in scope within the related loop body.
- The binding of an if let expression is in scope within the related block expression.
- _... and 3 more paragraphs_

#### `fls_m0z7omni9hp0`: Item Scope

_File: entities-and-resolution.rst, Line: 558_

**Legality Rules:**

- An item scope is a scope for items.
- An item declared within the block expression of an expression-with-block is in scope within the related block expression.
- An item declared within a module is in scope within the related module. Such an item is not in scope within nested modules.

#### `fls_ydmnb7qnmzzq`: Shadowing

_File: entities-and-resolution.rst, Line: 1171_

**Legality Rules:**

- Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it. A name cannot be referred to by any means once it is shadowed.
- No name shall be shadowed except for
- A prelude name shadows other prelude names depending on which preludes are included in a module. The order of shadowing is as follows, where a later prelude name shadows earlier prelude name:

#### `fls_jdknpu3kf865`: Visibility

_File: entities-and-resolution.rst, Line: 105_

**Legality Rules:**

- Visibility is a property of fields and items that determines which modules can refer to the name of the field or item.
- Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module ``M`` as long as the ancestor modules of the related entity can be referred to from ``M``.
- Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.
- A visibility modifier sets the visibility of a name.
- A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.
- _... and 9 more paragraphs_

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.10

**Type:** rule
**Title:** The # and ## preprocessor operators should not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.11

**Type:** rule
**Title:** Section 5: Rules

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.12

**Type:** rule
**Title:** Required A macro parameter used as an operand to the # or ## operators, which

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Similar function semantics with stronger type checking

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.13

**Type:** rule
**Title:** A line whose first token is # shall be a valid preprocessing directive

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.14

**Type:** rule
**Title:** All #else, #elif and #endif preprocessor directives shall reside in the

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has similar control flow with expressions; Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 20.15

**Type:** rule
**Title:** 5.6 Types

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | previously Rule 21.1 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: previously Rule 21.1. Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

_(none)_

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.1

**Type:** rule
**Title:** Renumbered as Rule 20.15 MISRA C:2025

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | Renumbered moved to rule 20.15 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: Renumbered moved to rule 20.15. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust enums are more powerful (algebraic data types)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_szibmtfv117b` | 4.5.1 | Enum Types |
| `fls_xc1hof4qbf6p` | 4.11.2.1 | Enum Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.5.1, 4.11.2.1, 4.11, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_szibmtfv117b`: Enum Types

_File: types-and-traits.rst, Line: 611_

**Legality Rules:**

- An enum type is an abstract data type that contains enum variants.
- A zero-variant enum type has no values.
- An enum variant is a construct that declares one of the possible variations of an enum.
- The name of an enum variant shall be unique within the related EnumDeclaration.
- A discriminant is an opaque integer that identifies an enum variant.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is a validity invariant for a value of an enum type to have a discriminant specified by the enum type.

#### `fls_xc1hof4qbf6p`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.2

**Type:** rule
**Title:** Renumbered as Rule 5.10 MISRA C:2025

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | Renumbered moved to Rule 5.10 |
| confidence | `medium` |

**Notes:** MISRA ADD-6: Renumbered moved to Rule 5.10. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust enums are more powerful (algebraic data types)

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_szibmtfv117b` | 4.5.1 | Enum Types |
| `fls_xc1hof4qbf6p` | 4.11.2.1 | Enum Type Representation |
| `fls_7pby13muw48o` | 4.11 | Representation |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 4.5.1, 4.11.2.1, 4.11, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_szibmtfv117b`: Enum Types

_File: types-and-traits.rst, Line: 611_

**Legality Rules:**

- An enum type is an abstract data type that contains enum variants.
- A zero-variant enum type has no values.
- An enum variant is a construct that declares one of the possible variations of an enum.
- The name of an enum variant shall be unique within the related EnumDeclaration.
- A discriminant is an opaque integer that identifies an enum variant.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is a validity invariant for a value of an enum type to have a discriminant specified by the enum type.

#### `fls_xc1hof4qbf6p`: _(not found in RST source)_

#### `fls_7pby13muw48o`: Representation

_File: types-and-traits.rst, Line: 1387_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.3

**Type:** rule
**Title:** The memory allocation and deallocation functions of <stdlib.h>

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Similar function semantics with stronger type checking. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.4

**Type:** rule
**Title:** The standard header file <setjmp.h> shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Rust has no setjmp/longjmp; uses panic/catch_unwind or Result; Rust uses std::io and std::fs; different API design. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.5

**Type:** rule
**Title:** The standard header file <signal.h> shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Rust has no native signal handling; use platform-specific crates; Rust uses std::io and std::fs; different API design. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.6

**Type:** rule
**Title:** The Standard Library input/output functions shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses std::io and std::fs; different API design. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.7

**Type:** rule
**Title:** The Standard Library functions atof, atoi, atol and atoll of <stdlib.h>

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.8

**Type:** rule
**Title:** The Standard Library termination functions of <stdlib.h> shall not

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.9

**Type:** rule
**Title:** The Standard Library functions bsearch and qsort of <stdlib.h>

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.10

**Type:** rule
**Title:** The Standard Library time and date functions shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.11

**Type:** rule
**Title:** The standard header file <tgmath.h> should not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | no external interface |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no external interface. Rust uses std::io and std::fs; different API design; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.12

**Type:** rule
**Title:** The standard header file <fenv.h> shall not be used

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Rust uses std::io and std::fs; different API design; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.13

**Type:** rule
**Title:** Any value passed to a function in <ctype.h> shall be representable

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.14

**Type:** rule
**Title:** Required The Standard Library function memcmp shall not be used to compare

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.15

**Type:** rule
**Title:** The pointer arguments to the Standard Library functions memcpy

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.16

**Type:** rule
**Title:** The pointer arguments to the Standard Library function memcmp

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.17

**Type:** rule
**Title:** Use of the string handling functions from <string.h> shall not result

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |
| `fls_maw4u1o8q37u` | 18.3 | Crates |
| `fls_gklst7joeo33` | 18.4 | Crate Imports |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 16, 16.1, 16.2, 6.5.3, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2, 18, 18.1, 18.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

#### `fls_maw4u1o8q37u`: Crates

_File: program-structure-and-compilation.rst, Line: 107_

**Legality Rules:**

- A crate is a unit of compilation and linking that contains a tree of nested modules.
- The crate type of a crate is the value of the attribute ``crate_type`` of a crate or the value of ``--crate-type`` flag passed to the tool compiling the crate.
- The crate type of a crate if not specified is ``bin``.
- A crate may be subject to multiple crate types, treating each type as a separate crate.
- A binary crate is a crate whose crate type is ``bin``.
- _... and 6 more paragraphs_

#### `fls_gklst7joeo33`: Crate Imports

_File: program-structure-and-compilation.rst, Line: 158_

**Legality Rules:**

- A crate import specifies a required dependency on an external crate.
- A crate indication is a construct that indicates a crate.
- A crate import binds an external crate to its crate indication.
- Crate indication ``self`` shall require a renaming.
- A crate import with a renaming with an identifier binds the external crate to a local name and introduces the local name into the enclosing scope.
- _... and 2 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.19

**Type:** rule
**Title:** Mandatory The pointers returned by the Standard Library functions localeconv

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.20

**Type:** rule
**Title:** The pointer returned by the Standard Library functions asctime, ctime

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Similar function semantics with stronger type checking. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.21

**Type:** rule
**Title:** The Standard Library function system of <stdlib.h> shall not be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.22

**Type:** rule
**Title:** All operand arguments to any type-generic macros declared in

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | no external interface |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no external interface. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 12, 12.1, 12.3, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.23

**Type:** rule
**Title:** All operand arguments to any multi-argument type-generic macros

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| misra_rust_comment | no external interface |
| confidence | `medium` |

**Notes:** MISRA ADD-6: no external interface. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 12, 12.1, 12.3, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.24

**Type:** rule
**Title:** The random number generator functions of <stdlib.h> shall not be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.25

**Type:** rule
**Title:** All memory synchronization operations shall be executed in

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has std::sync::atomic with similar memory ordering

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 21.26

**Type:** rule
**Title:** The Standard Library function mtx_timedlock() shall only be invoked on

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_4agmmu5al6gt` | 4.4.3 | Str Type |
| `fls_boyhlu5srp6u` | 2.4.6 | String Literals |
| `fls_hucd52suu6it` | 2.4.6.1 | Simple String Literals |
| `fls_usr6iuwpwqqh` | 2.4.6.2 | Raw String Literals |
| `fls_vpbikb73dw4k` | 4.4.2 | Slice Types |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 17, 17.1, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 4.4.3, 2.4.6, 2.4.6.1, 2.4.6.2, 4.4.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_4agmmu5al6gt`: Str Type

_File: types-and-traits.rst, Line: 545_

**Legality Rules:**

- :c:`Str` is a sequence type that represents a slice of 8-bit unsigned bytes.
- Type :c:`str` is a dynamically sized type.
- A value of type :c:`str` shall denote a valid UTF-8 sequence of characters.

**Undefined Behavior:**

- It is a safety invariant for a value of type :c:`str` to denote a valid UTF-8 sequence of characters.

#### `fls_boyhlu5srp6u`: String Literals

_File: lexical-elements.rst, Line: 1146_

**Syntax:**

- A SimpleStringCharacter is any Unicode character except characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).
- StringContinuation is the character sequence 0x5C 0x0A (reverse solidus, new line).

**Legality Rules:**

- A string literal is a literal that consists of multiple characters.
- The character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A (new line) inside of a string literal.
- A simple string literal is a string literal where the characters are Unicode characters.
- The type of a simple string literal is ``&'static str``.
- A raw string literal is a simple string literal that does not recognize escaped characters.
- _... and 1 more paragraphs_

#### `fls_hucd52suu6it`: _(not found in RST source)_

#### `fls_usr6iuwpwqqh`: _(not found in RST source)_

#### `fls_vpbikb73dw4k`: Slice Types

_File: types-and-traits.rst, Line: 511_

**Legality Rules:**

- A slice type is a sequence type that provides a view into a sequence of elements.
- The element type shall be a fixed sized type.
- A slice type is a dynamically sized type.

**Examples:**

- A slice type in the context of a let statement:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.1

**Type:** rule
**Title:** All resources obtained dynamically by means of Standard Library

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | applies to resources acquired through FFI only |
| confidence | `medium` |

**Notes:** MISRA ADD-6: applies to resources acquired through FFI only. Similar function semantics with stronger type checking; C standard library rules don't apply to Rust std library. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15.6, 15.7, 15.8, 15, 15.1, 15.2, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.2

**Type:** rule
**Title:** A block of memory shall only be freed if it was allocated by means of a

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs; Rust has similar control flow with expressions. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 17, 17.1, 17.2

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.3

**Type:** rule
**Title:** The same file shall not be open for read and write access at the same

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Rust has similar control flow with expressions; Rust uses std::io and std::fs; different API design. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_qfsfnql1t7m` → 5.2.4 Underscore Patterns
- `fls_qssijtofa9i8` → 5.3 Binding Modes
- `fls_vnai6ag4qrdb` → 5.4.1 Identifier Pattern Matching
- `fls_azzf1llv3wf` → 5.4.2 Literal Pattern Matching
- `fls_rr908hgunja7` → 6.15 Loop Expressions
- `fls_m6kd5i9dy8dx` → 6.15.4 While Let Loops

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.4

**Type:** rule
**Title:** There shall be no attempt to write to a stream which has been

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Rust uses std::io and std::fs; different API design; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.5

**Type:** rule
**Title:** Mandatory A pointer to a FILE object shall not be dereferenced

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Core Rust concept for safe memory access, applies to all Rust. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_8kqo952gjhaf` | 19.-2.1 | Unsafety Definition |
| `fls_ovn9czwnwxue` | 19.-2.2 | Unsafe Operation Definition |
| `fls_pfhmcafsjyf7` | 19.-2.3 | Unsafe Operations List |
| `fls_3ra8s1v1vbek` | 19.-2.5 | External Static Access |
| `fls_6ipl0xo5qjyl` | 19.-2.6 | Mutable Static Access |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_ljocmnaz2m49` | 19.-2.8 | Unsafe Function Call |
| `fls_jb6krd90tjmc` | 19.-2.9 | Unsafe Context |
| `fls_ybnpe7ppq1vh` | 19.-2.10 | Unsafe Operation Requirement |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 19.-2.1, 19.-2.2, 19.-2.3, 19.-2.5, 19.-2.6, 19.-2.7, 19.-2.8, 19.-2.9, 19.-2.10, 6.4.4, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_8kqo952gjhaf`: _(not found in RST source)_

#### `fls_ovn9czwnwxue`: _(not found in RST source)_

#### `fls_pfhmcafsjyf7`: _(not found in RST source)_

#### `fls_3ra8s1v1vbek`: _(not found in RST source)_

#### `fls_6ipl0xo5qjyl`: _(not found in RST source)_

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_ljocmnaz2m49`: _(not found in RST source)_

#### `fls_jb6krd90tjmc`: _(not found in RST source)_

#### `fls_ybnpe7ppq1vh`: _(not found in RST source)_

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.6

**Type:** rule
**Title:** Mandatory The value of a pointer to a FILE shall not be used after the associated

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust uses std::io and std::fs; different API design. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.7

**Type:** rule
**Title:** The macro EOF shall only be compared with the unmodified return

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust has no C-style preprocessor; uses modules and declarative/procedural macros. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.8

**Type:** rule
**Title:** The value of errno shall be set to zero prior to a call to an errno-

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `disapplied` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 16, 16.1, 16.2, 6.5.3, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.9

**Type:** rule
**Title:** The value of errno shall be tested against zero after calling an errno-

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `disapplied` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 16, 16.1, 16.2, 6.5.3, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.10

**Type:** rule
**Title:** The value of errno shall only be tested when the last function to be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `disapplied` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust uses Result<T, E> type instead of errno. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_dzq9cdz4ibsz` | 16 | Exceptions and Errors |
| `fls_k02nt1m5fq1z` | 16.1 | Panic |
| `fls_hi1iz0gbnksi` | 16.2 | Abort |
| `fls_pocsh1neugpc` | 6.5.3 | Error Propagation Expression |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 16, 16.1, 16.2, 6.5.3, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17, 17.1, 17.2

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_dzq9cdz4ibsz`: Exceptions and Errors

_File: exceptions-and-errors.rst, Line: 8_

**Legality Rules:**

- The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme:
- Enum core::option::Option indicates whether a value is either present using core::option::Option::Some or absent using core::option::Option::None.
- Enum core::result::Result indicates whether a computation completed successfully and produced a value using core::result::Result::Ok or the computation failed with an error using core::result::Result::Err.

#### `fls_k02nt1m5fq1z`: Panic

_File: exceptions-and-errors.rst, Line: 40_

**Legality Rules:**

- A panic is an abnormal program state caused by invoking macro core::panic.

**Dynamic Semantics:**

- Invoking macro core::panic has the following runtime effects:

#### `fls_hi1iz0gbnksi`: Abort

_File: exceptions-and-errors.rst, Line: 69_

**Legality Rules:**

- Abort is the immediate termination of a program.

**Dynamic Semantics:**

- Abort has the following runtime effects:

#### `fls_pocsh1neugpc`: Error Propagation Expression

_File: expressions.rst, Line: 1090_

**Legality Rules:**

- An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.
- An error propagation expression shall appear within a control flow boundary.
- The type of an error propagation expression is associated type core::ops::Try::Output.
- The value of an error propagation expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an error propagation expression of the form
- is equivalent to the evaluation the following expression:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.11

**Type:** rule
**Title:** A thread that was previously either joined or detached shall not be

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.12

**Type:** rule
**Title:** Thread objects, thread synchronization objects, and thread-specific

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.13

**Type:** rule
**Title:** Thread objects, thread synchronization objects and thread-specific

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass; Rust has Mutex<T> and RwLock<T> with RAII guards

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.14

**Type:** rule
**Title:** Thread synchronization objects shall be initialized before being

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| misra_rust_comment | applies to creating synchronization objects before threads that use them |
| confidence | `medium` |

**Notes:** MISRA ADD-6: applies to creating synchronization objects before threads that use them. Safe Rust requires initialization before use; unsafe can use MaybeUninit; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_8wnyln2nmg4y` | 6.4.4 | Unsafe Blocks |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 15.2, 15.1, 6.4.4, 19, 17, 17.1, 17.2, 15, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_8wnyln2nmg4y`: Unsafe Blocks

_File: expressions.rst, Line: 860_

**Legality Rules:**

- An unsafe block expression is a block expression that is specified with keyword ``unsafe``.
- An unsafe block expression allows unsafety.
- The type of the unsafe block expression is the type of its block expression.
- The value of the unsafe block expression is the value of its block expression.

**Dynamic Semantics:**

- The evaluation of an unsafe block expression evaluates its block expression.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_v5x85lt5ulva` → 15.3 References
- `fls_a14slch83hzn` → 15.4 Borrowing

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.15

**Type:** rule
**Title:** Thread synchronization objects and thread-specific storage pointers

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| misra_rust_comment | applies to releasing synchronization objects after threads that use them |
| confidence | `medium` |

**Notes:** MISRA ADD-6: applies to releasing synchronization objects after threads that use them. Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust unions require unsafe to read; safe Rust should use enums for tagged unions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.5.3, 4.11.2.3, 19.-2.7, 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.16

**Type:** rule
**Title:** Required All mutex objects locked by a thread shall be explicitly unlocked by the

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Safe Rust Send/Sync traits prevent data races at compile time; unsafe can bypass. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.17

**Type:** rule
**Title:** No thread shall unlock a mutex or call cnd_wait() or cnd_timedwait() for

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `required` |
| misra_rust_comment | only accessible through unsafe extern “C” |
| confidence | `medium` |

**Notes:** MISRA ADD-6: only accessible through unsafe extern “C”. Similar function semantics with stronger type checking; Rust has similar control flow with expressions. Only applicable in unsafe Rust

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_xztr1kebz8bo` | 4.7.1 | Function Pointer Types |
| `fls_airvr79xkcag` | 4.6.2 | Function Item Types |
| `fls_77scxuomlbgs` | 15.5 | Passing Conventions |
| `fls_lnpyb285qdiy` | 14.4.7 | Scope Hierarchy |
| `fls_jm6l7b90h6wa` | 5.4 | Pattern Matching |
| `fls_sf4qnd43z2wc` | 6.15.2 | Infinite Loops |
| `fls_onfyolkcbeh3` | 6.15.1 | For Loops |
| `fls_5jjm1kt43axd` | 6.15.3 | While Loops |
| `fls_uusi0zej55is` | 6.15.5 | Loop Labels |
| `fls_sjwrlwvpulp` | 6.15.7 | Continue Expressions |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 4.6, 4.6.1, 4.6.2, 15.5, 14.4.7, 6.9, 6.10, 6.11, 6.12, 6.13, 6.14, 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_xztr1kebz8bo`: Function Pointer Types

_File: types-and-traits.rst, Line: 942_

**Legality Rules:**

- A function pointer type is an indirection type that refers to a function.
- An unsafe function pointer type is a function pointer type subject to keyword ``unsafe``.
- A variadic part indicates the presence of C-like optional parameters.
- A variadic part can only be used in a variadic function.
- The return type of a function pointer type is determined as follows:

**Undefined Behavior:**

- It is a validity invariant for a value of a function pointer type to be not :c:`null`.

#### `fls_airvr79xkcag`: Function Item Types

_File: types-and-traits.rst, Line: 908_

**Legality Rules:**

- A function item type is a unique anonymous function type that identifies a function.
- An external function item type is a function item type where the related function is an external function.
- An unsafe function item type is a function item type where the related function is an unsafe function.
- A function item type is coercible to a function pointer type.
- A function item type implements the core::clone::Clone trait, the core::marker::Copy trait, the core::ops::Fn trait, the core::ops::FnMut trait, the core::ops::FnOnce trait, the core::marker::Send trait, and the core::marker::Sync trait.

#### `fls_77scxuomlbgs`: Passing Conventions

_File: ownership-and-deconstruction.rst, Line: 257_

**Legality Rules:**

- A passing convention is the mechanism that defines how a value is transferred between places.
- A copy type is a type that implements the core::marker::Copy trait.
- A value of a copy type is passed <passing convention> by copy. Passing by copy does not change the owner of the value.
- A move type is a type that implements the core::marker::Sized trait and is not a copy type.
- A value of a move type is passed <passing convention> by move. Passing by move changes the owner of the value.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Passing a value by copy from a source owner to a target owner proceeds as follows:
- Passing a value by move from a source owner to a target owner proceeds as follows:

**Examples:**

- Type ``i32`` is a copy type. By the end of the second let statement, ``x`` is the owner of the original ``42`` and ``y`` is the owner of a cloned ``42``.
- Type core::sync::atomic::AtomicI32 is a move type. By the end of the second let statement, ``x`` is uninitialized and ``y`` is the sole owner of the atomic ``42``.

#### `fls_lnpyb285qdiy`: Scope Hierarchy

_File: entities-and-resolution.rst, Line: 650_

**Legality Rules:**

- The scope hierarchy reflects the nesting of scopes as introduced by scoping constructs. An inner scope introduced by a nested scoping construct is the child of an outer scope introduced by an enclosing scoping construct.
- A scoping construct is a construct that introduces scopes into the scope hierarchy. The following constructs are scoping constructs:
- A closure expression introduces a binding scope into the scope hierarchy.
- A declarative macro introduces a textual macro scope into the scope hierarchy.
- The declaration of an enum type introduces a generic parameter scope and a Self scope into the scope hierarchy.
- _... and 15 more paragraphs_

#### `fls_jm6l7b90h6wa`: Pattern Matching

_File: patterns.rst, Line: 1290_

**Legality Rules:**

- Pattern matching that involves a pattern and a context value proceeds as follows:
- Only the bindings of a matched pattern-without-alternation are introduced into a binding scope.

#### `fls_sf4qnd43z2wc`: Infinite Loops

_File: expressions.rst, Line: 3924_

**Legality Rules:**

- An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.
- The type of an infinite loop expression is determined as follows:
- The value of an infinite loop expression is determined as follows:

**Dynamic Semantics:**

- The evaluation of an infinite loop expression proceeds as follows:

#### `fls_onfyolkcbeh3`: For Loops

_File: expressions.rst, Line: 3849_

**Legality Rules:**

- A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.
- The type of a subject expression shall implement the core::iter::IntoIterator trait.
- The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.
- The type of a for loop expression is the unit type.
- The value of a for loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a for loop expression of the form
- is equivalent to the evaluation of the following block expression:

#### `fls_5jjm1kt43axd`: While Loops

_File: expressions.rst, Line: 3985_

**Legality Rules:**

- A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.
- An iteration expression is an expression that provides the criterion of a while loop expression.
- The type of an iteration expression shall be type :c:`bool`.
- The type of a while loop expression is the unit type.
- The value of a while loop expression is the unit value.

**Dynamic Semantics:**

- The evaluation of a while loop expression proceeds as follows:

#### `fls_uusi0zej55is`: Loop Labels

_File: expressions.rst, Line: 4109_

**Legality Rules:**

- A label indication is a construct that indicates a label.
- A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression.

#### `fls_sjwrlwvpulp`: Continue Expressions

_File: expressions.rst, Line: 4246_

**Legality Rules:**

- A continue expression shall appear within a loop expression.
- A continue expression without a label indication is associated with the innermost enclosing loop expression.
- A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.
- The type of a continue expression is the never type.

**Dynamic Semantics:**

- The evaluation of a continue expression proceeds as follows:

**Examples:**

- The following continue expression terminates and restarts ``game_loop``.

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_3i4ou0dq64ny` → 4.7 Indirection Types
- `fls_ppd1xwve3tr7` → 4.7.2 Raw Pointer Types
- `fls_142vncdktbin` → 4.7.3 Reference Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.18

**Type:** rule
**Title:** Non-recursive mutexes shall not be recursively locked

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust allows recursion; stack overflow is runtime behavior; Rust has Mutex<T> and RwLock<T> with RAII guards

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3gapgqys3ceb` | 4.12.1 | Recursive Types |
| `fls_hbbek3z4wtcs` | 4.6 | Function Types |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 4.12.1, 4.6, 17, 17.1, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17.2

### FLS Content

#### `fls_3gapgqys3ceb`: Recursive Types

_File: types-and-traits.rst, Line: 1717_

**Legality Rules:**

- A recursive type is a type whose contained types refer back to the containing type, either directly or by referring to another type which refers back to the original recursive type.
- A type that is not an abstract data type shall not be recursive.

#### `fls_hbbek3z4wtcs`: Function Types

_File: types-and-traits.rst, Line: 857_

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_ohhsmifo0urd` → 4.11.2 Type Representation
- `fls_j02707n615z0` → 4.12 Type Model
- `fls_exe4zodlwfez` → 4.12.2 Type Unification
- `fls_dw33yt5g6m0k` → 4.12.3 Type Coercion
- `fls_9ucqbbd0s2yo` → 4.5.2 Struct Types
- `fls_fmdn7n7s413d` → 4.5.3 Union Types
- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.19

**Type:** rule
**Title:** A condition variable shall be associated with at most one mutex object

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `direct` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Rust has Mutex<T> and RwLock<T> with RAII guards; Safe Rust prevents use-after-free and double-free at compile time via ownership; unsafe Rust can use raw allocator APIs

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |

**FLS Sections:** 17, 17.1, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9, 17.2

### FLS Content

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mtuwzinpfvkl` → 17.3 Asynchronous Computation

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 22.20

**Type:** rule
**Title:** Thread-specific storage pointers shall be created before being

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `direct` |
| applicability_safe_rust | `partial` |
| misra_rust_category | `required` |
| confidence | `medium` |

**Notes:** Safe Rust uses references with borrow checking, preventing null/dangling pointers; raw pointers require unsafe blocks; Rust unions require unsafe to read; safe Rust should use enums for tagged unions

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_3i4ou0dq64ny` | 4.7 | Indirection Types |
| `fls_ppd1xwve3tr7` | 4.7.2 | Raw Pointer Types |
| `fls_142vncdktbin` | 4.7.3 | Reference Types |
| `fls_v5x85lt5ulva` | 15.3 | References |
| `fls_a14slch83hzn` | 15.4 | Borrowing |
| `fls_5cm4gkt55hjh` | 6.5.2 | Dereference Expression |
| `fls_qztk0bkju9u` | 6.5.1 | Borrow Expression |
| `fls_jep7p27kaqlp` | 19 | Unsafety |
| `fls_jd1inwz7ulyw` | 19.-2.4 | Raw Pointer Dereference |
| `fls_fmdn7n7s413d` | 4.5.3 | Union Types |
| `fls_cmq8ogs84ivh` | 4.11.2.3 | Union Type Representation |
| `fls_ucghxcnpaq2t` | 19.-2.7 | Union Field Access |
| `fls_3v733mnewssy` | 17 | Concurrency |
| `fls_eiw4by8z75di` | 17.1 | Send and Sync |
| `fls_vyc9vcuamlph` | 17.2 | Atomics |
| `fls_ronnwodjjjsh` | 15 | Ownership and Destruction |
| `fls_svkx6szhr472` | 15.1 | Ownership |
| `fls_3xvm61x0t251` | 15.2 | Initialization |
| `fls_4jiw35pan7vn` | 15.6 | Destruction |
| `fls_u2mzjgiwbkz0` | 15.7 | Destructors |
| `fls_rm4ncoopcdvj` | 15.8 | Drop Scopes |
| `fls_5eima0pd31c0` | 15.8.1 | Drop Scope Extension |
| `fls_afafmafz4hf2` | 15.9 | Drop Order |

**FLS Sections:** 4.7, 4.7.2, 4.7.3, 15.3, 15.4, 6.5.2, 6.5.1, 19, 19.-2.4, 4.5.3, 4.11.2.3, 19.-2.7, 17, 17.1, 17.2, 15, 15.1, 15.2, 15.6, 15.7, 15.8, 15.8.1, 15.9

### FLS Content

#### `fls_3i4ou0dq64ny`: Indirection Types

_File: types-and-traits.rst, Line: 937_

#### `fls_ppd1xwve3tr7`: Raw Pointer Types

_File: types-and-traits.rst, Line: 1006_

**Legality Rules:**

- A raw pointer type is an indirection type without validity guarantees.
- A mutable raw pointer type is a raw pointer type subject to keyword ``mut``.
- An immutable raw pointer type is a raw pointer type subject to keyword ``const``.
- Comparing two values of raw pointer types compares the addresses of the values.
- Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.

#### `fls_142vncdktbin`: Reference Types

_File: types-and-traits.rst, Line: 1046_

**Legality Rules:**

- A reference type is an indirection type with ownership.
- A shared reference type is a reference type not subject to keyword ``mut``.
- A shared reference type prevents the direct mutation of a referenced value.
- A shared reference type implements the core::marker::Copy trait. Copying a shared reference performs a shallow copy.
- Releasing a shared reference has no effect on the value it refers to.
- _... and 3 more paragraphs_

**Undefined Behavior:**

- It is validity invariant for a value of a reference type to be not :c:`null`.

#### `fls_v5x85lt5ulva`: References

_File: ownership-and-deconstruction.rst, Line: 87_

**Legality Rules:**

- A reference is a value of a reference type. A reference can be obtained explicitly by using a borrow expression or implicitly in certain scenarios.
- A referent is the value pointed-to by a reference.
- A reference shall point to an initialized referent.
- The lifetime of a referent shall be at least as long as the lifetime of its reference.
- A reference is active from the point of obtaining its referent upto the last use of the reference, prior to another assignment to the reference or the end of the scope of the reference.
- _... and 6 more paragraphs_

**Undefined Behavior:**

- It is undefined behavior to access a value through aliasing mutable references from unsafe context.

#### `fls_a14slch83hzn`: Borrowing

_File: ownership-and-deconstruction.rst, Line: 152_

**Legality Rules:**

- Borrowing is the process of temporarily associating a reference with a value without transferring ownership permanently.
- A borrow is a reference produced by borrowing.
- An implicit borrow is a borrow that is not present syntactically in program text. An implicit borrow occurs in the following contexts:
- ` An implicit borrow may be an immutable borrow or a mutable borrow if required.
- An immutable borrow is an immutable reference produced by borrowing.
- _... and 4 more paragraphs_

#### `fls_5cm4gkt55hjh`: Dereference Expression

_File: expressions.rst, Line: 1006_

**Legality Rules:**

- A dereference expression is an expression that obtains the pointed-to memory location of its operand.
- When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.
- The dereference is assignable when the dereference expression is a mutable place expression.
- Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.
- If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression ``*core::ops::Deref::deref(&operand)``.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a dereference expression evaluates its operand.

**Undefined Behavior:**

- It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.

**Examples:**

- See :p:`fls_350qejoq9i23` for the declaration of ``ref_answer``.

#### `fls_qztk0bkju9u`: Borrow Expression

_File: expressions.rst, Line: 936_

**Legality Rules:**

- A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.
- An immutable borrow expression is a borrow expression that lacks keyword ``mut``.
- A mutable borrow expression is a borrow expression that has keyword ``mut``.
- When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.
- The type of a borrow expression is determined as follows:
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a borrow expression evaluates its operand.

**Examples:**

- Mutable borrow.

#### `fls_jep7p27kaqlp`: Unsafety

_File: unsafety.rst, Line: 8_

**Legality Rules:**

- Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.
- An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error. Unsafe operations are referred to as unsafe Rust.
- The unsafe operations are:
- An unsafe context is either an unsafe block or an unsafe function.
- An unsafe operation shall be used only within an unsafe context.

#### `fls_jd1inwz7ulyw`: _(not found in RST source)_

#### `fls_fmdn7n7s413d`: Union Types

_File: types-and-traits.rst, Line: 801_

**Legality Rules:**

- A union type is an abstract data type that is a sum of other types.
- A union without any union fields is rejected, but may still be consumed by macros.
- The name of a union field shall be unique within the related RecordStructDeclaration.
- The type of a union field shall be either:

#### `fls_cmq8ogs84ivh`: _(not found in RST source)_

#### `fls_ucghxcnpaq2t`: _(not found in RST source)_

#### `fls_3v733mnewssy`: Concurrency

_File: concurrency.rst, Line: 8_

**Legality Rules:**

- A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.

**Undefined Behavior:**

- It is undefined behavior if two or more threads engage in a data race.

#### `fls_eiw4by8z75di`: Send and Sync

_File: concurrency.rst, Line: 29_

**Legality Rules:**

- The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.
- A send type is a type that implements the core::marker::Send trait.
- An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.
- A send type shall have values that are safe to transfer across thread boundaries.
- A sync type is a type that implements the core::marker::Sync trait.
- _... and 2 more paragraphs_

#### `fls_vyc9vcuamlph`: Atomics

_File: concurrency.rst, Line: 67_

**Legality Rules:**

- An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.
- Atomic types are related to types as follows:

#### `fls_ronnwodjjjsh`: Ownership and Destruction

_File: ownership-and-deconstruction.rst, Line: 8_

#### `fls_svkx6szhr472`: Ownership

_File: ownership-and-deconstruction.rst, Line: 13_

**Legality Rules:**

- Ownership is a property of values that is central to the resource management model of Rust.
- An owner is a variable that holds a value.
- A value shall have only one owner.

#### `fls_3xvm61x0t251`: Initialization

_File: ownership-and-deconstruction.rst, Line: 30_

**Legality Rules:**

- Initialization is the act of supplying an initial value to a variable.
- When a variable holds a value, the variable is considered to be initialized.
- When a variable lacks a value or its value has been passed <passing convention> by move, the variable is considered to be uninitialized.
- A variable shall be initialized before it is accessed.

**Runtime Semantics:**

- All memory starts as uninitialized.

**Examples:**

- Variable ``a`` is initialized.
- Variable ``b`` starts off as uninitialized, but is later initialized by virtue of the assignment statement.
- Variable ``c`` starts off initialized, but is later uninitialized by virtue of a transfer by move.

#### `fls_4jiw35pan7vn`: Destruction

_File: ownership-and-deconstruction.rst, Line: 353_

**Legality Rules:**

- Destruction is the process of recovering resources associated with a value as it goes out of scope.

#### `fls_u2mzjgiwbkz0`: Destructors

_File: ownership-and-deconstruction.rst, Line: 364_

**Legality Rules:**

- A drop type is a type that implements the core::ops::Drop trait or contains a field that has a drop type.
- A destructor is a function that is invoked immediately before the destruction of a value of a drop type.
- Dropping a value is the act of invoking the destructor of the related type. Such an object is said to be dropped.
- An uninitialized variable is not dropped.

**Dynamic Semantics:**

- Dropping an initialized variable proceeds as follows:

**Examples:**

- When object ``array`` is dropped, its destructor drops the first element, then the second element.
- Object ``uninitialized`` is not dropped.

#### `fls_rm4ncoopcdvj`: Drop Scopes

_File: ownership-and-deconstruction.rst, Line: 455_

**Legality Rules:**

- A drop scope is a region of program text that governs the dropping of values. When control flow leaves a drop scope, all values associated with that drop scope are dropped based on a drop order.
- A drop construct is a construct that employs a drop scope. The following constructs are drop constructs:
- Drop scopes are nested within one another as follows:
- A binding declared in a for loop expression is associated with the drop scope of the block expression of the for loop expression.
- A binding declared in an if let expression is associated with the drop scope of the block expression of the if let expression.
- _... and 5 more paragraphs_

#### `fls_5eima0pd31c0`: Drop Scope Extension

_File: ownership-and-deconstruction.rst, Line: 586_

**Legality Rules:**

- Drop scope extension is the process of extending a drop scope associated with a temporary to prevent the premature dropping of the temporary.
- An extending pattern is either
- If the pattern-without-alternation of a let statement is an extending pattern, then the drop scope of the expression of the let statement is extended to the drop scope of the block expression that contains the let statement.
- An extending expression is an expression with an extended drop scope <drop scope extension>.
- An extending expression is any of the following:
- _... and 3 more paragraphs_

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop scope of the temporary created for expression ``AtomicI32::new(42)`` is extended to the drop scope of the block expression.

#### `fls_afafmafz4hf2`: Drop Order

_File: ownership-and-deconstruction.rst, Line: 684_

**Legality Rules:**

- Drop order is the order by which values are dropped when a drop scope is left.
- When a drop scope is left, all values associated with that drop scope are dropped as follows:
- When a drop scope of a function is left, then each function parameter is dropped from right to left as follows:
- When multiple drop scopes are left at once, the values are dropped from the innermost drop scope to the outermost drop scope.

**Examples:**

- See :p:`fls_u2mzjgiwbkz0` for the declaration of ``PrintOnDrop``.
- The drop order of the following variables is ``b``, ``c``, ``a``. Dropping proceeds as follows:

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_xd2oxlebhs14` → 4.6.1 Closure Types
- `fls_airvr79xkcag` → 4.6.2 Function Item Types
- `fls_xztr1kebz8bo` → 4.7.1 Function Pointer Types
- `fls_1ompd93w7c9f` → 4.8 Trait Types

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.1

**Type:** rule
**Title:** A generic selection should only be expanded from a macro

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 12, 12.1, 12.3

### FLS Content

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_7nv8ualeaqe3` → 12.2 Where Clauses

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.2

**Type:** rule
**Title:** A generic selection that is not expanded from a macro shall not

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 12, 12.1, 12.3

### FLS Content

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_7nv8ualeaqe3` → 12.2 Where Clauses

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.3

**Type:** rule
**Title:** A generic selection should contain at least one non-default

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust match is exhaustive and more powerful than C switch; Rust uses generics and traits instead of _Generic

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 6.14, 5.4.5, 5.2, 12, 12.1, 12.3

### FLS Content

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_mkut7gut49gi` → 6.17.1 If Expressions
- `fls_p0t1ch115tra` → 6.17.2 If Let Expressions
- `fls_8l74abhlxzdl` → 6.19 Return Expressions
- `fls_hyrbmfmf6r8g` → 6.20 Await Expressions
- `fls_5loglxds6zik` → 5.4.3 Parenthesized Pattern Matching
- `fls_d44aflefat88` → 5.4.4 Path Pattern Matching
- `fls_org6hqv397fp` → 5.4.6 Reference Pattern Matching
- `fls_57ic33pwdvp3` → 5.4.7 Slice Pattern Matching

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.4

**Type:** rule
**Title:** A generic association shall list an appropriate type

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust uses generics and traits instead of _Generic

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 12, 12.1, 12.3

### FLS Content

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_7nv8ualeaqe3` → 12.2 Where Clauses

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.5

**Type:** rule
**Title:** Section 5: Rules

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust uses generics and traits instead of _Generic

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 12, 12.1, 12.3

### FLS Content

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_7nv8ualeaqe3` → 12.2 Where Clauses

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.6

**Type:** rule
**Title:** The controlling expression of a generic selection shall have an

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has well-defined evaluation order in most cases; Rust uses generics and traits instead of _Generic

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_ckvjj4tt1hh2` | 6 | Expressions |
| `fls_isyftqu120l` | 6.1 | Expression Classification |
| `fls_izdv9i4spokw` | 6.5 | Operator Expressions |
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 6, 6.1, 6.5, 12, 12.1, 12.3

### FLS Content

#### `fls_ckvjj4tt1hh2`: Expressions

_File: expressions.rst, Line: 8_

**Syntax:**

- A SubjectExpression is any expression in category Expression, except StructExpression.
- A SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.

**Legality Rules:**

- An expression is a construct that produces a value, and may have side effects at run-time.
- An expression-with-block is an expression whose structure involves a block expression.
- An expression-without-block is an expression whose structure does not involve a block expression.
- An operand is an expression nested within an expression.
- A left operand is an operand that appears on the left-hand side of a binary operator.
- _... and 3 more paragraphs_

**Dynamic Semantics:**

- Evaluation is the process by which an expression achieves its runtime effects.

#### `fls_isyftqu120l`: Expression Classification

_File: expressions.rst, Line: 116_

#### `fls_izdv9i4spokw`: Operator Expressions

_File: expressions.rst, Line: 903_

**Legality Rules:**

- An operator expression is an expression that involves an operator.

**Dynamic Semantics:**

- An operator expression that operates with floating-point values run as a constant expression is allowed to yield different values compared to when run as a non-constant expression.

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_3ut3biyra4r9` → 6.1.1 Assignee Expressions
- `fls_66m4rnbssgig` → 6.1.2 Constant Expressions

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.7

**Type:** rule
**Title:** Advisory A generic selection that is expanded from a macro should evaluate its

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust has no C-style preprocessor; uses modules and declarative/procedural macros; Rust uses generics and traits instead of _Generic

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 12, 12.1, 12.3

### FLS Content

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_7nv8ualeaqe3` → 12.2 Where Clauses

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---

## Rule 23.8

**Type:** rule
**Title:** A default association shall appear as either the first or the last

### Current Mapping

| Field | Value |
|-------|-------|
| applicability_all_rust | `not_applicable` |
| applicability_safe_rust | `not_applicable` |
| misra_rust_category | `n_a` |
| confidence | `medium` |

**Notes:** Rust requires explicit casts; no implicit narrowing conversions; transmute is unsafe; Rust match is exhaustive and more powerful than C switch

### Assigned FLS IDs

| FLS ID | Section | Title |
|--------|---------|-------|
| `fls_1qhsun1vyarz` | 6.5.10 | Type Cast Expressions |
| `fls_dw33yt5g6m0k` | 4.12.3 | Type Coercion |
| `fls_exe4zodlwfez` | 4.12.2 | Type Unification |
| `fls_lv7w7aalpwm5` | 4.12.7 | Type Inference |
| `fls_e5td0fa92fay` | 6.18 | Match Expressions |
| `fls_fyskeih6twyb` | 5.4.5 | Range Pattern Matching |
| `fls_7dbd5t2750ce` | 5.2 | Struct Patterns |
| `fls_y2k5paj8m8ug` | 12 | Generics |
| `fls_vhpwge5123cm` | 12.1 | Generic Parameters |
| `fls_utuu8mdbuyxm` | 12.3 | Generic Arguments |

**FLS Sections:** 6.5.10, 4.12.3, 4.12.2, 4.12.7, 6.14, 5.4.5, 5.2, 12, 12.1, 12.3

### FLS Content

#### `fls_1qhsun1vyarz`: Type Cast Expressions

_File: expressions.rst, Line: 2118_

**Legality Rules:**

- A type cast expression is an expression that changes the type of an operand.
- Cast or casting is the process of changing the type of an expression.
- The ``TypeSpecificationWithoutBounds`` describes the target type of the type cast expression.
- A type cast expression with the following characteristics performs a specialized cast:
- A cast is legal when it either performs type coercion or is a specialized cast.
- _... and 2 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a type cast expression evaluates its operand.
- The evaluation of a numeric cast proceeds as follows:

**Examples:**

- See :p:`fls_2jd0mgw4zja4` for the declaration of ``answer``.

#### `fls_dw33yt5g6m0k`: Type Coercion

_File: types-and-traits.rst, Line: 1940_

**Legality Rules:**

- Type coercion is an implicit operation that changes the type of a value. Any implicit conversion allowed by type coercion can be made explicit using a type cast expression.
- A type coercion takes place at a coercion site or within a coercion-propagating expression.
- The following constructs constitute a coercion site:
- The following expressions constitute a coercion-propagating expression:
- Type coercion from a source type to a target type is allowed to occur when:
- _... and 5 more paragraphs_

#### `fls_exe4zodlwfez`: Type Unification

_File: types-and-traits.rst, Line: 1741_

**Legality Rules:**

- Type unification is the process by which type inference propagates known types across the type inference root and assigns concrete types to type variables, as well as a general mechanism to check for compatibility between two types during method resolution.
- A type is said to unify with another type when the domains, ranges, and structures of both types are compatible according to the rules detailed below.
- Two types that unify are said to be unifiable types.
- Type unification is a symmetric operation. If type ``A`` unifies with type ``B``, then ``B`` also unifies with ``A`` and such type unification results in the same observable effects.
- If one of the two types is a type variable, type unification proceeds as follows:
- _... and 16 more paragraphs_

#### `fls_lv7w7aalpwm5`: Type Inference

_File: types-and-traits.rst, Line: 2249_

**Legality Rules:**

- Type inference is the process of automatically determining the type of expressions and patterns within a type inference root.
- A type inference root is an expression whose inner expressions and patterns are subject to type inference independently of those found in other type inference roots.
- The following expressions are considered type inference roots:
- A type inference root imposes an expected type on its expression depending on the type inference root as follows:
- A type variable is a placeholder used during type inference to stand in for an undetermined type of an expression or a pattern.
- _... and 14 more paragraphs_

#### `fls_e5td0fa92fay`: Match Expressions

_File: expressions.rst, Line: 4622_

**Legality Rules:**

- A match expression is an expression that tries to match one of its multiple patterns against its subject expression and if it succeeds, evaluates an operand.
- A match arm is a construct that consists of a match arm matcher and a match arm body.
- An intermediate match arm is any non-[final match arm] of a match expression.
- A final match arm is the last match arm of a match expression.
- A match arm matcher is a construct that consists of a pattern and a match arm guard.
- _... and 12 more paragraphs_

**Dynamic Semantics:**

- The evaluation of a match expression proceeds as follows:
- The evaluation of a match arm matcher proceeds as follows:
- The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to ``true`` when its operand evaluates to ``true``, otherwise it evaluates to ``false``.

#### `fls_fyskeih6twyb`: Range Pattern Matching

_File: patterns.rst, Line: 1434_

**Dynamic Semantics:**

- Range pattern matching proceeds as follows:

#### `fls_7dbd5t2750ce`: Struct Patterns

_File: patterns.rst, Line: 721_

**Legality Rules:**

- A struct pattern is a pattern that matches an enum value, a struct value, or a union value.
- A deconstructee indicates the enum variant or type that is being deconstructed by a struct pattern.
- A struct pattern is interpreted based on the deconstructee. It is a static error if a struct pattern cannot be interpreted.
- A struct pattern is an irrefutable pattern if

#### `fls_y2k5paj8m8ug`: Generics

_File: generics.rst, Line: 8_

#### `fls_vhpwge5123cm`: Generic Parameters

_File: generics.rst, Line: 13_

**Legality Rules:**

- A generic parameter is a placeholder for a constant, a lifetime, or a type, whose constant, lifetime, or type is supplied statically by a generic argument.
- All LifetimeParameters in a GenericParameterList shall precede all ConstantParameters and TypeParameters.
- A generic enum is an enum with generic parameters.
- A generic function is a function with generic parameters.
- A generic implementation is an implementation with generic parameters.
- _... and 30 more paragraphs_

#### `fls_utuu8mdbuyxm`: Generic Arguments

_File: generics.rst, Line: 316_

**Legality Rules:**

- A generic argument supplies a static input for an associated trait type or a generic parameter.
- A BindingArgument shall follow ConstantArguments, LifetimeArguments, and TypeArguments in a GenericArgumentList.
- A LifetimeArgument shall precede BindingArguments, ConstantArguments, and TypeArguments in a GenericArgumentList.
- A binding argument is a generic argument that supplies the type of an associated trait type.
- A binding bound argument is a generic argument that further imposes bounds on an associated trait type.
- _... and 6 more paragraphs_

**Examples:**

- The following is a generic function with a binding argument.
- The following are generic arguments for ``func``.

### Nearby FLS Sections

_Sections near assigned IDs that might be relevant:_

- `fls_lstusiu2c8lu` → 6.5.8 Lazy Boolean Expressions
- `fls_vXGuvRWOLbEE` → ? Raw Borrow Expression
- `fls_y4by2i8dl05o` → 6.5.11 Assignment Expressions
- `fls_290jmzfh7x4e` → 6.5.12 Compound Assignment Expressions
- `fls_3gapgqys3ceb` → 4.12.1 Recursive Types
- `fls_wsfw8xF3vniL` → ? Structural Equality
- `fls_omaq7psg83n3` → 4.12.5 Interior Mutability

### Review

- [ ] FLS IDs are correct
- [ ] No missing FLS IDs
- [ ] Applicability values correct
- [ ] Notes are adequate

**Issues found:**

```
(none)
```

---
