{
  "chapter": 6,
  "title": "Expressions",
  "fls_id": "fls_ckvjj4tt1hh2",
  "file": "expressions",
  "extraction_date": "2025-12-31",
  "category_codes": {
    "0": "section",
    "-1": "general",
    "-2": "legality_rules",
    "-3": "dynamic_semantics",
    "-4": "undefined_behavior",
    "-5": "implementation_requirements",
    "-6": "implementation_permissions",
    "-7": "examples",
    "-8": "syntax"
  },
  "statistics": {
    "total_sections": 59,
    "total_paragraphs": 934,
    "paragraphs_by_category": {
      "-8": 51,
      "-7": 14,
      "-4": 3,
      "-3": 249,
      "-2": 612,
      "-1": 5
    }
  },
  "sections": [
    {
      "fls_id": "fls_ckvjj4tt1hh2",
      "title": "Expressions",
      "category": 0,
      "level": 1,
      "file": "expressions",
      "content": "Expressions\n\n ExpressionWithBlock ::=\n OuterAttributeOrDoc* (\n AsyncBlockExpression\n | BlockExpression\n | ConstBlockExpression\n | IfExpression\n | IfLetExpression\n | LoopExpression\n | MatchExpression\n | UnsafeBlockExpression\n | NamedBlockExpression\n )\n\n ExpressionWithoutBlock ::=\n OuterAttributeOrDoc* (\n ArrayExpression\n | AwaitExpression\n | BreakExpression\n | CallExpression\n | ClosureExpression\n | ContinueExpression\n | FieldAccessExpression\n | IndexExpression\n | LiteralExpression\n | MethodCallExpression\n | MacroInvocation\n | OperatorExpression\n | ParenthesizedExpression\n | PathExpression\n | RangeExpression\n | ReturnExpression\n | StructExpression\n | TupleExpression\n | UnderscoreExpression\n )\n\n ExpressionList ::=\n Expression ($$,$$ Expression)* $$,$$?\n\n Operand ::=\n Expression\n\n LeftOperand ::=\n Operand\n\n RightOperand ::=\n Operand\n\nA :ds:`SubjectExpression` is any expression in category Expression, except\nStructExpression.\n\nA :ds:`SubjectLetExpression` is any expression in category\nSubjectExpression, except LazyBooleanExpression.\n\nAn expression is a construct that produces a value, and may have\nside effects at run-time.\n\nAn expression-with-block is an expression whose structure involves a\nblock expression.\n\nAn expression-without-block is an expression whose structure does not\ninvolve a block expression.\n\nAn operand is an expression nested within an expression.\n\nA left operand is an operand that appears on the left-hand side of a\nbinary operator.\n\nA right operand is an operand that appears on the right-hand side of a\nbinary operator.\n\nA subject expression is an expression that controls [for loop]s,\n[if expression]s, and [match expression]s.\n\nA subject let expression is an expression that controls\n[if let expression]s and [while let loop]s.\n\nEvaluation is the process by which an expression achieves its runtime\neffects.",
      "rubrics": {
        "-8": {
          "paragraphs": {
            "fls_pwut2jbmk66k": "A :ds:SubjectExpression is any expression in category Expression, except StructExpression.",
            "fls_361q9ljc6ybz": "A :ds:SubjectLetExpression is any expression in category SubjectExpression, except LazyBooleanExpression.",
            "syntax_1": "Expression ::=\n       ExpressionWithBlock\n     | ExpressionWithoutBlock\n\n   ExpressionWithBlock ::=\n       OuterAttributeOrDoc* (\n           AsyncBlockExpression\n         | BlockExpression\n         | ConstBlockExpression\n         | IfExpression\n         | IfLetExpression\n         | LoopExpression\n         | MatchExpression\n         | UnsafeBlockExpression\n         | NamedBlockExpression\n       )\n\n   ExpressionWithoutBlock ::=\n       OuterAttributeOrDoc* (\n           ArrayExpression\n         | Aw..."
          }
        },
        "-2": {
          "paragraphs": {
            "fls_h5o6tgul4yor": "An expression is a construct that produces a value, and may have side effects at run-time.",
            "fls_xmklb3070sp": "An expression-with-block is an expression whose structure involves a block expression.",
            "fls_p15oeage4j0e": "An expression-without-block is an expression whose structure does not involve a block expression.",
            "fls_gwgttltgjma4": "An operand is an expression nested within an expression.",
            "fls_1r29rtnjlkql": "A left operand is an operand that appears on the left-hand side of a binary operator.",
            "fls_qxdpyf4u3hbz": "A right operand is an operand that appears on the right-hand side of a binary operator.",
            "fls_2j132xueobfv": "A subject expression is an expression that controls [for loop]s, [if expression]s, and [match expression]s.",
            "fls_a243nclqqjlu": "A subject let expression is an expression that controls [if let expression]s and [while let loop]s."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_1223lwh4nq49": "Evaluation is the process by which an expression achieves its runtime effects."
          }
        }
      },
      "parent_fls_id": null,
      "sibling_fls_ids": []
    },
    {
      "fls_id": "fls_isyftqu120l",
      "title": "Expression Classification",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Expression Classification",
      "rubrics": {},
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_3ut3biyra4r9",
      "title": "Assignee Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Assignee Expressions\n\nAn assignee expression is an expression that appears as the\nleft operand of an assignment expression. The following\n[expression]s are [assignee expression]s:\n\n* [Place expression]s,\n\n* [Underscore expression]s,\n\n* [Array expression]s of [assignee expression]s,\n\n* [Struct expression]s of [assignee expression]s.\n\n* [Tuple expression]s of [assignee expression]s,\n\n* [Tuple struct call expression]s of [assignee expression]s,\n\n[Parenthesized expression]s are allowed to appear anywhere in\n[assignee expression]s.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_oqj7s9fi3j3j": "An assignee expression is an expression that appears as the left operand of an assignment expression. The following [expression]s are [assignee expression]s:",
            "fls_skopz71arbwa": "[Place expression]s,",
            "fls_vxrg6preh46x": "[Underscore expression]s,",
            "fls_yso6dmog0an2": "[Array expression]s of [assignee expression]s,",
            "fls_1tsdlpgkgb2u": "[Struct expression]s of [assignee expression]s.",
            "fls_hier3b8knpuq": "[Tuple expression]s of [assignee expression]s,",
            "fls_horl3qcfdb0k": "[Tuple struct call expression]s of [assignee expression]s,",
            "fls_1smb3tj9pxsq": "[Parenthesized expression]s are allowed to appear anywhere in [assignee expression]s."
          }
        }
      },
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_66m4rnbssgig",
        "fls_zJOAmSr3Dbqk",
        "fls_6ydylimiv553",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_66m4rnbssgig",
      "title": "Constant Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Constant Expressions\n\nA constant expression is an expression that can be evaluated\nstatically. The following [construct]s are [constant expression]s as\nlong as their [operand]s are also [constant expression]s and do not\ninvolve [type]s that require destruction:\n\n* [Arithmetic expression]s of [scalar type]s,\n\n* [Array expression]s,\n\n* [Assignment expression]s,\n\n* [Bit expression]s of [scalar type]s,\n\n* [Block expression]s,\n\n* [Call expression]s where the callee is a constant function,\n\n* [Closure expression]s that do not capture <capturing>,\n\n* [Comparison expression]s of [scalar type]s,\n\n* [Compound assignment expression]s,\n\n* [Constant parameter]s,\n\n* [Dereference expression]s,\n\n* [Expression statement]s,\n\n* [Field access expression]s that do not invoke the core::ops::Deref\n trait,\n\n* [If expression]s,\n\n* [If let expression]s,\n\n* [Index expression]s,\n\n* [Infinite loop expression]s,\n\n* [Lazy boolean expression]s of [scalar type]s,\n\n* [Let statement]s,\n\n* [Literal expression]s,\n\n* [Match expression]s,\n\n* [Method call expression]s where the callee is a constant function or\n do not invoke the core::ops::Deref trait,\n\n* [Negation expression]s of [scalar type]s,\n\n* [Parenthesized expression]s,\n\n* [Path expression]s that resolve to [associated constant]s,\n [constant]s, [constant parameter]s, [function]s,\n [static]s, [tuple struct]s, and [unit struct]s,\n\n* [Range expression]s,\n\n* [Struct expression]s,\n\n* [Tuple expression]s,\n\n* [Type cast expression]s that are not [pointer-to-address cast]s,\n [function-pointer-to-address cast]s, and [unsized coercion]s that\n involve a trait object type,\n\n* [Unsafe block expression]s,\n\n* [While let loop expression]s,\n\n* [While loop expression]s.\n\n* All forms of [borrow]s except those of expressions that are subject to\n drop scope extension to the end of the program\n and which are either [mutable borrow]s\n or borrows of expressions that result in values with interior mutability.\n\nAn expression is not considered a constant expression when it\nexplicitly invokes an associated trait function or uses\n[arithmetic operator]s of non-builtin [type]s that invoke\ncore::ops [trait]s.\n\nIt is a static error if the size operand of an\narray repetition constructor or an array type depends on\n[generic parameter]s.\n\nA constant context is a construct that requires a\nconstant expression. The following [construct]s are\n[constant context]s:\n\n* The constant initializer of an associated constant or a\n constant,\n\n* The constant argument for a constant parameter,\n\n* The default value of a constant parameter,\n\n* The discriminant initializer of an enum variant,\n\n* The size operand of an array repetition constructor,\n\n* The size operand of an array type,\n\n* The static initializer of a static.\n\n* The block expression of a const block expression.\n\nAn invocation of the core::ptr::addr_of macro expands to a\nconstant expression allowed in any constant context and\nconstant function, subject to the same restrictions as a\nimmutable borrow expression.\n\nAn invocation of the core::panic macro expands to a\nconstant expression allowed in any constant context and\nconstant function, as long as the macro is either invoked without\narguments, or with a single string literal that does not\ncapture <capturing> formatting arguments.\n\nA constant expression is evaluated statically whenever its value is\nneeded.\n\nThe evaluation of a constant expression that results in\narithmetic overflow [panic]s.\n\nIt is a static error if a constant expression either [panic]s or\ncontrol reaches the invocation of macro core::panic.\n\nIt is a static error if the evaluation of a constant expression results in\na value that is unaligned.\n\nThe invocation of a constant function follows the dynamic semantics of a\nnon-[constant function] invocation.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_1ji7368ieg0b": "A constant expression is an expression that can be evaluated statically. The following [construct]s are [constant expression]s as long as their [operand]s are also [constant expression]s and do not involve [type]s that require destruction:",
            "fls_y6ore0iwx7e0": "[Arithmetic expression]s of [scalar type]s,",
            "fls_xguga84v3j8u": "[Array expression]s,",
            "fls_idxf02p7jogu": "[Assignment expression]s,",
            "fls_6z45ss502alt": "[Bit expression]s of [scalar type]s,",
            "fls_wqs0792nud4e": "[Block expression]s,",
            "fls_490a1b74fut6": "[Call expression]s where the callee is a constant function,",
            "fls_8nyu6phm1nji": "[Closure expression]s that do not capture <capturing>,",
            "fls_8wux08bmpse": "[Comparison expression]s of [scalar type]s,",
            "fls_v1bnk7neb82a": "[Compound assignment expression]s,",
            "fls_6fq6bvxxvhsr": "[Constant parameter]s,",
            "fls_to4e7imq2c0w": "[Dereference expression]s,",
            "fls_krtbrpwf3mh0": "[Expression statement]s,",
            "fls_3etom5uu8y4u": "[Field access expression]s that do not invoke the core::ops::Deref trait,",
            "fls_qls0wj8bmupz": "[If expression]s,",
            "fls_b5fraqx07wuo": "[If let expression]s,",
            "fls_rpapnm3afan8": "[Index expression]s,",
            "fls_fc62yaqyjpl2": "[Infinite loop expression]s,",
            "fls_kwg8a351vc7": "[Lazy boolean expression]s of [scalar type]s,",
            "fls_7mjv1xd45qr4": "[Let statement]s,",
            "fls_g7hoyfqy9mu1": "[Literal expression]s,",
            "fls_br4g7qwfczig": "[Match expression]s,",
            "fls_w4lpq9bs8tsc": "[Method call expression]s where the callee is a constant function or do not invoke the core::ops::Deref trait,",
            "fls_y1ezabo61nyk": "[Negation expression]s of [scalar type]s,",
            "fls_6tb74n6lu0wf": "[Parenthesized expression]s,",
            "fls_axwrv7b3zt55": "[Path expression]s that resolve to [associated constant]s, [constant]s, [constant parameter]s, [function]s, [static]s, [tuple struct]s, and [unit struct]s,",
            "fls_3bucpdj828bq": "[Range expression]s,",
            "fls_fobs8ebt7dhc": "[Struct expression]s,",
            "fls_dyo3o1h3keqr": "[Tuple expression]s,",
            "fls_e0a1e8ddph7": "[Type cast expression]s that are not [pointer-to-address cast]s, [function-pointer-to-address cast]s, and [unsized coercion]s that involve a trait object type,",
            "fls_zcuzhw7qkzkr": "[Unsafe block expression]s,",
            "fls_pbpzkfo1fgtz": "[While let loop expression]s,",
            "fls_qvofy4wkql0s": "[While loop expression]s.",
            "fls_zyuxqty09SDO": "All forms of [borrow]s except those of expressions that are subject to drop scope extension to the end of the program and which are either [mutable borrow]s or borrows of expressions that result in values with interior mutability.",
            "fls_3i7efddbsmn0": "An expression is not considered a constant expression when it explicitly invokes an associated trait function or uses [arithmetic operator]s of non-builtin [type]s that invoke core::ops [trait]s.",
            "fls_fmqar6o1bwqk": "It is a static error if the size operand of an array repetition constructor or an array type depends on [generic parameter]s.",
            "fls_kjhma680hz3g": "A constant context is a construct that requires a constant expression. The following [construct]s are [constant context]s:",
            "fls_ljc6jq5ksbcs": "The constant initializer of an associated constant or a constant,",
            "fls_3of516eo0kkx": "The constant argument for a constant parameter,",
            "fls_yiks5bvojncc": "The default value of a constant parameter,",
            "fls_66m2hwkju0vv": "The discriminant initializer of an enum variant,",
            "fls_fsn32kmwg65u": "The size operand of an array repetition constructor,",
            "fls_j6kffhbxdm7o": "The size operand of an array type,",
            "fls_ib8p7dfwddx2": "The static initializer of a static.",
            "fls_ucFupTeCyylb": "The block expression of a const block expression.",
            "fls_od0h3v40kjp6": "An invocation of the core::ptr::addr_of macro expands to a constant expression allowed in any constant context and constant function, subject to the same restrictions as a immutable borrow expression.",
            "fls_6sc556tz4oxd": "An invocation of the core::panic macro expands to a constant expression allowed in any constant context and constant function, as long as the macro is either invoked without arguments, or with a single string literal that does not capture <capturing> formatting arguments.",
            "fls_b1vfpvsdv38": "A constant expression is evaluated statically whenever its value is needed.",
            "fls_b46nyamfqxdu": "The evaluation of a constant expression that results in arithmetic overflow [panic]s.",
            "fls_ms9vey2wymqp": "It is a static error if a constant expression either [panic]s or control reaches the invocation of macro core::panic.",
            "fls_XopG4yS9Q4q1": "It is a static error if the evaluation of a constant expression results in a value that is unaligned."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_tg0kya5125jt": "The invocation of a constant function follows the dynamic semantics of a non-[constant function] invocation."
          }
        }
      },
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_zJOAmSr3Dbqk",
        "fls_6ydylimiv553",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_zJOAmSr3Dbqk",
      "title": "Diverging Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Diverging Expressions\n\nA diverging expression is an expression whose evaluation causes\nprogram flow to diverge from the normal evaluation order.\n\n[Diverging expression]s are:\n\n* [Break expression]s,\n\n* [Return expression]s,\n\n* [Loop expression]s that are not the target of any\n [break expression]s,\n\n* [Call expression]s and [method call expression]s if the return\n type of the call operand is the never type,\n\n* Invocations of the core::panic macro,\n\n* Any expression whose evaluation requires the evaluation of a\n diverging subexpression on all reachable control flow paths.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_oth9vFtcb9l4": "A diverging expression is an expression whose evaluation causes program flow to diverge from the normal evaluation order.",
            "fls_cmBVodJMjZi7": "[Diverging expression]s are:",
            "fls_xsOgdiIzysP1": "[Break expression]s,",
            "fls_xqxdHziqgWf5": "[Return expression]s,",
            "fls_fU91m6DCB0ip": "[Loop expression]s that are not the target of any [break expression]s,",
            "fls_4wDpAHhnWZAB": "[Call expression]s and [method call expression]s if the return type of the call operand is the never type,",
            "fls_7HA5UThwjbQj": "Invocations of the core::panic macro,",
            "fls_pdDr8Lk1GQ0T": "Any expression whose evaluation requires the evaluation of a diverging subexpression on all reachable control flow paths."
          }
        }
      },
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_66m4rnbssgig",
        "fls_6ydylimiv553",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_6ydylimiv553",
      "title": "Place Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Place Expressions\n\nA place expression is an expression that represents a memory\nlocation. The following [expression]s are [place expression]s:\n\n* [Dereference expression]s,\n\n* [Field access expression]s,\n\n* [Index expression]s,\n\n* [Parenthesized expression]s where the operand is a\n place expression,\n\n* [Path expression]s that resolve to a static or a variable.\n\n* A temporary.\n\nA mutable place expression is a place expression whose memory\nlocation can be modified. The following [place expression]s are\n[mutable place expression]s:\n\n* A dereference expression whose operand's type implements the\n core::ops::DerefMut trait,\n\n* A dereference expression whose operand's type is a\n mutable raw pointer type,\n\n* A dereference expression whose operand's type is a\n mutable reference type,\n\n* A field access expression where the container operand is a\n mutable place expression,\n\n* An index expression whose type implements the\n core::ops::IndexMut trait,\n\n* [Parenthesized expression]s where the operand is a\n mutable place expression,\n\n* A path expression that resolves to a mutable static,\n\n* A path expression that resolves to a mutable variable that is not\n currently borrowed,\n\n* A temporary.\n\nAn immutable place expression is a place expression whose memory\nlocation cannot be modified. All [place expression]s that are not\n[mutable place expression]s are [immutable place expression]s.\n\nA place expression context is a construct that may evaluate its\noperand as a memory location.\n\nThe following [construct]s are [place expression context]s:\n\n* The assignee operand of an assignment expression or a\n compound assignment expression,\n\n* The operand of a borrow expression,\n\n* The operand of a raw borrow expression,\n\n* The operand of a dereference expression,\n\n* The container operand of a field access expression,\n\n* The initialization expression of a let statement,\n\n* The operand of an implicit borrow,\n\n* The indexed operand of an index expression,\n\n* The subject let expression of an if let expression or a\n while let loop expression,\n\n* The subject expression of a match expression,\n\n* The base initializer of a struct expression.\n\nA mutable place expression context is a place expression context that\nmay evaluate its operand as a mutable memory location. The following\n[construct]s are [mutable place expression context]s:\n\n* The indexed operand of an index expression if evaluated in a\n mutable place expression context,\n\n* The assignee operand of an assignment expression or a\n compound assignment expression,\n\n* The operand of a mutable borrow expression,\n\n* The operand of a dereference expression if evaluated in a\n mutable place expression context,\n\n* The container operand of field access expression if evaluated in a\n mutable place expression context,\n\n* The subject let expression of an if let expression or a\n while let loop expression,\n\n* The operand of a mutable implicit borrow,\n\n* The initialization expression of a let statement,\n\n* The subject expression of a match expression,\n\nA place expression that is evaluated in a value expression context\nor bound by value in a pattern denotes the value held in the\nmemory location of the place expression. Such an evaluation is subject to\n[passing convention]s.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_qbrcg3cl9td": "A place expression is an expression that represents a memory location. The following [expression]s are [place expression]s:",
            "fls_jpmhibm4omm7": "[Dereference expression]s,",
            "fls_none1dykbn8c": "[Field access expression]s,",
            "fls_lj7x5dgbmg9i": "[Index expression]s,",
            "fls_anzidgx02lly": "[Parenthesized expression]s where the operand is a place expression,",
            "fls_ya05djl1d154": "[Path expression]s that resolve to a static or a variable.",
            "fls_gv4M0DE3OMwk": "A temporary.",
            "fls_ku38h562vfyl": "A mutable place expression is a place expression whose memory location can be modified. The following [place expression]s are [mutable place expression]s:",
            "fls_1tq2o2huda9l": "A dereference expression whose operand's type implements the core::ops::DerefMut trait,",
            "fls_6b4rwkrc1ap6": "A dereference expression whose operand's type is a mutable raw pointer type,",
            "fls_s4bhrpykzmm7": "A dereference expression whose operand's type is a mutable reference type,",
            "fls_xm0gm2q27x2e": "A field access expression where the container operand is a mutable place expression,",
            "fls_bt50fltfqcvn": "An index expression whose type implements the core::ops::IndexMut trait,",
            "fls_Sgfxp186GMvz": "[Parenthesized expression]s where the operand is a mutable place expression,",
            "fls_ilaqmj3hc5uv": "A path expression that resolves to a mutable static,",
            "fls_m0gbw9myylv2": "A path expression that resolves to a mutable variable that is not currently borrowed,",
            "fls_dcm3yr3y9y0a": "A temporary.",
            "fls_cPEMHZtPkctX": "An immutable place expression is a place expression whose memory location cannot be modified. All [place expression]s that are not [mutable place expression]s are [immutable place expression]s.",
            "fls_4vxi1ji93dxb": "A place expression context is a construct that may evaluate its operand as a memory location.",
            "fls_fzsrdrHnndRd": "The following [construct]s are [place expression context]s:",
            "fls_ZED5wJQVO6nf": "The assignee operand of an assignment expression or a compound assignment expression,",
            "fls_Ufz9W5vyZkv3": "The operand of a borrow expression,",
            "fls_K7SbApHPmwjM": "The operand of a raw borrow expression,",
            "fls_KxWIzoh9WwK7": "The operand of a dereference expression,",
            "fls_oV9Hd6OiFAZX": "The container operand of a field access expression,",
            "fls_NnGiNsH6Zgmp": "The initialization expression of a let statement,",
            "fls_jLZlxIHr4w2v": "The operand of an implicit borrow,",
            "fls_giZ7w1G02JSg": "The indexed operand of an index expression,",
            "fls_5yXuTLQOQ3cc": "The subject let expression of an if let expression or a while let loop expression,",
            "fls_nman7mJVSQlm": "The subject expression of a match expression,",
            "fls_JBfZuFDQg3mU": "The base initializer of a struct expression.",
            "fls_wxGAOWEVT77u": "A mutable place expression context is a place expression context that may evaluate its operand as a mutable memory location. The following [construct]s are [mutable place expression context]s:",
            "fls_qytgkbhqr5ln": "The indexed operand of an index expression if evaluated in a mutable place expression context,",
            "fls_5gy92rsi2mqm": "The assignee operand of an assignment expression or a compound assignment expression,",
            "fls_u80htrnr2ebz": "The operand of a mutable borrow expression,",
            "fls_o0feajus3jtu": "The operand of a dereference expression if evaluated in a mutable place expression context,",
            "fls_ffjx1d5dseo4": "The container operand of field access expression if evaluated in a mutable place expression context,",
            "fls_9r7dopqf1nzl": "The subject let expression of an if let expression or a while let loop expression,",
            "fls_o76QXHyrrJPG": "The operand of a mutable implicit borrow,",
            "fls_ka5b87tkf8t6": "The initialization expression of a let statement,",
            "fls_brwv1zwu37e8": "The subject expression of a match expression,",
            "fls_4axr4V0icdBP": "A place expression that is evaluated in a value expression context or bound by value in a pattern denotes the value held in the memory location of the place expression. Such an evaluation is subject to [passing convention]s."
          }
        }
      },
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_66m4rnbssgig",
        "fls_zJOAmSr3Dbqk",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_e7zgqroy2qxn",
      "title": "Value Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Value Expressions\n\nA value expression is an expression that represents a value.\nAll [expression]s that are not [place expression]s are\n[value expression]s.\n\nA value expression context is an expression context that is not a\nplace expression context.\n\nThe evaluation of a value expression in a place expression context\nshall evaluate the value expression as a temporary and then use the\ntemporary in the place expression context.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_7q4hrt6yfr9b": "A value expression is an expression that represents a value. All [expression]s that are not [place expression]s are [value expression]s.",
            "fls_pB6xlp4uAg37": "A value expression context is an expression context that is not a place expression context.",
            "fls_8uhfwqurbyqf": "The evaluation of a value expression in a place expression context shall evaluate the value expression as a temporary and then use the temporary in the place expression context."
          }
        }
      },
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_66m4rnbssgig",
        "fls_zJOAmSr3Dbqk",
        "fls_6ydylimiv553"
      ]
    },
    {
      "fls_id": "fls_h0dvogc64tfh",
      "title": "Literal Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Literal Expressions\n\nA literal expression is an expression that denotes a literal.\n\nThe type of a literal expression is the type of the corresponding\nliteral.\n\nThe value of a literal expression is the value of the\ncorresponding literal.\n\nThe evaluation of a literal expression has no effect.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_rbwwczom3agt": "A literal expression is an expression that denotes a literal.",
            "fls_w30su9x4q13r": "The type of a literal expression is the type of the corresponding literal.",
            "fls_wdpbg5xzgmwu": "The value of a literal expression is the value of the corresponding literal."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_g061yzws1m45": "The evaluation of a literal expression has no effect."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "LiteralExpression ::=\n       Literal"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_6l60b5hwnjbm",
      "title": "Path Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Path Expressions\n\nA path expression is an expression that denotes a path.\n\nA path expression shall resolve to either a constant parameter, a\nconstant, a function, a static, a tuple enum variant, a\ntuple struct, a unit enum variant, a unit struct, or a\nvariable.\n\nA path expression that resolves to a mutable static shall require\nunsafe context.\n\nThe type of a path expression is the type of the entity that\nit resolved to.\n\nThe value of a path expression is the entity that it resolved to.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_gvanx4874ycy": "A path expression is an expression that denotes a path.",
            "fls_EOkrcIj9CuhV": "A path expression shall resolve to either a constant parameter, a constant, a function, a static, a tuple enum variant, a tuple struct, a unit enum variant, a unit struct, or a variable.",
            "fls_gz67ju6l7uhn": "A path expression that resolves to a mutable static shall require unsafe context.",
            "fls_cjywisyiyti6": "The type of a path expression is the type of the entity that it resolved to.",
            "fls_5ifai8nkp5ek": "The value of a path expression is the entity that it resolved to."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "PathExpression ::=\n       UnqualifiedPathExpression\n     | QualifiedPathExpression"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_hndm19t57wby",
      "title": "Block Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Block Expressions\n\n StatementList ::=\n Statement* Expression?\n\nA block expression is an expression that sequences [expression]s\nand [statement]s.\n\nA tail expression is the last expression within a block\nexpression.\n\nWhen the remaining [lexical element]s of a StatementList match either\nan Expression or Statement they are interpreted as an Expression.\n\nThe type of a block expression is determined as follows:\n\n* If the block expression contains at least one break expression and\n has a tail expression, then the type is the unified type of\n the [break type]s of all [break expression]s and the type of the\n tail expression.\n\n* Otherwise, if the block expression contains at least one\n break expression, then the type is the unified type of the\n [break type]s of all [break expression]s.\n\n* Otherwise, if the block expression has a tail expression, then the\n type is the type of the tail expression.\n\n* Otherwise the type is the unit type.\n\nThe value of a block expression is determined as follows:\n\n* If the block expression contains at least one break expression and\n a break expression broke out the block expression, then the\n value is the break value of the break expression that\n broke out of the block expression.\n\n* Otherwise, if the block expression has a tail expression, then the\n value is the value of the tail expression.\n\n* Otherwise the value is the unit value.\n\nThe evaluation of a block expression proceeds as follows:\n\n#. Each statement is executed in declarative order.\n\n#. The tail expression is evaluated.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_nf65p0l0v0gr": "A block expression is an expression that sequences [expression]s and [statement]s.",
            "fls_tn3hj7k2lliu": "A tail expression is the last expression within a block expression.",
            "fls_DfCne8YWevLE": "When the remaining [lexical element]s of a StatementList match either an Expression or Statement they are interpreted as an Expression.",
            "fls_u4gj2lnkq9ub": "The type of a block expression is determined as follows:",
            "fls_ltEygvWDtHXE": "If the block expression contains at least one break expression and has a tail expression, then the type is the unified type of the [break type]s of all [break expression]s and the type of the tail expression.",
            "fls_97v4fnekrRXI": "Otherwise, if the block expression contains at least one break expression, then the type is the unified type of the [break type]s of all [break expression]s.",
            "fls_ob76y2ymdd27": "Otherwise, if the block expression has a tail expression, then the type is the type of the tail expression.",
            "fls_u0avbm147nyh": "Otherwise the type is the unit type.",
            "fls_1hzup0sf8l7l": "The value of a block expression is determined as follows:",
            "fls_kKZPKvJ902cw": "If the block expression contains at least one break expression and a break expression broke out the block expression, then the value is the break value of the break expression that broke out of the block expression.",
            "fls_9nmssjseq3jt": "Otherwise, if the block expression has a tail expression, then the value is the value of the tail expression.",
            "fls_a3ulnvyc1ut": "Otherwise the value is the unit value."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_elcl73psruxw": "The evaluation of a block expression proceeds as follows: #.",
            "fls_13b5n127rj92": "Each statement is executed in declarative order. #.",
            "fls_nzdpw59plr2g": "The tail expression is evaluated."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "BlockExpression ::=\n       $${$$\n         InnerAttributeOrDoc*\n         StatementList\n       $$}$$\n\n   StatementList ::=\n       Statement* Expression?"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_aadan19t5006",
      "title": "Async Blocks",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Async Blocks\n\nAn async block expression is a block expression that is specified\nwith keyword async and encapsulates behavior which is executed in\nan asynchronous manner.\n\nAn async block expression denotes a new async control flow boundary.\n\nAn async block expression is subject to capturing.\n\nThe type of an async block expression is a unique anonymous type\nthat implement the core::future::Future trait.\n\nThe value of an async block expression is a value of the\nasync block expression's type.\n\nThe evaluation of an async block expression produces a value of\nthe type of the async block expression that captures <capturing>\nthe [capture target]s of the async block expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_hhidi5ukxo": "An async block expression is a block expression that is specified with keyword async and encapsulates behavior which is executed in an asynchronous manner.",
            "fls_oisws5qykedi": "An async block expression denotes a new async control flow boundary.",
            "fls_tzclkasinpoq": "An async block expression is subject to capturing.",
            "fls_ncd0wkgtldem": "The type of an async block expression is a unique anonymous type that implement the core::future::Future trait.",
            "fls_pvnofoomgwl5": "The value of an async block expression is a value of the async block expression's type."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_9ghp5yet75y6": "The evaluation of an async block expression produces a value of the type of the async block expression that captures <capturing> the [capture target]s of the async block expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "AsyncBlockExpression ::=\n       $$async$$ $$move$$? BlockExpression"
          }
        }
      },
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_G59PiNQkVUnQ",
        "fls_0ybsR1hEo7wV",
        "fls_8wnyln2nmg4y"
      ]
    },
    {
      "fls_id": "fls_G59PiNQkVUnQ",
      "title": "Const Blocks",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Const Blocks\n\nA const block expression is a block expression that is specified\nwith keyword const and encapsulates behavior which is evaluated\nstatically.\n\nAn const block expression denotes a new control flow boundary.\n\nThe block expression of a const block expression shall be a\nconstant expression.\n\nThe type of a const block expression is the type of the\ncontaining block expression.\n\nThe value of a const block expression is the value of the\ncontained block expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_0lcunL4bo8ka": "A const block expression is a block expression that is specified with keyword const and encapsulates behavior which is evaluated statically.",
            "fls_veEGzEbpT4ny": "An const block expression denotes a new control flow boundary.",
            "fls_PiUS1hF3dv9U": "The block expression of a const block expression shall be a constant expression.",
            "fls_wuwb0SnpP6Zu": "The type of a const block expression is the type of the containing block expression.",
            "fls_2i7TD7VoQk4B": "The value of a const block expression is the value of the contained block expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ConstBlockExpression ::=\n       $$const$$ BlockExpression"
          }
        }
      },
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_aadan19t5006",
        "fls_0ybsR1hEo7wV",
        "fls_8wnyln2nmg4y"
      ]
    },
    {
      "fls_id": "fls_0ybsR1hEo7wV",
      "title": "Named Blocks",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Named Blocks\n\nA named block expression is a block expression with a label.\n\nThe type of the named block expression is the type of its\nblock expression.\n\nThe value of the named block expression is the value of its\nblock expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_J8wJNfcSAYrS": "A named block expression is a block expression with a label.",
            "fls_B4NBv2jfZLuy": "The type of the named block expression is the type of its block expression.",
            "fls_YxvAUUYAPkaq": "The value of the named block expression is the value of its block expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "NamedBlockExpression ::=\n       Label BlockExpression"
          }
        }
      },
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_aadan19t5006",
        "fls_G59PiNQkVUnQ",
        "fls_8wnyln2nmg4y"
      ]
    },
    {
      "fls_id": "fls_8wnyln2nmg4y",
      "title": "Unsafe Blocks",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Unsafe Blocks\n\nAn unsafe block expression is a block expression that is specified\nwith keyword unsafe.\n\nAn unsafe block expression allows unsafety.\n\nThe type of the unsafe block expression is the type of its\nblock expression.\n\nThe value of the unsafe block expression is the value of its\nblock expression.\n\nThe evaluation of an unsafe block expression evaluates its\nblock expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_2az5huhcxzzy": "An unsafe block expression is a block expression that is specified with keyword unsafe.",
            "fls_5ucvvja4dzoc": "An unsafe block expression allows unsafety.",
            "fls_j3mmg317q442": "The type of the unsafe block expression is the type of its block expression.",
            "fls_nygurv3x3wq6": "The value of the unsafe block expression is the value of its block expression."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_pv5gcy3tbjwo": "The evaluation of an unsafe block expression evaluates its block expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "UnsafeBlockExpression ::=\n       $$unsafe$$ BlockExpression"
          }
        }
      },
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_aadan19t5006",
        "fls_G59PiNQkVUnQ",
        "fls_0ybsR1hEo7wV"
      ]
    },
    {
      "fls_id": "fls_izdv9i4spokw",
      "title": "Operator Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Operator Expressions\n\nAn operator expression is an expression that involves an operator.\n\nAn operator expression that operates with [floating-point value]s run as a constant expression is allowed to yield different [value]s compared to when run as a non-constant expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_ursc5ynymoy": "An operator expression is an expression that involves an operator."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_lSxXWxJn0vMO": "An operator expression that operates with [floating-point value]s run as a constant expression is allowed to yield different [value]s compared to when run as a non-constant expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "OperatorExpression ::=\n       ArithmeticExpression\n     | AssignmentExpression\n     | BitExpression\n     | BorrowExpression\n     | ComparisonExpression\n     | CompoundAssignmentExpression\n     | DereferenceExpression\n     | ErrorPropagationExpression\n     | LazyBooleanExpression\n     | NegationExpression\n     | RawBorrowExpression\n     | TypeCastExpression"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_qztk0bkju9u",
      "title": "Borrow Expression",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Borrow Expression\n\nA borrow expression is an expression that borrows the value of\nits operand and creates a reference to the memory location of its\noperand.\n\nAn immutable borrow expression is a borrow expression that lacks\nkeyword mut.\n\nA mutable borrow expression is a borrow expression that has\nkeyword mut.\n\nWhen the operand of a borrow expression is a place expression,\nthe borrow expression produces a reference to the memory location\nindicated by the operand. The memory location is placed in a borrowed\nstate, or simply borrowed.\n\nThe type of a borrow expression is determined as follows:\n\n* If the borrow expression denotes an immutable borrow expression, then the\n type is &T, where T is the type of the operand.\n\n* If the borrow expression denotes a mutable borrow expression, then the\n type is &mut T, where T is the type of the operand.\n\nThe value of a borrow expression is the address of its operand.\n\nIt is a static error if a borrow expression would create an unaligned\nreference to a field in an abstract data type subject to\nattribute repr.\n\nThe evaluation of a borrow expression evaluates its operand.\n\nMutable borrow.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_nnqfkl228hjx": "A borrow expression is an expression that borrows the value of its operand and creates a reference to the memory location of its operand.",
            "fls_r7ix8webgqlm": "An immutable borrow expression is a borrow expression that lacks keyword mut.",
            "fls_50j167r4v61b": "A mutable borrow expression is a borrow expression that has keyword mut.",
            "fls_ya77l2zgtilp": "When the operand of a borrow expression is a place expression, the borrow expression produces a reference to the memory location indicated by the operand. The memory location is placed in a borrowed state, or simply borrowed.",
            "fls_chr03xll75d": "The type of a borrow expression is determined as follows:",
            "fls_5b2x5ri2w54r": "If the borrow expression denotes an immutable borrow expression, then the type is &T, where T is the type of the operand.",
            "fls_agl09ia869rk": "If the borrow expression denotes a mutable borrow expression, then the type is &mut T, where T is the type of the operand.",
            "fls_8cvmee9bzs40": "The value of a borrow expression is the address of its operand.",
            "fls_LuaPBicDlDTT": "It is a static error if a borrow expression would create an unaligned reference to a field in an abstract data type subject to attribute repr."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_2jd0mgw4zja4": "The evaluation of a borrow expression evaluates its operand."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_350qejoq9i23": "Mutable borrow."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "BorrowExpression ::=\n       $$&$$ $$mut$$? Operand",
            "syntax_2": "let ref_answer = &mut answer;"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_5cm4gkt55hjh",
      "title": "Dereference Expression",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Dereference Expression\n\nA dereference expression is an expression that obtains the pointed-to\nmemory location of its operand.\n\nWhen the operand of a dereference expression is of a pointer\ntype, the dereference expression denotes the pointed-to memory location of\nthe operand, or the dereference of the operand.\n\nThe dereference is assignable when the dereference expression is a\nmutable place expression.\n\nDereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.\n\nIf the context of a dereference expression is an\nimmutable place expression context, then the dereference expression\nis equivalent to expression *core::ops::Deref::deref(&operand).\n\nIf the context of a dereference expression is a\nmutable place expression context, then the dereference expression\nis equivalent to expression\n*core::ops::DerefMut::deref_mut(&mut operand).\n\nThe type of a dereference expression is determined as follows:\n\n* If the type of the operand is &mut T, &T, *mut T, or\n *const T, then the type is T.\n\n* Otherwise the type is associated type\n core::ops::Deref::Target.\n\nThe value of a dereference expression is determined as follows:\n\n* If the type of the operand is &mut T, &T, *mut T, or\n *const T, then the value is the pointed-to value.\n\n* Otherwise the value is the result of evaluating expression\n *core::ops::Deref::deref(&operand) or expression\n *core::ops::DerefMut::deref_mut(&mut operand) respectively.\n\nThe evaluation of a dereference expression evaluates its operand.\n\nIt is undefined behavior to dereference a raw pointer that is either\ndangling or unaligned.\n\nSee fls_350qejoq9i23 for the declaration of ref_answer.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_f6wktzofzdn1": "A dereference expression is an expression that obtains the pointed-to memory location of its operand.",
            "fls_aeh5pzpcjveq": "When the operand of a dereference expression is of a pointer type, the dereference expression denotes the pointed-to memory location of the operand, or the dereference of the operand.",
            "fls_9cc0ml2sru6x": "The dereference is assignable when the dereference expression is a mutable place expression.",
            "fls_8i4jzksxlrw0": "Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.",
            "fls_d68ddlse4zp": "If the context of a dereference expression is an immutable place expression context, then the dereference expression is equivalent to expression *core::ops::Deref::deref(&operand).",
            "fls_g73vguanbs1x": "If the context of a dereference expression is a mutable place expression context, then the dereference expression is equivalent to expression *core::ops::DerefMut::deref_mut(&mut operand).",
            "fls_8ibfqxtnahzx": "The type of a dereference expression is determined as follows:",
            "fls_7e7tka4f2f1a": "If the type of the operand is &mut T, &T, *mut T, or *const T, then the type is T.",
            "fls_y9bc691kkh6v": "Otherwise the type is associated type core::ops::Deref::Target.",
            "fls_gw49nukfveib": "The value of a dereference expression is determined as follows:",
            "fls_jjf3sz9ddfhy": "If the type of the operand is &mut T, &T, *mut T, or *const T, then the value is the pointed-to value.",
            "fls_fyend8kkpqq4": "Otherwise the value is the result of evaluating expression *core::ops::Deref::deref(&operand) or expression *core::ops::DerefMut::deref_mut(&mut operand) respectively."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_72bpdsxxbgeq": "The evaluation of a dereference expression evaluates its operand."
          }
        },
        "-4": {
          "paragraphs": {
            "fls_9wgldua1u8yt": "It is undefined behavior to dereference a raw pointer that is either dangling or unaligned."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_9ifaterm8nop": "See for the declaration of ref_answer. .. code-block:: rust let deref_answer = *ref_answer;"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "DereferenceExpression ::=\n       $$*$$ Operand"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_pocsh1neugpc",
      "title": "Error Propagation Expression",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Error Propagation Expression\n\nAn error propagation expression is an expression that either evaluates\nto a value of its operand or returns a value to the enclosing control\nflow boundary.\n\nAn error propagation expression shall appear within a control flow\nboundary.\n\nThe type of an error propagation expression is associated type\ncore::ops::Try::Output.\n\nThe value of an error propagation expression is determined as follows:\n\n* If the evaluation of the error propagation expression executed\n core::ops::Try::branch, then the value is the value of\n the core::ops::ControlFlow::Continue variant.\n\n* Otherwise control flow is returned to the end of the enclosing control\n flow boundary.\n\nThe evaluation of an error propagation expression of the form\n\nis equivalent to the evaluation the following expression:",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_8q59wbumrt5s": "An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.",
            "fls_mq2h4seoxah": "An error propagation expression shall appear within a control flow boundary.",
            "fls_ab4vhq4nwn7f": "The type of an error propagation expression is associated type core::ops::Try::Output.",
            "fls_z4zikxy2b1em": "The value of an error propagation expression is determined as follows:",
            "fls_a09614kgsspt": "If the evaluation of the error propagation expression executed core::ops::Try::branch, then the value is the value of the core::ops::ControlFlow::Continue variant.",
            "fls_8df018q7y6g": "Otherwise control flow is returned to the end of the enclosing control flow boundary."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_alk4qvfprnvy": "The evaluation of an error propagation expression of the form .. code-block:: rust expression?",
            "fls_1nnhjcgy8kdh": "is equivalent to the evaluation the following expression: .. code-block:: rust match core::ops::Try::branch(expression) { core::ops::ControlFlow::Continue(value) => value, core::ops::ControlFlow::Break(value) => core::ops::FromResidual::from_residual(value), }"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ErrorPropagationExpression ::=\n       Operand $$?$$"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_wrecura8u5ar",
      "title": "Negation Expression",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Negation Expression\n\n NegationOperator ::=\n BitwiseNegationOperator\n | SignNegationOperator\n\n BitwiseNegationOperator ::=\n $$!$$\n\n SignNegationOperator ::=\n $$-$$\n\nA negation expression is an expression that negates its operand.\n\nThe type of the operand of a negation expression with a\nBitwiseNegationOperator shall implement the core::ops::Not\ntrait.\n\nThe type of a negation expression with a BitwiseNegationOperator\nis associated type core::ops::Not::Output.\n\nThe value of a negation expression with a BitwiseNegationOperator\nis the result of core::ops::Not::not(operand).\n\nThe type of the operand of a negation expression with a\nSignNegationOperator shall implement the core::ops::Neg trait.\n\nThe type of a negation expression with a SignNegationOperator\nshall be associated type core::ops::Neg::Output.\n\nThe value of a negation expression with a SignNegationOperator is\nthe result of core::ops::Neg::neg(operand).\n\nThe evaluation of a negation expression with a\nBitwiseNegationOperator proceeds as follows:\n\n#. The operand is evaluated.\n\n#. If the type of the operand is an integer type, then the\n negation expression evaluates to the bitwise negation of the\n operand.\n\n#. If the type of the operand is bool, then the result is computed as\n follows, depending on the value of the operand:\n\n \n\n#. If the type of operand is neither an integer type nor\n bool, then core::ops::Not::not(operand) is invoked.\n\nThe evaluation of a negation expression with a\nSignNegationOperator proceeds as follows:\n\n#. The operand is evaluated.\n\n#. If the type of the operand is an integer type, then the\n negation expression evaluates to the value of the operand,\n with its sign inverted. If the result of the negation expression does\n not fit within the range of the operand type, then\n arithmetic overflow occurs.\n\n#. If the type of the operand is a floating-point type, then the\n negation expression evaluates to the value of the operand,\n with its sign inverted. No arithmetic overflow is possible.\n\n#. If the type of the operand is neither an integer type nor a\n floating-point type, then core::ops::Neg::neg(operand) is invoked.\n\nSign negation.\n\nBitwise negation.\n\nLogical negation.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_pfa81kv2mru8": "A negation expression is an expression that negates its operand.",
            "fls_plcut8vzdwox": "The type of the operand of a negation expression with a BitwiseNegationOperator shall implement the core::ops::Not trait.",
            "fls_ohu0kljfexd3": "The type of a negation expression with a BitwiseNegationOperator is associated type core::ops::Not::Output.",
            "fls_ghqvj8q71o97": "The value of a negation expression with a BitwiseNegationOperator is the result of core::ops::Not::not(operand).",
            "fls_3m4mgqnzqhri": "The type of the operand of a negation expression with a SignNegationOperator shall implement the core::ops::Neg trait.",
            "fls_u7gzm6n75rzm": "The type of a negation expression with a SignNegationOperator shall be associated type core::ops::Neg::Output.",
            "fls_9rmq7iaf092d": "The value of a negation expression with a SignNegationOperator is the result of core::ops::Neg::neg(operand)."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_yzt6pcsvj3a": "The evaluation of a negation expression with a BitwiseNegationOperator proceeds as follows: #.",
            "fls_8tgxtprtifrr": "The operand is evaluated. #.",
            "fls_rFFlt33a5RsZ": "If the type of the operand is an integer type, then the negation expression evaluates to the bitwise negation of the operand. #.",
            "fls_h7pIl1WZ8Y2t": "If the type of the operand is bool, then the result is computed as follows, depending on the value of the operand: .. list-table:: -",
            "fls_yfK3pGHzUo3x": "- **Operand** - **Result** -",
            "fls_dcNtgLq2hRZb": "- true - false -",
            "fls_sxLwuITs62sN": "- false - true #.",
            "fls_gn3dnuxm2h8m": "If the type of operand is neither an integer type nor bool, then core::ops::Not::not(operand) is invoked.",
            "fls_tsou6yz4mfte": "The evaluation of a negation expression with a SignNegationOperator proceeds as follows: #.",
            "fls_zdfgqky85r1f": "The operand is evaluated. #.",
            "fls_CutpaCFCGHQs": "If the type of the operand is an integer type, then the negation expression evaluates to the value of the operand, with its sign inverted. If the result of the negation expression does not fit within the range of the operand type, then arithmetic overflow occurs. #.",
            "fls_B2eKGWaJhFKD": "If the type of the operand is a floating-point type, then the negation expression evaluates to the value of the operand, with its sign inverted. No arithmetic overflow is possible. #.",
            "fls_uldh10k77sng": "If the type of the operand is neither an integer type nor a floating-point type, then core::ops::Neg::neg(operand) is invoked."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_uo6vv2yf8usx": "Sign negation. .. code-block:: rust -42",
            "fls_hbrg0d98jak5": "Bitwise negation. .. code-block:: rust !42",
            "fls_kqtr9c3jorvg": "Logical negation. .. code-block:: rust !false"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "NegationExpression ::=\n       NegationOperator Operand\n\n   NegationOperator ::=\n       BitwiseNegationOperator\n     | SignNegationOperator\n\n   BitwiseNegationOperator ::=\n       $$!$$\n\n   SignNegationOperator ::=\n       $$-$$"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_1k9mkv7rbezi",
      "title": "Arithmetic Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Arithmetic Expressions\n\n AdditionExpression ::=\n LeftOperand $$+$$ RightOperand\n\n DivisionExpression ::=\n LeftOperand $$/$$ RightOperand\n\n MultiplicationExpression ::=\n LeftOperand $$*$$ RightOperand\n\n RemainderExpression ::=\n LeftOperand $$%$$ RightOperand\n\n SubtractionExpression ::=\n LeftOperand $$-$$ RightOperand\n\nAn arithmetic expression is an expression that computes a value\nfrom two [operand]s using arithmetic.\n\nAn addition expression is an arithmetic expression that uses addition.\n\nThe type of the left operand of an addition expression shall\nimplement the core::ops::Add trait with the type of the\nright operand as the trait implementation type parameter.\n\nThe type of an addition expression is associated type\ncore::ops::Add::Output.\n\nThe value of an addition expression is the result of\ncore::ops::Add::add(left_operand, right_operand).\n\nA division expression is an arithmetic expression that uses division.\n\nThe type of the left operand of a division expression shall\nimplement the core::ops::Div trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a division expression is associated type\ncore::ops::Div::Output.\n\nThe value of a division expression is the result of\ncore::ops::Div::div(left_operand, right_operand).\n\nA multiplication expression is an arithmetic expression that uses\nmultiplication.\n\nThe type of the left operand of a multiplication expression\nshall implement the core::ops::Mul trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a multiplication expression is associated type\ncore::ops::Mul::Output.\n\nThe value of a multiplication expression is the result of\ncore::ops::Mul::mul(left_operand, right_operand).\n\nA remainder expression is an arithmetic expression that uses remainder\ndivision.\n\nThe type of the left operand of a remainder expression shall\nimplement the core::ops::Rem trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a remainder expression is associated type\ncore::ops::Rem::Output.\n\nThe value of a remainder expression is the result of\ncore::ops::Rem::rem(left_operand, right_operand).\n\nA subtraction expression is an arithmetic expression that uses\nsubtraction.\n\nThe type of the left operand of a subtraction expression shall\nimplement the core::ops::Sub trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a subtraction expression is associated type\ncore::ops::Sub::Output.\n\nThe value of a subtraction expression is the result of\ncore::ops::Sub::sub(left_operand, right_operand).\n\nThe evaluation of an addition expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the addition expression evaluates to the\n sum of the [operand]s, following the rules of unsigned integer addition\n for [unsigned integer type]s, two's complement addition for\n [signed integer type]s, or floating-point addition for\n [floating-point type]s. If unsigned integer addition or two's\n complement addition is performed, then the operation may result in an\n arithmetic overflow.\n\n#. Otherwise, core::ops::Add::add(left_operand, right_operand) is invoked.\n\nThe evaluation of a division expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the division expression evaluates to the\n quotient of the [operand]s, following the rules of unsigned integer\n division for [unsigned integer type]s, two's complement division for\n [signed integer type]s, or floating-point division for\n [floating-point type]s.\n\n #. If unsigned integer division is performed and the right operand is\n 0, then the operation results in a panic.\n\n #. If two's complement division is performed and the right operand is 0\n or the result does not fit in the target type, then the operation results\n in a panic.\n\n#. Otherwise, core::ops::Div::div(left_operand, right_operand) is invoked.\n\nThe evaluation of a multiplication expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the multiplication expression evaluates\n to the product of the [operand]s, following the rules of unsigned\n integer multiplication for [unsigned integer type]s, two's complement\n multiplication for [signed integer type]s, or floating-point\n multiplication for [floating-point type]s. If unsigned integer\n multiplication or two's complement multiplication is performed, then the\n operation may result in an arithmetic overflow.\n\n#. Otherwise, core::ops::Mul::mul(left_operand, right_operand) is invoked.\n\nThe evaluation of a remainder expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the remainder expression evaluates to\n the remainder of the division of the left operand by the\n right operand, following the rules of unsigned integer division for\n [unsigned integer type]s, two's complement division for\n [signed integer type]s, or floating-point division for\n [floating-point type]s.\n\n #. If unsigned integer division is performed and the right operand is\n 0, then the operation results in a panic.\n\n #. If two's complement division is performed and the right operand is 0\n or the resulting remainder does not fit in the target type, then the\n operation results in a panic.\n\n#. Otherwise, core::ops::Rem::rem(left_operand, right_operand) is invoked.\n\nThe evaluation of a subtraction expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the subtraction expression evaluates to\n the difference of the [operand]s, following the rules of unsigned\n integer subtraction for [unsigned integer type]s, two's complement\n subtraction for [signed integer type]s, or floating-point subtraction\n for [floating-point type]s. If unsigned integer subtraction or two's\n complement subtraction is performed, then the operation may result in an\n arithmetic overflow.\n\n#. Otherwise, core::ops::Sub::sub(left_operand, right_operand) is invoked.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_asibqpe3z95h": "An arithmetic expression is an expression that computes a value from two [operand]s using arithmetic.",
            "fls_kr8Opj3c7uvb": "An addition expression is an arithmetic expression that uses addition.",
            "fls_8imzo7agyx0k": "The type of the left operand of an addition expression shall implement the core::ops::Add trait with the type of the right operand as the trait implementation type parameter.",
            "fls_vk17mfv47wk9": "The type of an addition expression is associated type core::ops::Add::Output.",
            "fls_ryzhdpxgm7ii": "The value of an addition expression is the result of core::ops::Add::add(left_operand, right_operand).",
            "fls_dstca76y08ge": "A division expression is an arithmetic expression that uses division.",
            "fls_f1puss9t4btz": "The type of the left operand of a division expression shall implement the core::ops::Div trait where the type of the right operand is the trait implementation type parameter.",
            "fls_5rdrkvspw57z": "The type of a division expression is associated type core::ops::Div::Output.",
            "fls_thyq4h55mx55": "The value of a division expression is the result of core::ops::Div::div(left_operand, right_operand).",
            "fls_kf41bphvlse3": "A multiplication expression is an arithmetic expression that uses multiplication.",
            "fls_hrml95g2txcj": "The type of the left operand of a multiplication expression shall implement the core::ops::Mul trait where the type of the right operand is the trait implementation type parameter.",
            "fls_ittf4yggk7do": "The type of a multiplication expression is associated type core::ops::Mul::Output.",
            "fls_ylqm6wucq2sw": "The value of a multiplication expression is the result of core::ops::Mul::mul(left_operand, right_operand).",
            "fls_3de9ulyzuoa": "A remainder expression is an arithmetic expression that uses remainder division.",
            "fls_8fbhreyynhid": "The type of the left operand of a remainder expression shall implement the core::ops::Rem trait where the type of the right operand is the trait implementation type parameter.",
            "fls_u3jwnrqun5kl": "The type of a remainder expression is associated type core::ops::Rem::Output.",
            "fls_2ude3wrxji2p": "The value of a remainder expression is the result of core::ops::Rem::rem(left_operand, right_operand).",
            "fls_aalxhbvu8kdi": "A subtraction expression is an arithmetic expression that uses subtraction.",
            "fls_fjcv1nm8tlgf": "The type of the left operand of a subtraction expression shall implement the core::ops::Sub trait where the type of the right operand is the trait implementation type parameter.",
            "fls_9x2i1zlsm364": "The type of a subtraction expression is associated type core::ops::Sub::Output.",
            "fls_v8vekngd27sz": "The value of a subtraction expression is the result of core::ops::Sub::sub(left_operand, right_operand)."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_5nsa9zefz9cv": "The evaluation of an addition expression proceeds as follows: #.",
            "fls_u3pstd6xe43y": "The left operand is evaluated. #.",
            "fls_jjmc1xgny77": "The right operand is evaluated. #.",
            "fls_NcLf4o1dpniS": "If the type of both [operand]s is the same integer type or floating-point type, then the addition expression evaluates to the sum of the [operand]s, following the rules of unsigned integer addition for [unsigned integer type]s, two's complement addition for [signed integer type]s, or floating-point addition for [floating-point type]s. If unsigned integer addition or two's complement addition is performed, then the operation may result in an arithmetic overflow. #.",
            "fls_cayhj5hcuhcg": "Otherwise, core::ops::Add::add(left_operand, right_operand) is invoked.",
            "fls_43knkymqpj7t": "The evaluation of a division expression proceeds as follows: #.",
            "fls_62gpbubfj30w": "The left operand is evaluated. #.",
            "fls_bveocgaagk1n": "The right operand is evaluated. #.",
            "fls_zLroZh43MOtN": "If the type of both [operand]s is the same integer type or floating-point type, then the division expression evaluates to the quotient of the [operand]s, following the rules of unsigned integer division for [unsigned integer type]s, two's complement division for [signed integer type]s, or floating-point division for [floating-point type]s. #.",
            "fls_Q9dhNiICGIfr": "If unsigned integer division is performed and the right operand is 0, then the operation results in a panic. #.",
            "fls_albbLSTYtmyq": "If two's complement division is performed and the right operand is 0 or the result does not fit in the target type, then the operation results in a panic. #.",
            "fls_qd6ggdgq2hob": "Otherwise, core::ops::Div::div(left_operand, right_operand) is invoked.",
            "fls_lr2a21v5en59": "The evaluation of a multiplication expression proceeds as follows: #.",
            "fls_kpbxcdaflb06": "The left operand is evaluated. #.",
            "fls_b94ojbfukhvd": "The right operand is evaluated. #.",
            "fls_Et5gp1I7VqBX": "If the type of both [operand]s is the same integer type or floating-point type, then the multiplication expression evaluates to the product of the [operand]s, following the rules of unsigned integer multiplication for [unsigned integer type]s, two's complement multiplication for [signed integer type]s, or floating-point multiplication for [floating-point type]s. If unsigned integer multiplication or two's complement multiplication is performed, then the operation may result in an arithmetic overflow. #.",
            "fls_blyr18iao20n": "Otherwise, core::ops::Mul::mul(left_operand, right_operand) is invoked.",
            "fls_g28igfbnwfe0": "The evaluation of a remainder expression proceeds as follows: #.",
            "fls_thcumw8n8xbw": "The left operand is evaluated. #.",
            "fls_gld1u9fnsj6d": "The right operand is evaluated. #.",
            "fls_Kdr6fLrRj0Du": "If the type of both [operand]s is the same integer type or floating-point type, then the remainder expression evaluates to the remainder of the division of the left operand by the right operand, following the rules of unsigned integer division for [unsigned integer type]s, two's complement division for [signed integer type]s, or floating-point division for [floating-point type]s. #.",
            "fls_FxLnXeGT2n9u": "If unsigned integer division is performed and the right operand is 0, then the operation results in a panic. #.",
            "fls_kN0HnldvDXSg": "If two's complement division is performed and the right operand is 0 or the resulting remainder does not fit in the target type, then the operation results in a panic. #.",
            "fls_k7lmxvpkxtub": "Otherwise, core::ops::Rem::rem(left_operand, right_operand) is invoked.",
            "fls_bndpd66973ev": "The evaluation of a subtraction expression proceeds as follows: #.",
            "fls_izmfimd4yg27": "The left operand is evaluated. #.",
            "fls_ad9tc6ki8vcq": "The right operand is evaluated. #.",
            "fls_Vy0DyZqfy7Iv": "If the type of both [operand]s is the same integer type or floating-point type, then the subtraction expression evaluates to the difference of the [operand]s, following the rules of unsigned integer subtraction for [unsigned integer type]s, two's complement subtraction for [signed integer type]s, or floating-point subtraction for [floating-point type]s. If unsigned integer subtraction or two's complement subtraction is performed, then the operation may result in an arithmetic overflow. #.",
            "fls_b9g0r9vc4rou": "Otherwise, core::ops::Sub::sub(left_operand, right_operand) is invoked."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ArithmeticExpression ::=\n       AdditionExpression\n     | DivisionExpression\n     | MultiplicationExpression\n     | RemainderExpression\n     | SubtractionExpression\n\n   AdditionExpression ::=\n       LeftOperand $$+$$ RightOperand\n\n   DivisionExpression ::=\n       LeftOperand $$/$$ RightOperand\n\n   MultiplicationExpression ::=\n       LeftOperand $$*$$ RightOperand\n\n   RemainderExpression ::=\n       LeftOperand $$%$$ RightOperand\n\n   SubtractionExpression ::=\n       LeftOperand $$-$$ RightOperand"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_abp6tjbz8tpn",
      "title": "Bit Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Bit Expressions\n\n BitAndExpression ::=\n LeftOperand $$&$$ RightOperand\n\n BitOrExpression ::=\n LeftOperand $$|$$ RightOperand\n\n BitXorExpression ::=\n LeftOperand $$^$$ RightOperand\n\n ShiftLeftExpression ::=\n LeftOperand $$<<$$ RightOperand\n\n ShiftRightExpression ::=\n LeftOperand $$>>$$ RightOperand\n\nA bit expression is an expression that computes a value from two\n[operand]s using bit arithmetic.\n\nA bit and expression is a bit expression that uses bit and arithmetic.\n\nThe type of the left operand of a bit and expression shall\nimplement the core::ops::BitAnd trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a bit and expression is associated type\ncore::ops::BitAnd::Output.\n\nThe value of a bit and expression is the result of\ncore::ops::BitAnd::bitand(left_operand, right_operand).\n\nA bit or expression is a bit expression that uses bit or arithmetic.\n\nThe type of the left operand of a bit or expression shall\nimplement the core::ops::BitOr trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a bit or expression is associated type\ncore::ops::BitOr::Output.\n\nThe value of a bit or expression is the result of\ncore::ops::BitOr::bitor(left_operand, right_operand).\n\nA bit xor expression is a bit expression that uses bit exclusive or\narithmetic.\n\nThe type of the left operand of a bit xor expression shall\nimplement the core::ops::BitXor trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a bit xor expression is associated type\ncore::ops::BitXor::Output.\n\nThe value of a bit xor expression is the result of\ncore::ops::BitXor::bitxor(left_operand, right_operand).\n\nA shift left expression is a bit expression that uses bit shift left\narithmetic.\n\nThe type of the left operand of a shift left expression shall\nimplement the core::ops::Shl trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a shift left expression is associated type\ncore::ops::Shl::Output.\n\nThe value of a shift left expression is the result of\ncore::ops::Shl::shl(left_operand, right_operand).\n\nA shift right expression is a bit expression that uses bit shift right\narithmetic.\n\nThe type of the left operand of a shift right expression shall\nimplement the core::ops::Shr trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a shift right expression is associated type\ncore::ops::Shr::Output.\n\nThe value of a shift right expression is the result of\ncore::ops::Shr::shr(left_operand, right_operand).\n\nThe evaluation of a bit and expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::ops::BitAnd::bitand(left_operand, right_operand) is invoked.\n\nThe evaluation of a bit or expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::ops::BitOr::bitor(left_operand, right_operand) is invoked.\n\nThe evaluation of a bit xor expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::ops::BitXor::bitxor(left_operand, right_operand) is invoked.\n\nThe evaluation of a shift left expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the types of both [operand]s are [integer type]s, then the\n shift left expression evaluates to the value of the left operand\n whose bits are shifted left by the number of positions the right operand\n evaluates to. Vacated bits are filled with zeros. lhs << rhs evaluates\n to :math:`\\mathrm{lhs} \\times 2 ^ \\mathrm{rhs}`, casted to the type of the left\n operand. If the value of the right operand is negative or greater\n than or equal to the width of the left operand, then the operation results in\n an arithmetic overflow.\n\n#. Otherwise, core::ops::Shl::shl(left_operand, right_operand) is invoked.\n\nThe evaluation of a shift right expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the types of both [operand]s are [integer type]s, then the\n shift right expression evaluates to the value of the left operand\n whose bits are shifted right by the number of positions the right\n operand evaluates to. If the type of the left operand is any\n signed integer type and is negative, then vacated bits are filled\n with ones. Otherwise, vacated bits are filled with zeros. lhs >> rhs\n evaluates to :math:`\\mathrm{lhs} / 2^ \\mathrm{rhs}`, casted to the type of\n the left operand. If the value of the right operand is negative,\n greater than or equal to the width of the left operand, then the operation\n results in an arithmetic overflow.\n\n#. Otherwise, core::ops::Shr::shr(left_operand, right_operand) is invoked.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_3zd59yuywz6l": "A bit expression is an expression that computes a value from two [operand]s using bit arithmetic.",
            "fls_f6mmva3lbj1i": "A bit and expression is a bit expression that uses bit and arithmetic.",
            "fls_cmowpfrcelke": "The type of the left operand of a bit and expression shall implement the core::ops::BitAnd trait where the type of the right operand is the trait implementation type parameter.",
            "fls_kchprk9z6xun": "The type of a bit and expression is associated type core::ops::BitAnd::Output.",
            "fls_dimu987fw4kg": "The value of a bit and expression is the result of core::ops::BitAnd::bitand(left_operand, right_operand).",
            "fls_3136k1y6x3cu": "A bit or expression is a bit expression that uses bit or arithmetic.",
            "fls_oo2ynd8e1ys6": "The type of the left operand of a bit or expression shall implement the core::ops::BitOr trait where the type of the right operand is the trait implementation type parameter.",
            "fls_s6hkt5fg598y": "The type of a bit or expression is associated type core::ops::BitOr::Output.",
            "fls_osfse0t6ua8a": "The value of a bit or expression is the result of core::ops::BitOr::bitor(left_operand, right_operand).",
            "fls_j7ujcuthga1i": "A bit xor expression is a bit expression that uses bit exclusive or arithmetic.",
            "fls_fnywefl9nty2": "The type of the left operand of a bit xor expression shall implement the core::ops::BitXor trait where the type of the right operand is the trait implementation type parameter.",
            "fls_4f24nyx0ix0j": "The type of a bit xor expression is associated type core::ops::BitXor::Output.",
            "fls_8tb22c6zbp3": "The value of a bit xor expression is the result of core::ops::BitXor::bitxor(left_operand, right_operand).",
            "fls_caxn774ij8lk": "A shift left expression is a bit expression that uses bit shift left arithmetic.",
            "fls_1f4pc612f2a8": "The type of the left operand of a shift left expression shall implement the core::ops::Shl trait where the type of the right operand is the trait implementation type parameter.",
            "fls_8trozue35xe4": "The type of a shift left expression is associated type core::ops::Shl::Output.",
            "fls_kqntxbwnc58v": "The value of a shift left expression is the result of core::ops::Shl::shl(left_operand, right_operand).",
            "fls_t709sl4co3al": "A shift right expression is a bit expression that uses bit shift right arithmetic.",
            "fls_onutb0b9p9zj": "The type of the left operand of a shift right expression shall implement the core::ops::Shr trait where the type of the right operand is the trait implementation type parameter.",
            "fls_yq8rtwfp3nv0": "The type of a shift right expression is associated type core::ops::Shr::Output.",
            "fls_fbazfgd5m1ot": "The value of a shift right expression is the result of core::ops::Shr::shr(left_operand, right_operand)."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_f4o8xlu67okn": "The evaluation of a bit and expression proceeds as follows: #.",
            "fls_kp747xqekyrr": "The left operand is evaluated. #.",
            "fls_m0pdk78dah6n": "The right operand is evaluated. #.",
            "fls_m2hsk41hwm2j": "core::ops::BitAnd::bitand(left_operand, right_operand) is invoked.",
            "fls_p9rlmjhbnbao": "The evaluation of a bit or expression proceeds as follows: #.",
            "fls_vprp53kv64q6": "The left operand is evaluated. #.",
            "fls_d456ummq6vrk": "The right operand is evaluated. #.",
            "fls_n269ufyesndz": "core::ops::BitOr::bitor(left_operand, right_operand) is invoked.",
            "fls_i9iqtobheivu": "The evaluation of a bit xor expression proceeds as follows: #.",
            "fls_htw2tpujktwt": "The left operand is evaluated. #.",
            "fls_gf9tyu1idpjk": "The right operand is evaluated. #.",
            "fls_u5irwqswbsvu": "core::ops::BitXor::bitxor(left_operand, right_operand) is invoked.",
            "fls_2kkpr955i4lm": "The evaluation of a shift left expression proceeds as follows: #.",
            "fls_7p64lgnjxylz": "The left operand is evaluated. #.",
            "fls_ieh1itrkcnf6": "The right operand is evaluated. #.",
            "fls_f0p70y92k14f": "If the types of both [operand]s are [integer type]s, then the shift left expression evaluates to the value of the left operand whose bits are shifted left by the number of positions the right operand evaluates to. Vacated bits are filled with zeros. lhs << rhs evaluates to :math:\\mathrm{lhs} \\times 2 ^ \\mathrm{rhs}, casted to the type of the left operand. If the value of the right operand is negative or greater than or equal to the width of the left operand, then the operation results in an arithmetic overflow. #.",
            "fls_8QGbl2SBU3R0": "Otherwise, core::ops::Shl::shl(left_operand, right_operand) is invoked.",
            "fls_303r0u6ug215": "The evaluation of a shift right expression proceeds as follows: #.",
            "fls_4gxj18t6cnzq": "The left operand is evaluated. #.",
            "fls_gurl2ve58drz": "The right operand is evaluated. #.",
            "fls_r02OGonXp93A": "If the types of both [operand]s are [integer type]s, then the shift right expression evaluates to the value of the left operand whose bits are shifted right by the number of positions the right operand evaluates to. If the type of the left operand is any signed integer type and is negative, then vacated bits are filled with ones. Otherwise, vacated bits are filled with zeros. lhs >> rhs evaluates to :math:\\mathrm{lhs} / 2^ \\mathrm{rhs}, casted to the type of the left operand. If the value of the right operand is negative, greater than or equal to the width of the left operand, then the operation results in an arithmetic overflow. #.",
            "fls_xkyj83mcb9d5": "Otherwise, core::ops::Shr::shr(left_operand, right_operand) is invoked."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "BitExpression ::=\n       BitAndExpression\n     | BitOrExpression\n     | BitXOrExpression\n     | ShiftLeftExpression\n     | ShiftRightExpression\n\n   BitAndExpression ::=\n       LeftOperand $$&$$ RightOperand\n\n   BitOrExpression ::=\n       LeftOperand $$|$$ RightOperand\n\n   BitXorExpression ::=\n       LeftOperand $$^$$ RightOperand\n\n   ShiftLeftExpression ::=\n       LeftOperand $$<<$$ RightOperand\n\n   ShiftRightExpression ::=\n       LeftOperand $$>>$$ RightOperand"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_nsvzzbldhq53",
      "title": "Comparison Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Comparison Expressions\n\n EqualsExpression ::=\n LeftOperand $$==$$ RightOperand\n\n GreaterThanExpression ::=\n LeftOperand $$>$$ RightOperand\n\n GreaterThanOrEqualsExpression ::=\n LeftOperand $$>=$$ RightOperand\n\n LessThanExpression ::=\n LeftOperand $$<$$ RightOperand\n\n LessThanOrEqualsExpression ::=\n LeftOperand $$<=$$ RightOperand\n\n NotEqualsExpression ::=\n LeftOperand $$!=$$ RightOperand\n\nA comparison expression is an expression that compares the\n[value]s of two [operand]s.\n\nA comparison expression implicitly takes [shared borrow]s of its\n[operand]s.\n\nThe type of a comparison expression is type bool.\n\nAn equals expression is a comparison expression that tests equality.\n\nThe type of the left operand of an equals expression shall\nimplement the core::cmp::PartialEq trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of an equals expression is the result of\ncore::cmp::PartialEq::eq(&left_operand, &right_operand).\n\nA greater-than expression is a comparison expression that tests for a\ngreater-than relationship.\n\nThe type of the left operand of a greater-than expression shall\nimplement the core::cmp::PartialOrd trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of a greater-than expression is the result of\ncore::cmp::PartialOrd::gt(&left_operand, &right_operand).\n\nA greater-than-or-equals expression is a comparison expression that\ntests for a greater-than-or-equals relationship.\n\nThe type of the left operand of a\ngreater-than-or-equals expression shall implement the\ncore::cmp::PartialOrd trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of a greater-than-or-equals expression is the result of\ncore::cmp::PartialOrd::ge(&left_operand, &right_operand).\n\nA less-than expression is a comparison expression that tests for a\nless-than relationship.\n\nThe type of the left operand of a less-than expression shall\nimplement the core::cmp::PartialOrd trait where the type of\nthe right operand is the trait implementation type parameter.\n\nThe value of a less-than expression is the result of\ncore::cmp::PartialOrd::lt(&left_operand, &right_operand).\n\nA less-than-or-equals expression is a comparison expression that tests\nfor a less-than-or-equals relationship.\n\nThe type of the left operand of a less-than-or-equals expression\nshall implement the core::cmp::PartialOrd trait where the type\nof the right operand is the trait implementation type parameter.\n\nThe value of a less-than-or-equals expression is the result of\ncore::cmp::PartialOrd::le(&left_operand, &right_operand).\n\nA not-equals expression is a comparison expression that tests for\ninequality.\n\nThe type of the left operand of a not-equals expression shall\nimplement the core::cmp::PartialEq trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of a not-equals expression is the result of\ncore::cmp::PartialEq::ne(&left_operand, &right_operand).\n\nThe evaluation of an equals expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialEq::eq(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a greater-than expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::gt(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a greater-than-or-equals expression proceeds as\nfollows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::ge(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a less-than expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::lt(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a less-than-or-equals expression proceeds as\nfollows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::le(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a not-equals expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialEq::ne(&left_operand, &right_operand) is invoked.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_yzuceqx6nxwa": "A comparison expression is an expression that compares the [value]s of two [operand]s.",
            "fls_asfrqemqviad": "A comparison expression implicitly takes [shared borrow]s of its [operand]s.",
            "fls_9s4re3ujnfis": "The type of a comparison expression is type bool.",
            "fls_ruyho6cu7rxg": "An equals expression is a comparison expression that tests equality.",
            "fls_8echqk9po1cf": "The type of the left operand of an equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.",
            "fls_d62qfloqk2ub": "The value of an equals expression is the result of core::cmp::PartialEq::eq(&left_operand, &right_operand).",
            "fls_wapl0ir7uvbp": "A greater-than expression is a comparison expression that tests for a greater-than relationship.",
            "fls_x2s6ydvj5zyd": "The type of the left operand of a greater-than expression shall implement the core::cmp::PartialOrd trait where the type of the right operand is the trait implementation type parameter.",
            "fls_pso38dowbk91": "The value of a greater-than expression is the result of core::cmp::PartialOrd::gt(&left_operand, &right_operand).",
            "fls_7n5gol6a8lod": "A greater-than-or-equals expression is a comparison expression that tests for a greater-than-or-equals relationship.",
            "fls_hholzcbp5u3n": "The type of the left operand of a greater-than-or-equals expression shall implement the core::cmp::PartialOrd trait where the type of the right operand is the trait implementation type parameter.",
            "fls_wytygse41vzm": "The value of a greater-than-or-equals expression is the result of core::cmp::PartialOrd::ge(&left_operand, &right_operand).",
            "fls_yd4qqi39w248": "A less-than expression is a comparison expression that tests for a less-than relationship.",
            "fls_ynibdcke3etb": "The type of the left operand of a less-than expression shall implement the core::cmp::PartialOrd trait where the type of the right operand is the trait implementation type parameter.",
            "fls_xmtxkit3qpw7": "The value of a less-than expression is the result of core::cmp::PartialOrd::lt(&left_operand, &right_operand).",
            "fls_yxwe1o27u6ns": "A less-than-or-equals expression is a comparison expression that tests for a less-than-or-equals relationship.",
            "fls_6dgfieyxdan0": "The type of the left operand of a less-than-or-equals expression shall implement the core::cmp::PartialOrd trait where the type of the right operand is the trait implementation type parameter.",
            "fls_7pfsqby2saag": "The value of a less-than-or-equals expression is the result of core::cmp::PartialOrd::le(&left_operand, &right_operand).",
            "fls_w71j7i3n1kit": "A not-equals expression is a comparison expression that tests for inequality.",
            "fls_qzo1torhv5i3": "The type of the left operand of a not-equals expression shall implement the core::cmp::PartialEq trait where the type of the right operand is the trait implementation type parameter.",
            "fls_kodwkh58hmdv": "The value of a not-equals expression is the result of core::cmp::PartialEq::ne(&left_operand, &right_operand)."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_ydt9zvh0h5ex": "The evaluation of an equals expression proceeds as follows: #.",
            "fls_4vbrc31r0o60": "The left operand is evaluated. #.",
            "fls_hyy974ksbbrq": "The right operand is evaluated. #.",
            "fls_htrjqxiv3avh": "core::cmp::PartialEq::eq(&left_operand, &right_operand) is invoked.",
            "fls_1udbc4aom6ok": "The evaluation of a greater-than expression proceeds as follows: #.",
            "fls_96mt7gx5ogo0": "The left operand is evaluated. #.",
            "fls_or0i2cqxwl8o": "The right operand is evaluated. #.",
            "fls_udnhkbxpk83m": "core::cmp::PartialOrd::gt(&left_operand, &right_operand) is invoked.",
            "fls_mab6yirx77zl": "The evaluation of a greater-than-or-equals expression proceeds as follows: #.",
            "fls_2ggb7a7nhrk9": "The left operand is evaluated. #.",
            "fls_ukm97arfzsk1": "The right operand is evaluated. #.",
            "fls_wrftg7onlkmm": "core::cmp::PartialOrd::ge(&left_operand, &right_operand) is invoked.",
            "fls_irlqykpbtvd": "The evaluation of a less-than expression proceeds as follows: #.",
            "fls_udonl4c7f6pz": "The left operand is evaluated. #.",
            "fls_ebvyhqbb921g": "The right operand is evaluated. #.",
            "fls_rfomib80bnn2": "core::cmp::PartialOrd::lt(&left_operand, &right_operand) is invoked.",
            "fls_6cb4wg59wmef": "The evaluation of a less-than-or-equals expression proceeds as follows: #.",
            "fls_dkbjn7noq8n2": "The left operand is evaluated. #.",
            "fls_kezynx2xc1q7": "The right operand is evaluated. #.",
            "fls_8luq5sellcaq": "core::cmp::PartialOrd::le(&left_operand, &right_operand) is invoked.",
            "fls_c93pacid548a": "The evaluation of a not-equals expression proceeds as follows: #.",
            "fls_gqy6uuowij9e": "The left operand is evaluated. #.",
            "fls_s6sq6p8th5nt": "The right operand is evaluated. #.",
            "fls_kdga59xx4nx3": "core::cmp::PartialEq::ne(&left_operand, &right_operand) is invoked."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ComparisonExpression ::=\n       EqualsExpression\n     | GreaterThanExpression\n     | GreaterThanOrEqualsExpression\n     | LessThanExpression\n     | LessThanOrEqualsExpression\n     | NotEqualsExpression\n\n   EqualsExpression ::=\n       LeftOperand $$==$$ RightOperand\n\n   GreaterThanExpression ::=\n       LeftOperand $$>$$ RightOperand\n\n   GreaterThanOrEqualsExpression ::=\n       LeftOperand $$>=$$ RightOperand\n\n   LessThanExpression ::=\n       LeftOperand $$<$$ RightOperand\n\n   LessThanOrEqualsExpr..."
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_lstusiu2c8lu",
      "title": "Lazy Boolean Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Lazy Boolean Expressions\n\n LazyAndExpression ::=\n LeftOperand $$&&$$ RightOperand\n\n LazyOrExpression ::=\n LeftOperand $$||$$ RightOperand\n\nA lazy boolean expression is an expression that performs short circuit\nBoolean arithmetic.\n\nA lazy and expression is a lazy boolean expression that uses short\ncircuit and arithmetic.\n\nA lazy or expression is a lazy boolean expression that uses short\ncircuit or arithmetic.\n\nThe [type]s of the [operand]s of a lazy boolean expression shall\nbe type bool.\n\nThe type of a lazy boolean expression is type bool.\n\nThe value of a lazy boolean expression is either true or\nfalse.\n\nThe evaluation of a lazy and expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. If the left operand evaluated to true, then the right operand\n is evaluated and returned as the [lazy and expression]'s value.\n\n#. Otherwise the lazy and expression evaluates to false.\n\nThe evaluation of a lazy or expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. If the left operand evaluated to false, then the right operand\n is evaluated and returned as the [lazy or expression]'s value.\n\n#. Otherwise the lazy or expression evaluates to true.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_gpbvus89iy4c": "A lazy boolean expression is an expression that performs short circuit Boolean arithmetic.",
            "fls_40jya46h62yi": "A lazy and expression is a lazy boolean expression that uses short circuit and arithmetic.",
            "fls_k8u77ow5bb6c": "A lazy or expression is a lazy boolean expression that uses short circuit or arithmetic.",
            "fls_u0gwo0s2l0tn": "The [type]s of the [operand]s of a lazy boolean expression shall be type bool.",
            "fls_zas0lizgq2hn": "The type of a lazy boolean expression is type bool.",
            "fls_xdgvrd58nkoa": "The value of a lazy boolean expression is either true or false."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_ufre0ko2cwh2": "The evaluation of a lazy and expression proceeds as follows: #.",
            "fls_jugckad775kq": "The left operand is evaluated. #.",
            "fls_tmfmu3syxp2q": "If the left operand evaluated to true, then the right operand is evaluated and returned as the [lazy and expression]'s value. #.",
            "fls_srfv1d4idxy9": "Otherwise the lazy and expression evaluates to false.",
            "fls_tflikh8cmxvc": "The evaluation of a lazy or expression proceeds as follows: #.",
            "fls_p0rafjsridre": "The left operand is evaluated. #.",
            "fls_yg1348rlziw3": "If the left operand evaluated to false, then the right operand is evaluated and returned as the [lazy or expression]'s value. #.",
            "fls_yffozo2vq5xz": "Otherwise the lazy or expression evaluates to true."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "LazyBooleanExpression ::=\n       LazyAndExpression\n     | LazyOrExpression\n\n   LazyAndExpression ::=\n       LeftOperand $$&&$$ RightOperand\n\n   LazyOrExpression ::=\n       LeftOperand $$||$$ RightOperand"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_vXGuvRWOLbEE",
      "title": "Raw Borrow Expression",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Raw Borrow Expression\n\nA raw borrow expression is an expression that creates a raw pointer to the memory location of its operand without incurring a borrow.\n\nAn immutable raw borrow expression is a raw borrow expression that has keyword const.\n\nA mutable raw borrow expression is a raw borrow expression that has keyword mut.\n\nWhen the operand of a raw borrow expression is a place expression, the raw borrow expression produces a raw pointer to the memory location indicated by the operand.\n\nIt is a static error if the operand of a raw borrow expression is a temporary.\n\nThe type of a raw borrow expression is determined as follows:\n\n* If the raw borrow expression denotes an immutable raw borrow expression, then the type is *const T, where T is the type of the operand.\n\n* If the raw borrow expression denotes a mutable raw borrow expression, then the type is *mut T, where T is the type of the operand.\n\nThe value of a raw borrow expression is the address of its operand.\n\nThe evaluation of a raw borrow expression evaluates its operand.\n\nMutable raw borrow.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_TS6DvMon5h27": "A raw borrow expression is an expression that creates a raw pointer to the memory location of its operand without incurring a borrow.",
            "fls_UtjWrE2qeplQ": "An immutable raw borrow expression is a raw borrow expression that has keyword const.",
            "fls_4e7EE4a8Yvmy": "A mutable raw borrow expression is a raw borrow expression that has keyword mut.",
            "fls_gOXUWePymgGV": "When the operand of a raw borrow expression is a place expression, the raw borrow expression produces a raw pointer to the memory location indicated by the operand.",
            "fls_YBC8GrIBzZbi": "It is a static error if the operand of a raw borrow expression is a temporary.",
            "fls_Twkre8IzUa8S": "The type of a raw borrow expression is determined as follows:",
            "fls_Ki4FOzJMqtvJ": "If the raw borrow expression denotes an immutable raw borrow expression, then the type is *const T, where T is the type of the operand.",
            "fls_DJxQDBsO9hc7": "If the raw borrow expression denotes a mutable raw borrow expression, then the type is *mut T, where T is the type of the operand.",
            "fls_WlXB0AHifCdd": "The value of a raw borrow expression is the address of its operand."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_qQrV8QuGGcVO": "The evaluation of a raw borrow expression evaluates its operand."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_dTABiwAPGhdZ": "Mutable raw borrow."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "RawBorrowExpression ::=\n       $$&$$ $$raw$$ ($$const$$ | $$mut$$) Operand",
            "syntax_2": "let ref_answer = &raw mut answer;"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_1qhsun1vyarz",
      "title": "Type Cast Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Type Cast Expressions\n\nA type cast expression is an expression that changes the type of\nan operand.\n\nCast or casting is the process of changing the type of an\nexpression.\n\nThe TypeSpecificationWithoutBounds describes the target type of the\ntype cast expression.\n\nA type cast expression with the following characteristics performs a\nspecialized cast:\n\n* An operand of a numeric type and a target numeric type perform\n a numeric cast.\n\n* An operand of an enum type and a target integer type\n perform enum cast. An enum cast converts the operand to its\n discriminant, followed by a numeric cast.\n\n* An operand of type bool or type char and a\n target integer type perform primitive-to-integer cast. A\n primitive-to-integer cast\n\n * Converts an operand of type bool with value false\n to zero.\n\n * Converts an operand of type bool with value true\n to one.\n\n * Convert an operand of type char to the value of the\n corresponding code point, followed by a numeric cast.\n\n* An operand of type u8 and a target type char performs\n u8-to-char cast. A u8-to-char cast converts an operand of\n type u8 to the value of the corresponding code point.\n\n* An operand of type *const T or *mut T and a\n target type *const V or *mut V where V implements the\n core::marker::Sized trait performs pointer-to-pointer cast.\n\n* An operand of type *const T or *mut T where T implements\n the core::marker::Sized trait and a target integer type\n perform pointer-to-address cast. A pointer-to-address cast produces\n an integer that represents the machine address of the referenced memory. If\n the integer type is smaller than the type of the operand, the\n address is truncated.\n\n* An operand of integer type and target type *const V or\n *mut V where V implements the core::marker::Sized trait\n perform address-to-pointer cast. An address-to-pointer cast\n produces a pointer that interprets the integer as a machine address.\n\n* An operand of type &mut [T; N] and a target type\n *const T perform array-to-pointer cast.\n\n* An operand of a function item type and a target type\n *const V or *mut V where V implements the\n core::marker::Sized trait perform function-item-to-pointer cast.\n\n* An operand of a function item type and a target integer type\n perform function-to-address cast.\n\n* An operand of a function pointer type and a target type\n *const V or *mut V where V implements the\n core::marker::Sized trait perform\n function-pointer-to-pointer cast.\n\n* An operand of a function pointer type and a target integer type\n perform function-pointer-to-address cast. A\n function-pointer-to-address cast produces an integer that represents the\n machine address of the referenced function. If the integer type is\n smaller than the size of the function pointer type, the address is\n truncated.\n\nA cast is legal when it either performs type coercion or is a\nspecialized cast.\n\nThe type of a type cast expression is the target type.\n\nThe value of a type cast expression is the value of the\noperand after the cast.\n\nThe evaluation of a type cast expression evaluates its operand.\n\nThe evaluation of a numeric cast proceeds as follows:\n\n* Casting an operand of an integer type to a target integer type\n of the same size has no effect.\n\n* Casting an operand of an integer type to a target integer type\n with smaller size truncates the value of the operand.\n\n* Casting an operand of an integer type to a target integer type\n with a larger size either\n\n * Zero-extends the operand if the [operand]'s type is\n unsigned, or\n\n * Sign-extends the operand if the [operand]'s type is signed.\n\n* Casting an operand of a floating-point type to a target\n integer type rounds the value of the operand towards zero. In\n addition, the type cast expression\n\n * Returns zero if the operand denotes f32::NaN or f64::NaN\n respectively.\n\n * Saturates the value of the operand to the maximum value\n of the target integer type if the [operand]'s value\n exceeds the maximum value of the target integer type or denotes\n f32::INFINITY or f64::INFINITY respectively.\n\n * Saturates the value of the operand to the minimum value\n of the target integer type if the [operand]'s value\n exceeds the minimum value of the target integer type or denotes\n f32::NEG_INFINITY or f64::NEG_INFINITY respectively.\n\n* Casting an operand of an integer type to a target\n floating-point type produces the closest possible floating-point\n value. In addition, the type cast expression\n\n * Rounds the value of the operand preferring the value with an\n even least significant digit if exactly halfway between two floating-point\n numbers.\n\n * Produces f32::INFINITY or f64::INFINITY of the same sign as\n the value of the operand when the value of the operand\n causes arithmetic overflow.\n\n* Casting an operand of type f32 to a target type f64\n is perfect and lossless.\n\n* Casting an operand of type f64 to target type f32\n produces the closest possible f32 value. In addition, the\n type cast expression\n\n * Prefers the nearest value with an even least significant digit if\n exactly halfway between two floating-point numbers.\n\n * Produces f32::INFINITY of the same sign as the value of the\n operand when the value of the operand causes\n arithmetic overflow.\n\nSee fls_2jd0mgw4zja4 for the declaration of answer.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_ltioqbhl14g0": "A type cast expression is an expression that changes the type of an operand.",
            "fls_99kvyh4puy57": "Cast or casting is the process of changing the type of an expression.",
            "fls_a6midh2m0w0b": "The TypeSpecificationWithoutBounds describes the target type of the type cast expression.",
            "fls_otaxe9okhdr1": "A type cast expression with the following characteristics performs a specialized cast:",
            "fls_4s69s9pcvbn7": "An operand of a numeric type and a target numeric type perform a numeric cast.",
            "fls_le6bchl25ewz": "An operand of an enum type and a target integer type perform enum cast. An enum cast converts the operand to its discriminant, followed by a numeric cast.",
            "fls_pcromhosmnf0": "An operand of type bool or type char and a target integer type perform primitive-to-integer cast. A primitive-to-integer cast",
            "fls_al9f1t7vlsxi": "Converts an operand of type bool with value false to zero.",
            "fls_jea17f39fmsg": "Converts an operand of type bool with value true to one.",
            "fls_eb00s8fxlvjb": "Convert an operand of type char to the value of the corresponding code point, followed by a numeric cast.",
            "fls_qk5trk8wkvxb": "An operand of type u8 and a target type char performs u8-to-char cast. A u8-to-char cast converts an operand of type u8 to the value of the corresponding code point.",
            "fls_t16yzaxro5ew": "An operand of type *const T or *mut T and a target type *const V or *mut V where V implements the core::marker::Sized trait performs pointer-to-pointer cast.",
            "fls_i4zsbbmfa2fl": "An operand of type *const T or *mut T where T implements the core::marker::Sized trait and a target integer type perform pointer-to-address cast. A pointer-to-address cast produces an integer that represents the machine address of the referenced memory. If the integer type is smaller than the type of the operand, the address is truncated.",
            "fls_59mpteeczzo": "An operand of integer type and target type *const V or *mut V where V implements the core::marker::Sized trait perform address-to-pointer cast. An address-to-pointer cast produces a pointer that interprets the integer as a machine address.",
            "fls_8ccwlliqw9jx": "An operand of type &mut [T; N] and a target type *const T perform array-to-pointer cast.",
            "fls_i8txki3htx92": "An operand of a function item type and a target type *const V or *mut V where V implements the core::marker::Sized trait perform function-item-to-pointer cast.",
            "fls_6hbkvbb1c8aj": "An operand of a function item type and a target integer type perform function-to-address cast.",
            "fls_133j6xw8k4qe": "An operand of a function pointer type and a target type *const V or *mut V where V implements the core::marker::Sized trait perform function-pointer-to-pointer cast.",
            "fls_bhw2j9wjpf2x": "An operand of a function pointer type and a target integer type perform function-pointer-to-address cast. A function-pointer-to-address cast produces an integer that represents the machine address of the referenced function. If the integer type is smaller than the size of the function pointer type, the address is truncated.",
            "fls_3ww5gbk9w4ys": "A cast is legal when it either performs type coercion or is a specialized cast.",
            "fls_hhxawo12cndy": "The type of a type cast expression is the target type.",
            "fls_uuayaksl8059": "The value of a type cast expression is the value of the operand after the cast."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_syk2li8ft3rx": "The evaluation of a type cast expression evaluates its operand.",
            "fls_uqv32nthva6y": "The evaluation of a numeric cast proceeds as follows:",
            "fls_kc3gwj9x3jnr": "Casting an operand of an integer type to a target integer type of the same size has no effect.",
            "fls_76eq3bd6birr": "Casting an operand of an integer type to a target integer type with smaller size truncates the value of the operand.",
            "fls_ldiritt32h2w": "Casting an operand of an integer type to a target integer type with a larger size either",
            "fls_h9sxg3pxn7i2": "Zero-extends the operand if the [operand]'s type is unsigned, or",
            "fls_shy6e0e30bco": "Sign-extends the operand if the [operand]'s type is signed.",
            "fls_4xldaoj5ac6t": "Casting an operand of a floating-point type to a target integer type rounds the value of the operand towards zero. In addition, the type cast expression",
            "fls_50714cvaqkfv": "Returns zero if the operand denotes f32::NaN or f64::NaN respectively.",
            "fls_g3xbmp8zx1yh": "Saturates the value of the operand to the maximum value of the target integer type if the [operand]'s value exceeds the maximum value of the target integer type or denotes f32::INFINITY or f64::INFINITY respectively.",
            "fls_hcc5odh52bk7": "Saturates the value of the operand to the minimum value of the target integer type if the [operand]'s value exceeds the minimum value of the target integer type or denotes f32::NEG_INFINITY or f64::NEG_INFINITY respectively.",
            "fls_o2ep4b6t287z": "Casting an operand of an integer type to a target floating-point type produces the closest possible floating-point value. In addition, the type cast expression",
            "fls_vfofk2aagsj5": "Rounds the value of the operand preferring the value with an even least significant digit if exactly halfway between two floating-point numbers.",
            "fls_cx86k8yfjhht": "Produces f32::INFINITY or f64::INFINITY of the same sign as the value of the operand when the value of the operand causes arithmetic overflow.",
            "fls_gzmdwibl5s4w": "Casting an operand of type f32 to a target type f64 is perfect and lossless.",
            "fls_mjqvjt7v8a25": "Casting an operand of type f64 to target type f32 produces the closest possible f32 value. In addition, the type cast expression",
            "fls_4fd5vkh0jt4": "Prefers the nearest value with an even least significant digit if exactly halfway between two floating-point numbers.",
            "fls_2etd73f8jg2n": "Produces f32::INFINITY of the same sign as the value of the operand when the value of the operand causes arithmetic overflow."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_vdxkpvmpwl3s": "See for the declaration of answer. .. code-block:: rust answer as f64"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "TypeCastExpression ::=\n       Operand $$as$$ TypeSpecificationWithoutBounds"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_y4by2i8dl05o",
      "title": "Assignment Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Assignment Expressions\n\n AssigneeOperand ::=\n Operand\n\n ValueOperand ::=\n Operand\n\nAn assignment expression is an expression that assigns the value\nof a value operand to an assignee operand.\n\nAn assignee operand is the target operand of an\nassignment expression.\n\nA value operand is an operand that supplies the value that is\nassigned to an assignee operand by an assignment expression.\n\nThe type of an assignment expression is the unit type.\n\nThe value of an assignment expression is the unit value.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_nhgexeu2h6wi": "An assignment expression is an expression that assigns the value of a value operand to an assignee operand.",
            "fls_bsjw6f4a3wol": "An assignee operand is the target operand of an assignment expression.",
            "fls_uinh05sslxeo": "A value operand is an operand that supplies the value that is assigned to an assignee operand by an assignment expression.",
            "fls_qengy157fa4a": "The type of an assignment expression is the unit type.",
            "fls_bwwtgqprbxrm": "The value of an assignment expression is the unit value."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "AssignmentExpression ::=\n       AssigneeOperand $$=$$ ValueOperand\n\n   AssigneeOperand ::=\n       Operand\n\n   ValueOperand ::=\n       Operand"
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_nnqlae9zp80s",
      "title": "Basic Assignment",
      "category": 0,
      "level": 4,
      "file": "expressions",
      "content": "Basic Assignment\n\nA basic assignment is an assignment expression that is not a\ndestructuring assignment.\n\nThe evaluation of a basic assignment proceeds as follows:\n\n#. The value operand is evaluated.\n\n#. The assignee operand is evaluated.\n\n#. The value denoted by the assignee operand is dropped, unless\n the assignee operand denotes an uninitialized variable or an\n uninitialized field of a variable.\n\n#. The value of the value operand is passed <passing convention>\n into the place of the assignee operand.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_uhcodvq75nlr": "A basic assignment is an assignment expression that is not a destructuring assignment."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_esn5ceoldta": "The evaluation of a basic assignment proceeds as follows: #.",
            "fls_t8eqzc64ivin": "The value operand is evaluated. #.",
            "fls_b0mqcn5fejhk": "The assignee operand is evaluated. #.",
            "fls_9i0ctuo099bp": "The value denoted by the assignee operand is dropped, unless the assignee operand denotes an uninitialized variable or an uninitialized field of a variable. #.",
            "fls_hc01gtvlxba": "The value of the value operand is passed <passing convention> into the place of the assignee operand."
          }
        }
      },
      "parent_fls_id": "fls_y4by2i8dl05o",
      "sibling_fls_ids": [
        "fls_9beohh5475s2"
      ]
    },
    {
      "fls_id": "fls_9beohh5475s2",
      "title": "Destructuring Assignment",
      "category": 0,
      "level": 4,
      "file": "expressions",
      "content": "Destructuring Assignment\n\nA destructuring assignment is an assignment expression where\nthe assignee operand is either an array expression, a struct\nexpression, a tuple expression or a tuple struct call expression.\n\nThe assignee operand of a destructuring assignment is treated as an\nassignee pattern depending on its kind, as follows:\n\n* An array expression corresponds to a slice pattern with all the\n [subexpression]s lowered to their corresponding [pattern]s.\n\n* A full range expression corresponds to a rest pattern if inside an\n array expression, otherwise this is a static error.\n\n* A place expression corresponds to an identifier pattern with a\n unique identifier and without keyword ref, keyword mut, or\n a bound pattern.\n\n* A struct expression corresponds to a struct pattern with all the\n [subexpression]s lowered to their corresponding [pattern]s.\n\n* A tuple expression corresponds to a tuple pattern with all the\n [subexpression]s lowered to their corresponding [pattern]s.\n\n* A tuple struct call expression corresponds to a\n tuple struct pattern with all the [subexpression]s lowered to their\n corresponding [pattern]s.\n\n* An underscore expression corresponds to an underscore pattern.\n\nThe pattern that corresponds to a destructuring assignment shall be\nan irrefutable pattern.\n\nA destructuring assignment is equivalent to a block expression of the\nfollowing form:\n\n* The first statement is a let statement with its pattern\n equivalent to the lowered assignee pattern and its\n initialization expression equivalent to the value operand.\n\n* Then each bound identifier of the assignee pattern is an\n assignment expression used as a statement, as follows:\n\n* The bound identifier becomes the value operand of the new\n assignment expression, and\n\n* The corresponding expression from the assignee operand of the\n destructuring assignment becomes the assignee operand of the new\n assignment expression.\n\nThe evaluation of a destructuring assignment proceeds as follows:\n\n#. The value operand is evaluated.\n\n#. The assignee operand is evaluated by evaluating its [operand]s in\n a left-to-right order.\n\n#. Each value denoted by the assignee operand is dropped\n in left-to-right order, unless the assignee operand denotes an\n uninitialized variable or an uninitialized field of a variable.\n\n#. The value of the value operand is passed <passing convention>\n into the place of the assignee operand.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_2eheo4yo2orm": "A destructuring assignment is an assignment expression where the assignee operand is either an array expression, a struct expression, a tuple expression or a tuple struct call expression.",
            "fls_z8c3b9s9de3x": "The assignee operand of a destructuring assignment is treated as an assignee pattern depending on its kind, as follows:",
            "fls_vqb89rkkjw81": "An array expression corresponds to a slice pattern with all the [subexpression]s lowered to their corresponding [pattern]s.",
            "fls_vqj7ljrrd7wi": "A full range expression corresponds to a rest pattern if inside an array expression, otherwise this is a static error.",
            "fls_du5eybf8mocy": "A place expression corresponds to an identifier pattern with a unique identifier and without keyword ref, keyword mut, or a bound pattern.",
            "fls_hj6srmzbobid": "A struct expression corresponds to a struct pattern with all the [subexpression]s lowered to their corresponding [pattern]s.",
            "fls_uydzlfc4hjbx": "A tuple expression corresponds to a tuple pattern with all the [subexpression]s lowered to their corresponding [pattern]s.",
            "fls_fa14yfvxsbx3": "A tuple struct call expression corresponds to a tuple struct pattern with all the [subexpression]s lowered to their corresponding [pattern]s.",
            "fls_q90ikfi7ewoi": "An underscore expression corresponds to an underscore pattern.",
            "fls_4bb07tn28ivw": "The pattern that corresponds to a destructuring assignment shall be an irrefutable pattern.",
            "fls_g80a92tr2ser": "A destructuring assignment is equivalent to a block expression of the following form:",
            "fls_u0iqhbw37xvq": "The first statement is a let statement with its pattern equivalent to the lowered assignee pattern and its initialization expression equivalent to the value operand.",
            "fls_wsfhd3udt6fq": "Then each bound identifier of the assignee pattern is an assignment expression used as a statement, as follows:",
            "fls_ll6h6qcaos65": "The bound identifier becomes the value operand of the new assignment expression, and",
            "fls_ajbdn54qe6wc": "The corresponding expression from the assignee operand of the destructuring assignment becomes the assignee operand of the new assignment expression."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_l4u5hhw8tnvs": "The evaluation of a destructuring assignment proceeds as follows: #.",
            "fls_dd62w8c9n9sd": "The value operand is evaluated. #.",
            "fls_jqu2u6mdccgi": "The assignee operand is evaluated by evaluating its [operand]s in a left-to-right order. #.",
            "fls_n7nuj1lvpspc": "Each value denoted by the assignee operand is dropped in left-to-right order, unless the assignee operand denotes an uninitialized variable or an uninitialized field of a variable. #.",
            "fls_qb8u5skn8bc4": "The value of the value operand is passed <passing convention> into the place of the assignee operand."
          }
        }
      },
      "parent_fls_id": "fls_y4by2i8dl05o",
      "sibling_fls_ids": [
        "fls_nnqlae9zp80s"
      ]
    },
    {
      "fls_id": "fls_290jmzfh7x4e",
      "title": "Compound Assignment Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Compound Assignment Expressions\n\n AdditionAssignmentExpression ::=\n AssignedOperand $$+=$$ ModifyingOperand\n\n BitAndAssignmentExpression ::=\n AssignedOperand $$&=$$ ModifyingOperand\n\n BitOrAssignmentExpression ::=\n AssignedOperand $$|=$$ ModifyingOperand\n\n BitXorAssignmentExpression ::=\n AssignedOperand $$^=$$ ModifyingOperand\n\n DivisionAssignmentExpression ::=\n AssignedOperand $$/=$$ ModifyingOperand\n\n MultiplicationAssignmentExpression ::=\n AssignedOperand $$*=$$ ModifyingOperand\n\n RemainderAssignmentExpression ::=\n AssignedOperand $$%=$$ ModifyingOperand\n\n ShiftLeftAssignmentExpression ::=\n AssignedOperand $$<<=$$ ModifyingOperand\n\n ShiftRightAssignmentExpression ::=\n AssignedOperand $$>>=$$ ModifyingOperand\n\n SubtractionAssignmentExpression ::=\n AssignedOperand $$-=$$ ModifyingOperand\n\n AssignedOperand ::=\n Operand\n\n ModifyingOperand ::=\n Operand\n\nA compound assignment expression is an expression that first computes\na value from two [operand]s and then assigns the value to an\nassigned operand.\n\nA bit and assignment expression is a compound assignment expression\nthat uses bit and arithmetic.\n\nA bit or assignment expression is a compound assignment expression\nthat uses bit or arithmetic.\n\nA bit xor assignment expression is a compound assignment expression\nthat uses bit exclusive or arithmetic.\n\nA division assignment expression is a compound assignment expression\nthat uses division.\n\nA multiplication assignment expression is a\ncompound assignment expression that uses multiplication.\n\nA remainder assignment expression is a compound assignment expression\nthat uses remainder division.\n\nA shift left assignment expression is a compound assignment expression\nthat uses bit shift left arithmetic.\n\nA shift right assignment expression is a\ncompound assignment expression that uses bit shift right arithmetic.\n\nA subtraction assignment expression is a\ncompound assignment expression that uses subtraction.\n\nAn assigned operand is the target operand of a\ncompound assignment expression.\n\nA modifying operand is an operand that supplies the value that\nis used in the calculation of a compound assignment expression.\n\nAn assigned operand shall denote a mutable assignee expression.\n\nThe type of a compound assignment is the unit type.\n\nThe value of a compound assignment is the unit value.\n\nThe type of the assigned operand of an addition assignment shall\nimplement the core::ops::AddAssign trait where the type of the right\noperand is the trait implementation type parameter.\n\nThe type of the assigned operand of a bit and assignment shall\nimplement the core::ops::BitAndAssign trait where the type of\nthe modifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a bit or assignment shall\nimplement the core::ops::BitOrAssign trait where the type of\nthe modifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a bit xor assignment shall\nimplement the core::ops::BitXorAssign trait where the type of\nthe modifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a division assignment shall\nimplement the core::ops::DivAssign trait where the type of the\nmodifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a multiplication assignment\nshall implement the core::ops::MulAssign trait where the type\nof the modifying operand is the trait implementation\ntype parameter.\n\nThe type of the assigned operand of a remainder assignment shall\nimplement the core::ops::RemAssign trait where the type of the\nmodifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a shift left assignment shall\nimplement the core::ops::ShlAssign trait where the type of the\nmodifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a shift right assignment\nshall implement the core::ops::ShrAssign trait where the type\nof the modifying operand is the trait implementation\ntype parameter.\n\nThe type of the assigned operand of a subtraction assignment\nshall implement the core::ops::SubAssign trait where the type\nof the modifying operand is the trait implementation\ntype parameter.\n\nThe evaluation of a compound assignment proceeds as follows:\n\n#. If the [type]s of both [operand]s are [integer type]s or [floating-point type]s, then\n\n #. The modifying operand is evaluated.\n\n #. The assigned operand is evaluated.\n\n #. The appropriate function is invoked as indicated below.\n\n#. Otherwise\n\n #. The assigned operand is evaluated.\n\n #. The modifying operand is evaluated.\n\n #. The appropriate function is invoked as indicated below.\n\nFor an addition assignment,\ncore::ops::AddAssign::add_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a bit and assignment,\ncore::ops::BitAndAssign::bitand_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a bit or assignment,\ncore::ops::BitOrAssign::bitor_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a bit xor assignment,\ncore::ops::BitXorAssign::bitxor_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a division assignment,\ncore::ops::DivAssign::div_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a multiplication assignment,\ncore::ops::MulAssign::mul_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a remainder assignment,\ncore::ops::RemAssign::rem_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a shift left assignment,\ncore::ops::ShlAssign::shl_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a shift right assignment,\ncore::ops::ShrAssign::shr_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a subtraction assignment,\ncore::ops::SubAssign::sub_assign(&mut assigned_operand, modifying_operand)\nis invoked.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_3bu3g8o5nopc": "A compound assignment expression is an expression that first computes a value from two [operand]s and then assigns the value to an assigned operand.",
            "fls_w2hbhb989yr4": "A bit and assignment expression is a compound assignment expression that uses bit and arithmetic.",
            "fls_ak4g5112jkl": "A bit or assignment expression is a compound assignment expression that uses bit or arithmetic.",
            "fls_lkjwyy78m2vx": "A bit xor assignment expression is a compound assignment expression that uses bit exclusive or arithmetic.",
            "fls_pkzj0uigfcgm": "A division assignment expression is a compound assignment expression that uses division.",
            "fls_ndlv3k9uclz2": "A multiplication assignment expression is a compound assignment expression that uses multiplication.",
            "fls_fbp5dojti27r": "A remainder assignment expression is a compound assignment expression that uses remainder division.",
            "fls_oy9ur11k78t": "A shift left assignment expression is a compound assignment expression that uses bit shift left arithmetic.",
            "fls_s7rey2bndfei": "A shift right assignment expression is a compound assignment expression that uses bit shift right arithmetic.",
            "fls_7l7v7vigw3fu": "A subtraction assignment expression is a compound assignment expression that uses subtraction.",
            "fls_dvy201zd6oym": "An assigned operand is the target operand of a compound assignment expression.",
            "fls_9v09ayi2azpe": "A modifying operand is an operand that supplies the value that is used in the calculation of a compound assignment expression.",
            "fls_row7saf53vwd": "An assigned operand shall denote a mutable assignee expression.",
            "fls_xmgcdw9yhb55": "The type of a compound assignment is the unit type.",
            "fls_yeh6mvyvb4dp": "The value of a compound assignment is the unit value.",
            "fls_657knnsobdyu": "The type of the assigned operand of an addition assignment shall implement the core::ops::AddAssign trait where the type of the right operand is the trait implementation type parameter.",
            "fls_m942dwwmr2cl": "The type of the assigned operand of a bit and assignment shall implement the core::ops::BitAndAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_np33oqrz33mp": "The type of the assigned operand of a bit or assignment shall implement the core::ops::BitOrAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_atdpr8be2o2r": "The type of the assigned operand of a bit xor assignment shall implement the core::ops::BitXorAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_fbgwb3pdfgz": "The type of the assigned operand of a division assignment shall implement the core::ops::DivAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_8tbxq95x06yt": "The type of the assigned operand of a multiplication assignment shall implement the core::ops::MulAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_9oy9zo3x3fy3": "The type of the assigned operand of a remainder assignment shall implement the core::ops::RemAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_pdgj2xekdead": "The type of the assigned operand of a shift left assignment shall implement the core::ops::ShlAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_4uoi6k8r7mvc": "The type of the assigned operand of a shift right assignment shall implement the core::ops::ShrAssign trait where the type of the modifying operand is the trait implementation type parameter.",
            "fls_fjaz4m90cagr": "The type of the assigned operand of a subtraction assignment shall implement the core::ops::SubAssign trait where the type of the modifying operand is the trait implementation type parameter."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_eesn9kuylim": "The evaluation of a compound assignment proceeds as follows: #.",
            "fls_4nnqz4etisgw": "If the [type]s of both [operand]s are [integer type]s or [floating-point type]s, then #.",
            "fls_a2g4hs15jpiu": "The modifying operand is evaluated. #.",
            "fls_kuet16jp6ps9": "The assigned operand is evaluated. #.",
            "fls_hovju0sni9gr": "The appropriate function is invoked as indicated below. #.",
            "fls_ngimpabunzis": "Otherwise #.",
            "fls_4sbpfi12frwe": "The assigned operand is evaluated. #.",
            "fls_n5ds6ydgckvo": "The modifying operand is evaluated. #.",
            "fls_xjdu0y1slsg9": "The appropriate function is invoked as indicated below.",
            "fls_ijfmnnrdlu8n": "For an addition assignment, core::ops::AddAssign::add_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_6x7j9x354pkb": "For a bit and assignment, core::ops::BitAndAssign::bitand_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_h2cpbz2t74hy": "For a bit or assignment, core::ops::BitOrAssign::bitor_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_whj50spxz3bh": "For a bit xor assignment, core::ops::BitXorAssign::bitxor_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_d1cxq1zbt5fq": "For a division assignment, core::ops::DivAssign::div_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_48i245an2449": "For a multiplication assignment, core::ops::MulAssign::mul_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_69wr03rt0ali": "For a remainder assignment, core::ops::RemAssign::rem_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_9d970yfwmj2d": "For a shift left assignment, core::ops::ShlAssign::shl_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_p9687v3xckps": "For a shift right assignment, core::ops::ShrAssign::shr_assign(&mut assigned_operand, modifying_operand) is invoked.",
            "fls_8j408kckzzud": "For a subtraction assignment, core::ops::SubAssign::sub_assign(&mut assigned_operand, modifying_operand) is invoked."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "CompoundAssignmentExpression ::=\n       AdditionAssignmentExpression\n     | BitAndAssignmentExpression\n     | BitOrAssignmentExpression\n     | BitXorAssignmentExpression\n     | DivisionAssignmentExpression\n     | MultiplicationAssignmentExpression\n     | RemainderAssignmentExpression\n     | ShiftLeftAssignmentExpression\n     | ShiftRightAssignmentExpression\n     | SubtractionAssignmentExpression\n\n   AdditionAssignmentExpression ::=\n       AssignedOperand $$+=$$ ModifyingOperand\n\n   BitAndAssignm..."
          }
        }
      },
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o"
      ]
    },
    {
      "fls_id": "fls_tpwp86mronn2",
      "title": "Underscore Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Underscore Expressions\n\nAn underscore expression is an expression that acts as a placeholder\nin a destructuring assignment.\n\nAn underscore expression shall appear in the assigned operand of a\ndestructuring assignment.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_pydmv629vfuu": "An underscore expression is an expression that acts as a placeholder in a destructuring assignment.",
            "fls_wms3dbwjwyu4": "An underscore expression shall appear in the assigned operand of a destructuring assignment."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "UnderscoreExpression ::=\n       $$_$$"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_g0uyl7qw4c7w",
      "title": "Parenthesized Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Parenthesized Expressions\n\nA parenthesized expression is an expression that groups other\n[expression]s.\n\nThe type of a parenthesized expression is the type of its\noperand.\n\nThe value of a parenthesized expression is the value of its\noperand.\n\nThe evaluation of a parenthesized expression evaluates its\noperand.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_jhazc75w5vj": "A parenthesized expression is an expression that groups other [expression]s.",
            "fls_5d66h7naoup6": "The type of a parenthesized expression is the type of its operand.",
            "fls_xp9whcj2obk8": "The value of a parenthesized expression is the value of its operand."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_2po52gv0m021": "The evaluation of a parenthesized expression evaluates its operand."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ParenthesizedExpression ::=\n       $$($$ Operand $$)$$"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_xinykul167l",
      "title": "Array Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Array Expressions\n\n ArrayElementExpression ::=\n ArrayElementConstructor\n | ArrayRepetitionConstructor\n\n ArrayElementConstructor ::=\n ExpressionList\n\n ArrayRepetitionConstructor ::=\n RepeatOperand $$;$$ SizeOperand\n\n RepeatOperand ::=\n Operand\n\n SizeOperand ::=\n Operand\n\nAn array expression is an expression that constructs an array.\n\nAn array element constructor is an array expression that lists all\nelements of the array being constructed.\n\nAn array repetition constructor is an array expression that specifies\nhow many times an element is repeated in the array being constructed.\n\nA repeat operand is an operand that specifies the element being\nrepeated in an array repetition constructor.\n\nA size operand is an operand that specifies the size of an array\nor an array type.\n\nThe size operand shall be a constant expression.\n\nThe [type]s of the [operand]s of an array element constructor\nshall be unifiable.\n\nIf the size operand is greater than one, then the type of the\nrepeat operand shall implement the core::copy::Copy trait\nor the repeat operand shall be a path expression resolving to a\nconstant.\n\nThe type of the size operand shall be type usize.\n\nThe type of an array expression is [T; N], where T is the\nelement type and N is the size of the array. The size of an\narray is determined as follows:\n\n* If the array expression appears with an array element constructor,\n then the size is the number of [operand]s in the\n array element constructor.\n\n* Otherwise the size is the value of size operand.\n\nThe value of an array expression is the constructed array.\n\nThe evaluation of an array expression with an\narray element constructor evaluates its [operand]s in left-to-right\norder.\n\nThe evaluation of an array expression with an\narray repetition constructor proceeds as follows:\n\n#. If the value of the size operand is greater than zero, then the\n repeat operand is evaluated once and its value is\n passed <passing convention> by copy [size operand]'s\n value times.\n\n#. Otherwise the repeat operand is evaluated once.\n\nTwo dimensional array.\n\nAn array of nine 42s.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_ya9res33oxt6": "An array expression is an expression that constructs an array.",
            "fls_fwtd3b10veiw": "An array element constructor is an array expression that lists all elements of the array being constructed.",
            "fls_81jf78m5uga4": "An array repetition constructor is an array expression that specifies how many times an element is repeated in the array being constructed.",
            "fls_3y69y9ga4at7": "A repeat operand is an operand that specifies the element being repeated in an array repetition constructor.",
            "fls_2l9objtb23zn": "A size operand is an operand that specifies the size of an array or an array type.",
            "fls_9gmnjvs83d8o": "The size operand shall be a constant expression.",
            "fls_by21pey7k423": "The [type]s of the [operand]s of an array element constructor shall be unifiable.",
            "fls_x2xu2pynxy1u": "If the size operand is greater than one, then the type of the repeat operand shall implement the core::copy::Copy trait or the repeat operand shall be a path expression resolving to a constant.",
            "fls_qplsh3pdqitq": "The type of the size operand shall be type usize.",
            "fls_wmsekin1gd2y": "The type of an array expression is [T; N], where T is the element type and N is the size of the array. The size of an array is determined as follows:",
            "fls_2gto5kp9bjw8": "If the array expression appears with an array element constructor, then the size is the number of [operand]s in the array element constructor.",
            "fls_guop34ayjw2": "Otherwise the size is the value of size operand.",
            "fls_aj6tbe54v5jl": "The value of an array expression is the constructed array."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_t52in1kkyli3": "The evaluation of an array expression with an array element constructor evaluates its [operand]s in left-to-right order.",
            "fls_1kj8nlc5eb8a": "The evaluation of an array expression with an array repetition constructor proceeds as follows: #.",
            "fls_f3izbkm8607z": "If the value of the size operand is greater than zero, then the repeat operand is evaluated once and its value is passed <passing convention> by copy [size operand]'s value times. #.",
            "fls_5cs68nm54l31": "Otherwise the repeat operand is evaluated once."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_p7hcqryal5cm": "Two dimensional array.",
            "fls_izlpt6100gvk": "An array of nine 42s."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ArrayExpression ::=\n       $$[$$ ArrayElementExpression? $$]$$\n\n   ArrayElementExpression ::=\n       ArrayElementConstructor\n     | ArrayRepetitionConstructor\n\n   ArrayElementConstructor ::=\n       ExpressionList\n\n   ArrayRepetitionConstructor ::=\n       RepeatOperand $$;$$ SizeOperand\n\n   RepeatOperand ::=\n       Operand\n\n   SizeOperand ::=\n       Operand",
            "syntax_2": "[[0, 0], [0, 1], [1, 0], [1, 1]]",
            "syntax_3": "[42; 9]"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_sxcr4aa098i6",
      "title": "Indexing Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Indexing Expressions\n\n IndexedOperand ::=\n Operand\n\n IndexingOperand ::=\n Operand\n\nAn indexable type is a type that implements the\ncore::ops::Index trait.\n\nAn index expression is an expression that indexes into a value\nof an indexable type.\n\nAn indexed operand is an operand which indicates the value\nbeing indexed into by an index expression.\n\nAn indexing operand is an operand which specifies the index of an\nindex expression.\n\nAn index expression is a constant expression if the\nindexing operand and indexed operand are [constant expression]s.\n\nThe type of the indexing operand is the generic parameter of the\ncore::ops::Index implementation of the type of the\nindexed operand.\n\nIf the indexed operand is evaluated in a value expression context,\nthen\n\n* The type of the indexed operand shall implement the\n core::ops::Index trait.\n\n* The type of the index expression is &T, where T is\n associated type core::ops::Index::Output.\n\nIf the indexed operand is mutable and the index expression is\nevaluated in a mutable place expression context, then\n\n* The type of the indexed operand shall implement the\n core::ops::IndexMut trait.\n\n* The type of the index expression is &mut T, where T is\n the element type of the indexed operand's type.\n\nThe value of an index expression is the indexed memory location.\n\nThe evaluation of an index expression proceeds as follows:\n\n#. The indexed operand is evaluated.\n\n#. The indexing operand is evaluated.\n\n#. If the index expression is evaluated in a mutable place\n expression context, then expression\n *core::ops::IndexMut::index_mut(&mut indexed_operand, indexing_operand)\n is evaluated.\n\n#. Otherwise expression *core::ops::Index::index(&indexed_operand,\n indexing_operand) is evaluated.\n\nEvaluates to 6.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_X9kdEAPTqsAe": "An indexable type is a type that implements the core::ops::Index trait.",
            "fls_42ijvuqqqlvh": "An index expression is an expression that indexes into a value of an indexable type.",
            "fls_pc0c22asgzvw": "An indexed operand is an operand which indicates the value being indexed into by an index expression.",
            "fls_ff3sgpldn52o": "An indexing operand is an operand which specifies the index of an index expression.",
            "fls_w96p9oyv5mqt": "An index expression is a constant expression if the indexing operand and indexed operand are [constant expression]s.",
            "fls_u9sl7h4i8hqu": "The type of the indexing operand is the generic parameter of the core::ops::Index implementation of the type of the indexed operand.",
            "fls_98qeczwv7fmy": "If the indexed operand is evaluated in a value expression context, then",
            "fls_sb2b8gszzaxq": "The type of the indexed operand shall implement the core::ops::Index trait.",
            "fls_issaykiuha75": "The type of the index expression is &T, where T is associated type core::ops::Index::Output.",
            "fls_y3sduoma6q9v": "If the indexed operand is mutable and the index expression is evaluated in a mutable place expression context, then",
            "fls_ld7lbvqms5i6": "The type of the indexed operand shall implement the core::ops::IndexMut trait.",
            "fls_nw705fpon79b": "The type of the index expression is &mut T, where T is the element type of the indexed operand's type.",
            "fls_fouu0z3jwoad": "The value of an index expression is the indexed memory location."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_6sgj0ltt21i": "The evaluation of an index expression proceeds as follows: #.",
            "fls_e5l4y3dy69xi": "The indexed operand is evaluated. #.",
            "fls_fza3omn8yw7s": "The indexing operand is evaluated. #.",
            "fls_ehamppbq4gmg": "If the index expression is evaluated in a mutable place expression context, then expression *core::ops::IndexMut::index_mut(&mut indexed_operand, indexing_operand) is evaluated. #.",
            "fls_i68oxj659hc1": "Otherwise expression *core::ops::Index::index(&indexed_operand, indexing_operand) is evaluated."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_esvpmh6razg3": "Evaluates to 6."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "IndexExpression ::=\n       IndexedOperand $$[$$ IndexingOperand $$]$$\n\n   IndexedOperand ::=\n       Operand\n\n   IndexingOperand ::=\n       Operand"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_k64tfywtn0g8",
      "title": "Tuple Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Tuple Expressions\n\n TupleInitializerList ::=\n ExpressionList\n\nA tuple expression is an expression that constructs a tuple.\n\nA tuple initializer is an operand that provides the value of a\ntuple field in a tuple expression.\n\nThe type of a tuple expression is (T1, T2, ..., TN), where T1\nis the type of the first tuple initializer, T2 is the type of\nthe second tuple initializer, and TN is the type of the N-th\ntuple initializer.\n\nThe value of a tuple expression is (V1, V2, ..., VN), where V1\nis the value of the first tuple initializer, V2 is the value\nof the second tuple initializer, and VN is the value of the\nN-th tuple initializer.\n\nThe evaluation of a tuple expression evaluates its\n[tuple initializer]s in left-to-right order.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_87rp1hfwvjel": "A tuple expression is an expression that constructs a tuple.",
            "fls_581y6jq1eyn8": "A tuple initializer is an operand that provides the value of a tuple field in a tuple expression.",
            "fls_ljz3sxmfzflm": "The type of a tuple expression is (T1, T2, ..., TN), where T1 is the type of the first tuple initializer, T2 is the type of the second tuple initializer, and TN is the type of the N-th tuple initializer.",
            "fls_k2aznqo9j49p": "The value of a tuple expression is (V1, V2, ..., VN), where V1 is the value of the first tuple initializer, V2 is the value of the second tuple initializer, and VN is the value of the N-th tuple initializer."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_waf55yd3mpsq": "The evaluation of a tuple expression evaluates its [tuple initializer]s in left-to-right order."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "TupleExpression ::=\n       $$($$ TupleInitializerList? $$)$$\n\n   TupleInitializerList ::=\n       ExpressionList"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_8tsynkj2cufj",
      "title": "Struct Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Struct Expressions\n\n Constructee ::=\n PathExpression\n\n StructExpressionContent ::=\n BaseInitializer\n | FieldInitializerList ($$,$$ BaseInitializer | $$,$$?)\n\n BaseInitializer ::=\n $$..$$ Operand\n\n FieldInitializerList ::=\n FieldInitializer ($$,$$ FieldInitializer)*\n\n FieldInitializer ::=\n IndexedInitializer\n | NamedInitializer\n | ShorthandInitializer\n\n IndexedInitializer ::=\n FieldIndex $$:$$ Expression\n\n NamedInitializer ::=\n Identifier $$:$$ Expression\n\n ShorthandInitializer ::=\n Identifier\n\nA struct expression is an expression that constructs an\nenum value, a struct value, or a union value.\n\nA constructee indicates the enum variant, struct, or union\nwhose value is being constructed by a struct expression.\n\nA base initializer is a construct that specifies an enum value, or\na struct value to be used as a base for\nconstruction in a struct expression.\n\nThe type of a base initializer is the type of its operand.\nThe type of a base initializer shall be the same as the type of\nthe constructee.\n\nAn indexed initializer is a construct that specifies the index and\ninitial value of a field in a struct expression.\n\nAn indexed initializer matches a field of the constructee\nwhen the field index of the indexed initializer resolves to a valid\nposition of a field in the constructee. Such an\nindexed initializer is a matched indexed initializer.\n\nThe type of the operand of an indexed initializer and the\ntype of the matched field shall be unifiable.\n\nThe value of an indexed initializer is the value of its\noperand.\n\nA named initializer is a construct that specifies the name and\ninitial value of a field in a struct expression.\n\nA named initializer matches a field of the constructee when\nits identifier and the name of the field are the same. Such a\nnamed initializer is a matched named initializer.\n\nThe type of a named initializer and the type of the matched\nfield shall be unifiable.\n\nThe value of a named initializer is the value of its\nexpression.\n\nA shorthand initializer is a construct that specifies the name\nof a field in a struct expression.\n\nA shorthand initializer is equivalent to a named initializer where\nboth the identifier and the expression of the named initializer\ndenote the identifier of the shorthand initializer.\n\nA shorthand initializer matches a field of the constructee\nwhen its identifier and the name of the field are the same. Such\na shorthand initializer is a matched shorthand initializer.\n\nThe type of a shorthand initializer and the type of the matched\nfield shall be unifiable.\n\nThe value of a shorthand initializer is the value its\nidentifier resolves to.\n\nThe type of a struct expression is the type of the\nconstructee.\n\nThe value of a struct expression is the enum value,\nstruct value, or union value in construction.\n\nIf the constructee is a record enum variant or a record struct,\nthen\n\n* For each field of the constructee, the struct expression shall\n either:\n\n * Contain at most one matched named initializer, or\n\n * Contain at most one matched shorthand initializer, or\n\n * Have exactly one base initializer.\n\n* A base initializer is allowed even if all [field]s of the\n constructee have been matched.\n\nIf the constructee is a tuple enum variant or a tuple struct,\nthen\n\n* For each field of the constructee, the struct expression shall\n either:\n\n * Contain at most one matched indexed initializer, or\n\n * Have exactly one base initializer.\n\n* A base initializer is allowed even if all [field]s of the\n constructee have been matched.\n\nIf the constructee is a union type, then\n\n* The struct expression shall not contain a base initializer.\n\n* For the single field of the constructee, the struct expression\n shall either:\n\n * Contain exactly one matched named initializer, or\n\n * Contain exactly one matched shorthand initializer.\n\nIf the constructee is a unit enum variant or a unit struct, then\nthe struct expression shall have at most one base initializer.\n\nIf a base initializer is supplied, then for each field that was not\nmatched in the struct expression the value of the corresponding\nfield of the base initializer is passed <passing convention> to\nthe field of the constructee.\n\nThe evaluation of a struct expression evaluates its [operand]s in\na left-to-right order.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_ij8rebvupb85": "A struct expression is an expression that constructs an enum value, a struct value, or a union value.",
            "fls_4z91ymz3ciup": "A constructee indicates the enum variant, struct, or union whose value is being constructed by a struct expression.",
            "fls_uib1ml41mfrn": "A base initializer is a construct that specifies an enum value, or a struct value to be used as a base for construction in a struct expression.",
            "fls_gfu267bpl9ql": "The type of a base initializer is the type of its operand. The type of a base initializer shall be the same as the type of the constructee.",
            "fls_ph7fsphbpbv4": "An indexed initializer is a construct that specifies the index and initial value of a field in a struct expression.",
            "fls_y3p6rtm7ek3l": "An indexed initializer matches a field of the constructee when the field index of the indexed initializer resolves to a valid position of a field in the constructee. Such an indexed initializer is a matched indexed initializer.",
            "fls_dfajs3xaxbv": "The type of the operand of an indexed initializer and the type of the matched field shall be unifiable.",
            "fls_e5b9n910z1cp": "The value of an indexed initializer is the value of its operand.",
            "fls_lwyq3vyc91rn": "A named initializer is a construct that specifies the name and initial value of a field in a struct expression.",
            "fls_qed1pps827dv": "A named initializer matches a field of the constructee when its identifier and the name of the field are the same. Such a named initializer is a matched named initializer.",
            "fls_b60omrhc7t73": "The type of a named initializer and the type of the matched field shall be unifiable.",
            "fls_z3gj1v6g605r": "The value of a named initializer is the value of its expression.",
            "fls_57t368kema7h": "A shorthand initializer is a construct that specifies the name of a field in a struct expression.",
            "fls_sm2hx8sh4agb": "A shorthand initializer is equivalent to a named initializer where both the identifier and the expression of the named initializer denote the identifier of the shorthand initializer.",
            "fls_yjx1t3x6qpfg": "A shorthand initializer matches a field of the constructee when its identifier and the name of the field are the same. Such a shorthand initializer is a matched shorthand initializer.",
            "fls_2dajkhq58cdp": "The type of a shorthand initializer and the type of the matched field shall be unifiable.",
            "fls_9s4znhi0u3ys": "The value of a shorthand initializer is the value its identifier resolves to.",
            "fls_i31rodt42m0z": "The type of a struct expression is the type of the constructee.",
            "fls_sjwd8o5mknjo": "The value of a struct expression is the enum value, struct value, or union value in construction.",
            "fls_ccqomsereni2": "If the constructee is a record enum variant or a record struct, then",
            "fls_pivpdyr4seez": "For each field of the constructee, the struct expression shall either:",
            "fls_bbmm5vir9xos": "Contain at most one matched named initializer, or",
            "fls_9370n5xkkzce": "Contain at most one matched shorthand initializer, or",
            "fls_rclgwzdhfjj": "Have exactly one base initializer.",
            "fls_lmxz5768v5d8": "A base initializer is allowed even if all [field]s of the constructee have been matched.",
            "fls_939cugbxju5e": "If the constructee is a tuple enum variant or a tuple struct, then",
            "fls_c34qwhaq2asm": "For each field of the constructee, the struct expression shall either:",
            "fls_j2kmp1fee0g4": "Contain at most one matched indexed initializer, or",
            "fls_90q7krxazc6u": "Have exactly one base initializer.",
            "fls_qo05owpmtag0": "A base initializer is allowed even if all [field]s of the constructee have been matched.",
            "fls_ywh3nk6emwmw": "If the constructee is a union type, then",
            "fls_5w9lj5dc84p": "The struct expression shall not contain a base initializer.",
            "fls_5zceer19mhdu": "For the single field of the constructee, the struct expression shall either:",
            "fls_mq80i8fof7sx": "Contain exactly one matched named initializer, or",
            "fls_raon1c1vrhx7": "Contain exactly one matched shorthand initializer.",
            "fls_njder5r7y5fg": "If the constructee is a unit enum variant or a unit struct, then the struct expression shall have at most one base initializer.",
            "fls_w7x9wy6t0qcp": "If a base initializer is supplied, then for each field that was not matched in the struct expression the value of the corresponding field of the base initializer is passed <passing convention> to the field of the constructee."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_vsxsbqps64o": "The evaluation of a struct expression evaluates its [operand]s in a left-to-right order."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "StructExpression ::=\n       Constructee $${$$ StructExpressionContent? $$}$$\n\n   Constructee ::=\n       PathExpression\n\n   StructExpressionContent ::=\n       BaseInitializer\n     | FieldInitializerList ($$,$$ BaseInitializer | $$,$$?)\n\n   BaseInitializer ::=\n       $$..$$ Operand\n\n   FieldInitializerList ::=\n       FieldInitializer ($$,$$ FieldInitializer)*\n\n   FieldInitializer ::=\n       IndexedInitializer\n     | NamedInitializer\n     | ShorthandInitializer\n\n   IndexedInitializer ::=\n       Fie..."
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_mjVXiDQRIAzU",
      "title": "Invocation Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Invocation Expressions",
      "rubrics": {},
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_xa4nbfas01cj",
      "title": "Call Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Call Expressions\n\n CallOperand ::=\n Operand\n\n ArgumentOperandList ::=\n ExpressionList\n\nA call expression is an expression that invokes a function or\nconstructs a tuple enum variant value or a tuple struct value.\n\nAn argument operand is an operand which is used as an argument in a\ncall expression or a method call expression.\n\nA call operand is the function being invoked or the\ntuple enum variant value or the tuple struct value being constructed\nby a call expression.\n\nA tuple struct call expression is a call expression where the\ncall operand resolves to a tuple struct.\n\nA callee type is either a function item type, a\nfunction pointer type, a tuple enum variant, a\ntuple struct type, or a type that implements any of the\ncore::ops::Fn, core::ops::FnMut, or core::ops::FnOnce\n[trait]s.\n\nThe type of a call expression is the return type of the invoked\nfunction, the type of the tuple enum variant or the\ntuple struct being constructed, or associated type\ncore::ops::FnOnce::Output.\n\nA call expression whose callee type is either an\nexternal function item type, an unsafe function item type, or an\nunsafe function pointer type shall require unsafe context.\n\nThe value of a call expression is determined as follows:\n\n* If the callee type is a function item type or a\n function pointer type, then the value is the result of invoking the\n corresponding function with the [argument operand]s.\n\n* If the callee type is a tuple enum variant or a\n tuple struct type, then the value is the result of constructing\n the tuple enum variant or the tuple struct with the\n [argument operand]s.\n\n* If the callee type implements the core::ops::Fn trait, then\n the value is the result of invoking\n core::ops::Fn::call(adjusted_call_operand, argument_operand_tuple),\n where adjusted_call_operand is the adjusted call operand, and\n argument_operand_tuple is a tuple that wraps the\n [argument operand]s.\n\n* If the call operand implements the core::ops::FnMut trait,\n then the value is the result of invoking\n core::ops::FnMut::call_mut(adjusted_call_operand, argument_operand_tuple),\n where adjusted_call_operand is the adjusted call operand, and\n argument_operand_tuple is a tuple that wraps the\n [argument operand]s.\n\n* If the call operand implements the core::ops::FnOnce trait,\n then the value is the result of invoking\n core::ops::FnOnce::call_once(adjusted_call_operand, argument_operand_tuple),\n where adjusted_call_operand is the adjusted call operand, and\n argument_operand_tuple is a tuple that wraps the\n [argument operand]s.\n\nA call expression is subject to call resolution.\n\nThe evaluation of a call expression proceeds as follows:\n\n#. The call operand is evaluated.\n\n#. The [argument operand]s are evaluated in left-to-right order.\n\n#. If the adjusted call operand is a function item type or\n function pointer type, then corresponding function is invoked.\n\n#. If the type of the call operand implements the\n core::ops::Fn trait, then\n core::ops::Fn::call(adjusted_call_operand, argument_operand_tuple) is\n invoked.\n\n#. If the type of the call operand implements the\n core::ops::FnMut trait, then\n core::ops::FnMut::call_mut(adjusted_call_operand, argument_operand_tuple)\n is invoked.\n\n#. If the type of the call operand implements the\n core::ops::FnOnce trait, then\n core::ops::FnOnce::call_once(adjusted_call_operand, argument_operand_tuple)\n is invoked.\n\nIt is undefined behavior to call a function with an ABI other than the\nABI the function was defined with.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_fvgfx17ossd9": "A call expression is an expression that invokes a function or constructs a tuple enum variant value or a tuple struct value.",
            "fls_jvz5z3eqxb39": "An argument operand is an operand which is used as an argument in a call expression or a method call expression.",
            "fls_7ql1c71eidg8": "A call operand is the function being invoked or the tuple enum variant value or the tuple struct value being constructed by a call expression.",
            "fls_QpBu34U6hXn9": "A tuple struct call expression is a call expression where the call operand resolves to a tuple struct.",
            "fls_4t6imtiw6kzt": "A callee type is either a function item type, a function pointer type, a tuple enum variant, a tuple struct type, or a type that implements any of the core::ops::Fn, core::ops::FnMut, or core::ops::FnOnce [trait]s.",
            "fls_bu6i3mcvnbin": "The type of a call expression is the return type of the invoked function, the type of the tuple enum variant or the tuple struct being constructed, or associated type core::ops::FnOnce::Output.",
            "fls_8ljrgdept7s8": "A call expression whose callee type is either an external function item type, an unsafe function item type, or an unsafe function pointer type shall require unsafe context.",
            "fls_7p6zrjbpj0kl": "The value of a call expression is determined as follows:",
            "fls_yrr1s0tucgvh": "If the callee type is a function item type or a function pointer type, then the value is the result of invoking the corresponding function with the [argument operand]s.",
            "fls_RZjFs9koNOk8": "If the callee type is a tuple enum variant or a tuple struct type, then the value is the result of constructing the tuple enum variant or the tuple struct with the [argument operand]s.",
            "fls_s3q3sej1hgho": "If the callee type implements the core::ops::Fn trait, then the value is the result of invoking core::ops::Fn::call(adjusted_call_operand, argument_operand_tuple), where adjusted_call_operand is the adjusted call operand, and argument_operand_tuple is a tuple that wraps the [argument operand]s.",
            "fls_cu2ubdm3tfwb": "If the call operand implements the core::ops::FnMut trait, then the value is the result of invoking core::ops::FnMut::call_mut(adjusted_call_operand, argument_operand_tuple), where adjusted_call_operand is the adjusted call operand, and argument_operand_tuple is a tuple that wraps the [argument operand]s.",
            "fls_9bbewx1l7h5h": "If the call operand implements the core::ops::FnOnce trait, then the value is the result of invoking core::ops::FnOnce::call_once(adjusted_call_operand, argument_operand_tuple), where adjusted_call_operand is the adjusted call operand, and argument_operand_tuple is a tuple that wraps the [argument operand]s.",
            "fls_ZSkcro52q097": "A call expression is subject to call resolution."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_ggr5i91vur0r": "The evaluation of a call expression proceeds as follows: #.",
            "fls_hwalzgdidbfz": "The call operand is evaluated. #.",
            "fls_p52mfvpadu7w": "The [argument operand]s are evaluated in left-to-right order. #.",
            "fls_1cyo5qhbl1j9": "If the adjusted call operand is a function item type or function pointer type, then corresponding function is invoked. #.",
            "fls_nb0eqky2akzt": "If the type of the call operand implements the core::ops::Fn trait, then core::ops::Fn::call(adjusted_call_operand, argument_operand_tuple) is invoked. #.",
            "fls_9lt4wh9ql5ae": "If the type of the call operand implements the core::ops::FnMut trait, then core::ops::FnMut::call_mut(adjusted_call_operand, argument_operand_tuple) is invoked. #.",
            "fls_ixebnlcccmit": "If the type of the call operand implements the core::ops::FnOnce trait, then core::ops::FnOnce::call_once(adjusted_call_operand, argument_operand_tuple) is invoked."
          }
        },
        "-4": {
          "paragraphs": {
            "fls_5yeq4oah58dl": "It is undefined behavior to call a function with an ABI other than the ABI the function was defined with."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "CallExpression ::=\n       CallOperand $$($$ ArgumentOperandList? $$)$$\n\n   CallOperand ::=\n       Operand\n\n   ArgumentOperandList ::=\n       ExpressionList"
          }
        }
      },
      "parent_fls_id": "fls_mjVXiDQRIAzU",
      "sibling_fls_ids": [
        "fls_z7q8kbjwdc7g",
        "fls_8gPCPVc99pXJ"
      ]
    },
    {
      "fls_id": "fls_z7q8kbjwdc7g",
      "title": "Method Call Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Method Call Expressions\n\n ReceiverOperand ::=\n Operand\n\n MethodOperand ::=\n PathExpressionSegment\n\nA method call expression is an expression that invokes a method\nof a variable.\n\nA receiver operand is an operand that denotes the value whose\nmethod is being invoked by a method call expression.\n\nA method operand is an operand that denotes the method being\ninvoked by a method call expression.\n\nThe type of a method call expression is the return type of the\ninvoked method.\n\nThe value of a method call expression is the value returned by\nthe invoked method.\n\nA method call expression is subject to method resolution.\n\nThe evaluation of a method call expression proceeds as follows:\n\n#. The receiver operand is evaluated.\n\n#. The [argument operand]s are evaluated in left-to-right order.\n\n#. The method is invoked.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_b7i26954j1hc": "A method call expression is an expression that invokes a method of a variable.",
            "fls_jx3ryre0xs88": "A receiver operand is an operand that denotes the value whose method is being invoked by a method call expression.",
            "fls_3AQUOBo7akXu": "A method operand is an operand that denotes the method being invoked by a method call expression.",
            "fls_11glzggtbgb3": "The type of a method call expression is the return type of the invoked method.",
            "fls_ljvj1f9fv085": "The value of a method call expression is the value returned by the invoked method.",
            "fls_y7bj7y6davlh": "A method call expression is subject to method resolution."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_oxxk3snd7ya0": "The evaluation of a method call expression proceeds as follows: #.",
            "fls_gmpq15g77o20": "The receiver operand is evaluated. #.",
            "fls_pu0n9hakkym2": "The [argument operand]s are evaluated in left-to-right order. #.",
            "fls_cawdkgvvd1x6": "The method is invoked."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "MethodCallExpression ::=\n       ReceiverOperand $$.$$ MethodOperand $$($$ ArgumentOperandList? $$)$$\n\n   ReceiverOperand ::=\n       Operand\n\n   MethodOperand ::=\n       PathExpressionSegment"
          }
        }
      },
      "parent_fls_id": "fls_mjVXiDQRIAzU",
      "sibling_fls_ids": [
        "fls_xa4nbfas01cj",
        "fls_8gPCPVc99pXJ"
      ]
    },
    {
      "fls_id": "fls_8gPCPVc99pXJ",
      "title": "Call Conformance",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Call Conformance\n\nA method call expression is equivalent to a call expression where the\ncall operand is the resolved method and the adjusted\nreceiver operand is prepended to the [argument operand]s.\n\nAn argument operand matches a function parameter or field of the\ncallee type when its position and the position of the\nfunction parameter or field are the same. Such an\nargument operand is a matched argument operand.\n\nThe type of a matched argument operand and the type of the\ncorresponding function parameter or field shall be unifiable.\n\nThe number of [argument operand]s shall be equal to the number of\n[field]s or [function parameter]s of the callee type.",
      "rubrics": {
        "-1": {
          "paragraphs": {
            "fls_tsn6SUUG9LvW": "A method call expression is equivalent to a call expression where the call operand is the resolved method and the adjusted receiver operand is prepended to the [argument operand]s.",
            "fls_c40C6rg6rGv6": "An argument operand matches a function parameter or field of the callee type when its position and the position of the function parameter or field are the same. Such an argument operand is a matched argument operand.",
            "fls_Gr1ixJ9vFjUm": "The type of a matched argument operand and the type of the corresponding function parameter or field shall be unifiable.",
            "fls_jTMQa6AJSMpE": "The number of [argument operand]s shall be equal to the number of [field]s or [function parameter]s of the callee type."
          }
        }
      },
      "parent_fls_id": "fls_mjVXiDQRIAzU",
      "sibling_fls_ids": [
        "fls_xa4nbfas01cj",
        "fls_z7q8kbjwdc7g"
      ]
    },
    {
      "fls_id": "fls_18k3uajrgq5f",
      "title": "Field Access Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Field Access Expressions\n\n ContainerOperand ::=\n Operand\n\n FieldSelector ::=\n IndexedFieldSelector\n | NamedFieldSelector\n\n IndexedFieldSelector ::=\n DecimalLiteral\n\n NamedFieldSelector ::=\n Identifier\n\nA field access expression is an expression that accesses a field\nof a value.\n\nA container operand is an operand that indicates the value whose\nfield is selected in a field access expression.\n\nA field selector is a construct that selects the field to be\naccessed in a field access expression.\n\nA selected field is a field that is selected by a\nfield access expression.\n\nThe type of a field access expression is the type of the\nselected field.\n\nThe value of a field access expression is the value of the\nselected field.\n\nReading the selected field of a union shall require\nunsafe context.\n\nWriting to the selected field of a union where the type of the\nselected field implements the core::marker::Copy trait or the\ncore::mem::ManuallyDrop trait shall not require unsafe context.\n\nWriting to and then reading from the selected field of a union\nsubject to attribute repr is equivalent to invoking function\ncore::mem::transmute<write_type, read_type>(field_bits) where write_type\nis the type used at the time of writing the selected field,\nread_type is the type used at the time of reading the\nselected field, and field_bits is the bit representation of the\nselected field.\n\nA field access expression is subject to field resolution.\n\nIt is undefined behavior reading the selected field of a\nunion type when it contains data that is invalid for the selected\nfield's type.\n\nThe evaluation of a field access expression evaluates its\ncontainer operand.\n\nSee fls_vsxsbqps64o for the declaration of alice.\n\nThe following indexed field access evaluates to 42.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_hr8qvwlhd9ts": "A field access expression is an expression that accesses a field of a value.",
            "fls_s2vpn4ihenpe": "A container operand is an operand that indicates the value whose field is selected in a field access expression.",
            "fls_yeuayil6uxzx": "A field selector is a construct that selects the field to be accessed in a field access expression.",
            "fls_qqrconpa92i3": "A selected field is a field that is selected by a field access expression.",
            "fls_fovs9il2h9xg": "The type of a field access expression is the type of the selected field.",
            "fls_r1b4n12i93pg": "The value of a field access expression is the value of the selected field.",
            "fls_kddnnz8uc15b": "Reading the selected field of a union shall require unsafe context.",
            "fls_an3no949lvfw": "Writing to the selected field of a union where the type of the selected field implements the core::marker::Copy trait or the core::mem::ManuallyDrop trait shall not require unsafe context.",
            "fls_t6xmsm2nk1bc": "Writing to and then reading from the selected field of a union subject to attribute repr is equivalent to invoking function core::mem::transmute<write_type, read_type>(field_bits) where write_type is the type used at the time of writing the selected field, read_type is the type used at the time of reading the selected field, and field_bits is the bit representation of the selected field.",
            "fls_jjnyuU9KIaGy": "A field access expression is subject to field resolution."
          }
        },
        "-4": {
          "paragraphs": {
            "fls_Vani4665hiJY": "It is undefined behavior reading the selected field of a union type when it contains data that is invalid for the selected field's type."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_6uzouesw2sod": "The evaluation of a field access expression evaluates its container operand."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_x27yayh4z787": "See for the declaration of alice. .. code-block:: rust alice.name",
            "fls_dimto84ifanr": "The following indexed field access evaluates to 42. .. code-block:: rust (\"hello\", 42i16, true).1"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "FieldAccessExpression ::=\n       ContainerOperand $$.$$ FieldSelector\n\n   ContainerOperand ::=\n       Operand\n\n   FieldSelector ::=\n       IndexedFieldSelector\n     | NamedFieldSelector\n\n   IndexedFieldSelector ::=\n       DecimalLiteral\n\n   NamedFieldSelector ::=\n       Identifier"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_tjyexqrx0fx5",
      "title": "Closure Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Closure Expressions\n\n ClosureBody ::=\n Expression\n\n ClosureBodyWithReturnType ::=\n ReturnTypeWithoutBounds BlockExpression\n\n ReturnTypeWithoutBounds ::=\n $$->$$ TypeSpecificationWithoutBounds\n\n ClosureParameterList ::=\n ClosureParameter ($$,$$ ClosureParameter)* $$,$$?\n\n ClosureParameter ::=\n OuterAttributeOrDoc* PatternWithoutAlternation TypeAscription?\n\nA closure expression is an expression that defines a\nclosure type and constructs a value of that type.\n\nAn async closure expression is a closure expression subject to keyword async that defines an async closure type and constructs a value of that type.\n\nThe return type of a closure type is determined as follows:\n\n* If the closure expression specifies a ClosureBodyWithReturnType, then the return type is the specified ReturnTypeWithoutBounds.\n\n* Otherwise the return type is the type of the closure body.\n\nThe return type of an async closure type is an anonymous return type with a core::future::Future trait bound and a binding argument for the Output associated type alias with the actual return type of the corresponding closure type.\n\nA closure body is a construct that represents the executable portion\nof a closure expression.\n\nA closure body denotes a new control flow boundary.\n\nA closure body is subject to capturing.\n\nA closure parameter is a construct that yields a set of\n[binding]s that bind matched input [value]s to [name]s at the\nsite of a call expression or a method call expression.\n\nThe type of a closure parameter is determined as follows:\n\n* If the closure parameter lacks a TypeSpecification, the type is inferred form the usage of the closure parameter.\n\n* Otherwise the type is the specified type.\n\nThe pattern of a closure parameter shall be an\nirrefutable pattern.\n\nThe expected type of the pattern of a closure parameter is the type of the closure parameter.\n\nThe [binding]s of all [pattern]s of all [closure parameter]s of a closure expression shall not shadow another.\n\nThe type of a closure expression is the unique anonymous\nclosure type defined by it.\n\nThe value of a closure expression is the value of the unique\nanonymous closure type instantiated with the selected\n[capture target]s.\n\nThe evaluation of a closure expression proceeds as follows:\n\n#. An anonymous value of an unique anonymous closure type is created.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_2d141c9a0yui": "A closure expression is an expression that defines a closure type and constructs a value of that type.",
            "fls_My6pMgpeFCFg": "An async closure expression is a closure expression subject to keyword async that defines an async closure type and constructs a value of that type.",
            "fls_UgJgur0z6d4a": "The return type of a closure type is determined as follows:",
            "fls_af1WL2mBKMfW": "If the closure expression specifies a ClosureBodyWithReturnType, then the return type is the specified ReturnTypeWithoutBounds.",
            "fls_wLVeE6cNG8oa": "Otherwise the return type is the type of the closure body.",
            "fls_DSy7bPKGzyov": "The return type of an async closure type is an anonymous return type with a core::future::Future trait bound and a binding argument for the Output associated type alias with the actual return type of the corresponding closure type.",
            "fls_srbl7ptknjyk": "A closure body is a construct that represents the executable portion of a closure expression.",
            "fls_oey0ivaiu1l": "A closure body denotes a new control flow boundary.",
            "fls_fg8lx0yyt6oq": "A closure body is subject to capturing.",
            "fls_c3rzwUxjmBMY": "A closure parameter is a construct that yields a set of [binding]s that bind matched input [value]s to [name]s at the site of a call expression or a method call expression.",
            "fls_81KOEXwps2HS": "The type of a closure parameter is determined as follows:",
            "fls_XWJ9SFggdVeH": "If the closure parameter lacks a TypeSpecification, the type is inferred form the usage of the closure parameter.",
            "fls_mPWkIxTJErqx": "Otherwise the type is the specified type.",
            "fls_r6gWLoNR7JMR": "The pattern of a closure parameter shall be an irrefutable pattern.",
            "fls_zsaTK9snhXs0": "The expected type of the pattern of a closure parameter is the type of the closure parameter.",
            "fls_qPeOL6ZhXsgH": "The [binding]s of all [pattern]s of all [closure parameter]s of a closure expression shall not shadow another.",
            "fls_yn30xuejcfxo": "The type of a closure expression is the unique anonymous closure type defined by it.",
            "fls_sje6cdvifgv5": "The value of a closure expression is the value of the unique anonymous closure type instantiated with the selected [capture target]s."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_f59fw17gsasn": "The evaluation of a closure expression proceeds as follows: #.",
            "fls_7w15ccc1zzxl": "An anonymous value of an unique anonymous closure type is created."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ClosureExpression ::=\n       $$async$$? $$move$$? $$|$$ ClosureParameterList? $$|$$\n         (ClosureBody | ClosureBodyWithReturnType)\n\n   ClosureBody ::=\n       Expression\n\n   ClosureBodyWithReturnType ::=\n       ReturnTypeWithoutBounds BlockExpression\n\n   ReturnTypeWithoutBounds ::=\n       $$->$$ TypeSpecificationWithoutBounds\n\n   ClosureParameterList ::=\n       ClosureParameter ($$,$$ ClosureParameter)* $$,$$?\n\n   ClosureParameter ::=\n       OuterAttributeOrDoc* PatternWithoutAlternation Type..."
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_rr908hgunja7",
      "title": "Loop Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Loop Expressions\n\n Label ::=\n $$'$$ NonKeywordIdentifier $$:$$\n\n LoopContent ::=\n ForLoopExpression\n | InfiniteLoopExpression\n | WhileLetLoopExpression\n | WhileLoopExpression\n\n LoopBody ::=\n BlockExpression\n\nA loop expression is an expression that evaluates a block\nexpression continuously as long as some criterion holds true.\n\nA loop body is the block expression of a loop expression.\n\nThe type of the loop body shall be the unit type.\n\nAn anonymous loop expression is a loop expression without a\nlabel.\n\nA named loop expression is a loop expression with a label.\n\nA loop expression is terminated when its block expression is no\nlonger evaluated.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_y1d8kd1bdlmx": "A loop expression is an expression that evaluates a block expression continuously as long as some criterion holds true.",
            "fls_BjZjuiFnPtFd": "A loop body is the block expression of a loop expression.",
            "fls_XEc0cIkpkyzJ": "The type of the loop body shall be the unit type.",
            "fls_eg93m93gvwal": "An anonymous loop expression is a loop expression without a label.",
            "fls_phpoq9ho8f1v": "A named loop expression is a loop expression with a label."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_aw6qczl4zpko": "A loop expression is terminated when its block expression is no longer evaluated."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "LoopExpression ::=\n       Label? LoopContent\n\n   Label ::=\n       $$'$$ NonKeywordIdentifier $$:$$\n\n   LoopContent ::=\n       ForLoopExpression\n     | InfiniteLoopExpression\n     | WhileLetLoopExpression\n     | WhileLoopExpression\n\n   LoopBody ::=\n       BlockExpression"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_onfyolkcbeh3",
      "title": "For Loops",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "For Loops\n\nA for loop expression is a loop expression that continues to evaluate\nits loop body as long as its subject expression yields a value.\n\nThe type of a subject expression shall implement the\ncore::iter::IntoIterator trait.\n\nThe expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.\n\nThe type of a for loop expression is the unit type.\n\nThe value of a for loop expression is the unit value.\n\nThe evaluation of a for loop expression of the form\n\nis equivalent to the evaluation of the following block expression:",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_1bh2alh37frz": "A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.",
            "fls_fkgbin6ydkm4": "The type of a subject expression shall implement the core::iter::IntoIterator trait.",
            "fls_fo6Aa6Td6rMA": "The expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.",
            "fls_bmTjhKdpfgCB": "The type of a for loop expression is the unit type.",
            "fls_FkxLf91WKiIo": "The value of a for loop expression is the unit value."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_kuxo0on3vit6": "The evaluation of a for loop expression of the form .. code-block:: rust 'label: for pattern in subject_expression { /* loop body */ }",
            "fls_2lrzrtjhsdes": "is equivalent to the evaluation of the following block expression: .. code-block:: rust { let result = match core::iter::IntoIterator::into_iter (subject_expression) { mut iter => 'label: loop { let mut next_value; match core::iter::Iterator::next(&mut iter) { Option::Some(value) => next_value = value, Option::None => break }; let pattern = next_value; let () = { /* loop body */ }; } }; result }"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ForLoopExpression ::=\n       $$for$$ Pattern $$in$$ SubjectExpression LoopBody"
          }
        }
      },
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_sf4qnd43z2wc",
      "title": "Infinite Loops",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Infinite Loops\n\nAn infinite loop expression is a loop expression that continues to\nevaluate its loop body indefinitely.\n\nThe type of an infinite loop expression is determined as follows:\n\n* If the infinite loop expression does not contain a break expression,\n then the type is the never type.\n\n* If the infinite loop expression contains at least one\n break expression, then the type is the unified type of the\n [break type]s of all [break expression]s.\n\nThe value of an infinite loop expression is determined as follows:\n\n* If the infinite loop expression does not contain a break expression,\n then the value is the unit value.\n\n* If the infinite loop expression contains at least one\n break expression, then the value is the break value of the\n break expression that broke out of the loop expression.\n\nThe evaluation of an infinite loop expression proceeds as follows:\n\n#. The block expression is evaluated.\n\n#. Control restarts the evaluation of the infinite loop expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_p11qw6mtxlda": "An infinite loop expression is a loop expression that continues to evaluate its loop body indefinitely.",
            "fls_b314wjbv0zwe": "The type of an infinite loop expression is determined as follows:",
            "fls_rpedapxnv8w3": "If the infinite loop expression does not contain a break expression, then the type is the never type.",
            "fls_wf11yp1jwf53": "If the infinite loop expression contains at least one break expression, then the type is the unified type of the [break type]s of all [break expression]s.",
            "fls_q3qpcf2fz7h": "The value of an infinite loop expression is determined as follows:",
            "fls_2ulbzmuuny3g": "If the infinite loop expression does not contain a break expression, then the value is the unit value.",
            "fls_99imks9hj3kp": "If the infinite loop expression contains at least one break expression, then the value is the break value of the break expression that broke out of the loop expression."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_w4tj5gofwih1": "The evaluation of an infinite loop expression proceeds as follows: #.",
            "fls_pg3r6nyl865": "The block expression is evaluated. #.",
            "fls_lp15ilkul2uv": "Control restarts the evaluation of the infinite loop expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "InfiniteLoopExpression ::=\n       $$loop$$ LoopBody"
          }
        }
      },
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_5jjm1kt43axd",
      "title": "While Loops",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "While Loops\n\n IterationExpression ::=\n SubjectExpression\n\nA while loop expression is a loop expression that continues to\nevaluate its loop body as long as its iteration expression holds\ntrue.\n\nAn iteration expression is an expression that provides the criterion\nof a while loop expression.\n\nThe type of an iteration expression shall be type bool.\n\nThe type of a while loop expression is the unit type.\n\nThe value of a while loop expression is the unit value.\n\nThe evaluation of a while loop expression proceeds as follows:\n\n#. The iteration expression is evaluated.\n\n#. If the iteration expression evaluated to true, then:\n\n #. The block expression is evaluated.\n\n #. Control restarts the evaluation of the while loop expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_ajby242tnu7c": "A while loop expression is a loop expression that continues to evaluate its loop body as long as its iteration expression holds true.",
            "fls_13hmhzqz82v6": "An iteration expression is an expression that provides the criterion of a while loop expression.",
            "fls_d7ofrq3777kq": "The type of an iteration expression shall be type bool.",
            "fls_P8iyTN6KZCVA": "The type of a while loop expression is the unit type.",
            "fls_s6hRa5spz64w": "The value of a while loop expression is the unit value."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_1i7hm645h7ox": "The evaluation of a while loop expression proceeds as follows: #.",
            "fls_5x0du3u1jwd3": "The iteration expression is evaluated. #.",
            "fls_23uluvhhoct6": "If the iteration expression evaluated to true, then: #.",
            "fls_k7g4cac93617": "The block expression is evaluated. #.",
            "fls_j08k3brdpgno": "Control restarts the evaluation of the while loop expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "WhileLoopExpression ::=\n       $$while$$ IterationExpression LoopBody\n\n   IterationExpression ::=\n       SubjectExpression"
          }
        }
      },
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_m6kd5i9dy8dx",
      "title": "While Let Loops",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "While Let Loops\n\nA while let loop expression is a loop expression that continues to\nevaluate its loop body as long as its subject let expression yields\na value that can be matched against its pattern.\n\nThe expected type of the pattern is the type of the subject let expression.\n\nThe type of a while let loop expression is the unit type.\n\nThe value of a while let loop expression is the unit value.\n\nThe evaluation of a while let loop expression of the form\n\nshall be equivalent to the evaluation the following infinite loop:",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_fmdlyp9r9zl7": "A while let loop expression is a loop expression that continues to evaluate its loop body as long as its subject let expression yields a value that can be matched against its pattern.",
            "fls_bC60ZSC9yUOI": "The expected type of the pattern is the type of the subject let expression.",
            "fls_gTfSLePwHTES": "The type of a while let loop expression is the unit type.",
            "fls_pTq4LIGIoAtN": "The value of a while let loop expression is the unit value."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_z2ht5iaat5ag": "The evaluation of a while let loop expression of the form .. code-block:: rust 'label: let pattern = subject_let_expression { /* loop body */ }",
            "fls_pacf1uavh1qt": "shall be equivalent to the evaluation the following infinite loop: .. code-block:: rust 'label: loop { match subject_let_expression { pattern => { /* loop body */ }, _ => break } }"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "WhileLetLoopExpression ::=\n       $$while$$ $$let$$ Pattern $$=$$ SubjectLetExpression LoopBody"
          }
        }
      },
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_uusi0zej55is",
      "title": "Loop Labels",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Loop Labels\n\nA label indication is a construct that indicates a label.\n\nA label indication shall indicate a label of an enclosing\nnamed block expression or named loop expression that does not pass a\ncontrol flow boundary in order to reach the enclosing\nnamed block expression or named loop expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_tx5u743391h7": "A label indication is a construct that indicates a label.",
            "fls_7hc8yboeaho0": "A label indication shall indicate a label of an enclosing named block expression or named loop expression that does not pass a control flow boundary in order to reach the enclosing named block expression or named loop expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "LabelIndication ::=\n       $$'$$ NonKeywordIdentifier"
          }
        }
      },
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_jr4tpuyksr75",
      "title": "Break Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Break Expressions\n\nA break expression is an expression that terminates a\nloop expression or a named block expression.\n\nA break expression shall appear within a loop body or a\nnamed block expression.\n\nIf a break expression appears within a named block expression, then\nthe break expression shall have a label indication.\n\nThe label indication of a break expression shall resolve to the\nlabel of an enclosing named block expression or\nnamed loop expression.\n\nA break expression with a label indication is associated with the\nnamed block expression or named loop expression whose label is\nindicated by the label indication.\n\nA break expression without a label indication is associated with the\ninnermost enclosing loop expression.\n\nIf a break expression appears within a loop expression, then the\nbreak expression shall have an operand only when it is associated\nwith an infinite loop.\n\nThe type of a break expression is the never type.\n\nBreak type is the type of the operand of a break expression.\n\nThe break type is determined as follows:\n\n* If the break expression lacks an operand, then the break type\n is the unit type.\n\n* If the break expression has an operand, then the break type is\n the type of its operand.\n\nBreak value is the value of the operand of a\nbreak expression.\n\nThe break value is determined as follows:\n\n* If the break expression lacks an operand, then the break value\n is the unit value.\n\n* If the break expression has an operand, then the break value is\n the value of its operand.\n\nIf a break expression appears within a loop expression, then the\nevaluation of the break expression proceeds as follows:\n\n#. The operand is evaluated.\n\n#. All enclosing [loop expression]s upto and including the associated\n loop expression are terminated.\n\nIf a break expression appears within a named block expression, then\nthe evaluation of the break expression proceeds as follows:\n\n#. The operand is evaluated.\n\n#. All enclosing [named block expression]s upto and including the\n associated named block expression are terminated.\n\nThe following break expression terminates both the inner and the outer loop.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_i5ko1t2wbgxe": "A break expression is an expression that terminates a loop expression or a named block expression.",
            "fls_jiykbp51909f": "A break expression shall appear within a loop body or a named block expression.",
            "fls_gnupTkuafKNi": "If a break expression appears within a named block expression, then the break expression shall have a label indication.",
            "fls_7frvr2nm2mcj": "The label indication of a break expression shall resolve to the label of an enclosing named block expression or named loop expression.",
            "fls_54d5uydc87td": "A break expression with a label indication is associated with the named block expression or named loop expression whose label is indicated by the label indication.",
            "fls_ghxns2nggffj": "A break expression without a label indication is associated with the innermost enclosing loop expression.",
            "fls_3hI7FU42sVyX": "If a break expression appears within a loop expression, then the break expression shall have an operand only when it is associated with an infinite loop.",
            "fls_dnnq1zym8ii0": "The type of a break expression is the never type.",
            "fls_1wdybpfldj7q": "Break type is the type of the operand of a break expression.",
            "fls_8yore99adr22": "The break type is determined as follows:",
            "fls_60imbzwg3e2x": "If the break expression lacks an operand, then the break type is the unit type.",
            "fls_l0c05wa9q97w": "If the break expression has an operand, then the break type is the type of its operand.",
            "fls_bgd7d5q69q0g": "Break value is the value of the operand of a break expression.",
            "fls_yb8jv4mkmki0": "The break value is determined as follows:",
            "fls_d7l1y2qbe8br": "If the break expression lacks an operand, then the break value is the unit value.",
            "fls_56szfyilc06": "If the break expression has an operand, then the break value is the value of its operand."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_jnpx8mx1oa7n": "If a break expression appears within a loop expression, then the evaluation of the break expression proceeds as follows: #.",
            "fls_l2kp8mw6bjj0": "The operand is evaluated. #.",
            "fls_2nmadhe3ismj": "All enclosing [loop expression]s upto and including the associated loop expression are terminated.",
            "fls_XpFLrL78QMe1": "If a break expression appears within a named block expression, then the evaluation of the break expression proceeds as follows: #.",
            "fls_WFAW1PG1YXdM": "The operand is evaluated. #.",
            "fls_AurifMM8RpDp": "All enclosing [named block expression]s upto and including the associated named block expression are terminated."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_32fwis9pxh77": "The following break expression terminates both the inner and the outer loop. .. code-block:: rust 'outer: loop { 'inner: loop { break 'outer; } }"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "BreakExpression ::=\n       $$break$$ LabelIndication? Operand?"
          }
        }
      },
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_sjwrlwvpulp",
      "title": "Continue Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "Continue Expressions\n\nA continue expression shall appear within a loop expression.\n\nA continue expression without a label indication is associated with\nthe innermost enclosing loop expression.\n\nA continue expression with a label indication is associated with a\nnamed loop expression whose label is indicated by the\nlabel indication.\n\nThe type of a continue expression is the never type.\n\nThe evaluation of a continue expression proceeds as follows:\n\n#. If the continue expression appears with a label indication, then\n all enclosing [loop expression]s upto and including the associated\n loop expression are terminated.\n\n#. The evaluation of the associated loop expression is restarted.\n\nThe following continue expression terminates and restarts game_loop.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_wzs6kz9ffqzt": "A continue expression shall appear within a loop expression.",
            "fls_r5ke7b9n7k3s": "A continue expression without a label indication is associated with the innermost enclosing loop expression.",
            "fls_ckm6i9c3s6j8": "A continue expression with a label indication is associated with a named loop expression whose label is indicated by the label indication.",
            "fls_d0bmw8xiw5nk": "The type of a continue expression is the never type."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_vmyuuptfnwek": "The evaluation of a continue expression proceeds as follows: #.",
            "fls_gm74eo754rq9": "If the continue expression appears with a label indication, then all enclosing [loop expression]s upto and including the associated loop expression are terminated. #.",
            "fls_gvuesa5ekeif": "The evaluation of the associated loop expression is restarted."
          }
        },
        "-7": {
          "paragraphs": {
            "fls_767gv7zhqamh": "The following continue expression terminates and restarts game_loop. .. code-block:: rust 'game_loop: loop { if is_paused() { continue; } . . . }"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ContinueExpression ::=\n       $$continue$$ LabelIndication?"
          }
        }
      },
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75"
      ]
    },
    {
      "fls_id": "fls_18swodqqzadj",
      "title": "Range Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Range Expressions\n\n RangeFromExpression ::=\n RangeExpressionLowBound $$..$$\n\n RangeFromToExpression ::=\n RangeExpressionLowBound $$..$$ RangeExpressionHighBound\n\n RangeFullExpression ::=\n $$..$$\n\n RangeInclusiveExpression ::=\n RangeExpressionLowBound $$..=$$ RangeExpressionHighBound\n\n RangeToExpression ::=\n $$..$$ RangeExpressionHighBound\n\n RangeToInclusiveExpression ::=\n $$..=$$ RangeExpressionHighBound\n\n RangeExpressionLowBound ::=\n Operand\n\n RangeExpressionHighBound ::=\n Operand\n\nA range expression is an expression that constructs a range.\n\nA range expression low bound is an operand that specifies the start of\na range.\n\nA range expression high bound is an operand that specifies the end of\na range.\n\nIf a range expression has two [operand]s, then the [type]s of the\n[operand]s shall be unifiable.\n\nA range-from expression is a range expression that specifies an\nincluded range expression low bound.\n\nThe type of a range-from expression is core::ops::RangeFrom.\n\nThe value of a range-from expression is\ncore::ops::RangeFrom { start: range_expression_low_bound }.\n\nA range-from-to expression is a range expression that specifies an\nincluded range expression low bound and an excluded\nrange expression high bound.\n\nThe type of a range-from-to expression is core::ops::Range.\n\nThe value of a range-from-to expression is\ncore::ops::Range { start: range_expression_low_bound, end: range_expression_high_bound }.\n\nA range-full expression is a range expression that covers the whole\nrange of a type.\n\nThe type of a range-full expression is core::ops::RangeFull.\n\nThe value of a range-full expression is core::ops::RangeFull {}.\n\nA range-inclusive expression is a range expression that specifies an\nincluded range expression low bound and an included\nrange expression high bound.\n\nThe type of a range-inclusive expression is\ncore::ops::RangeInclusive.\n\nThe value of a range-inclusive expression is\ncore::ops::RangeInclusive::new(range_expression_low_bound, range_expression_high_bound).\n\nA range-to expression is a range expression that specifies an excluded\nrange expression high bound.\n\nThe type of a range-to expression is core::ops::RangeTo.\n\nThe value of a range-to expression is\ncore::ops::RangeTo { end: range_expression_high_bound }.\n\nA range-to-inclusive expression is a range expression that specifies\nan included range expression high bound.\n\nThe type of a range-to-inclusive expression is\ncore::ops::RangeToInclusive.\n\nThe value of a range-to-inclusive expression is\ncore::ops::RangeToInclusive { end: range_expression_high_bound }.\n\nThe evaluation of a range expression evaluates its [operand]s in\nleft-to-right order.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_bi82rusji8g0": "A range expression is an expression that constructs a range.",
            "fls_msyv4oyk5zp9": "A range expression low bound is an operand that specifies the start of a range.",
            "fls_f648uuxxh4vk": "A range expression high bound is an operand that specifies the end of a range.",
            "fls_9pl4629t54yq": "If a range expression has two [operand]s, then the [type]s of the [operand]s shall be unifiable.",
            "fls_xaumwogwbv3g": "A range-from expression is a range expression that specifies an included range expression low bound.",
            "fls_exa2ufugnpgc": "The type of a range-from expression is core::ops::RangeFrom.",
            "fls_jqy0p155btca": "The value of a range-from expression is core::ops::RangeFrom { start: range_expression_low_bound }.",
            "fls_ppustuqdji7b": "A range-from-to expression is a range expression that specifies an included range expression low bound and an excluded range expression high bound.",
            "fls_ke2fpgodq84u": "The type of a range-from-to expression is core::ops::Range.",
            "fls_zb6jk6qykun6": "The value of a range-from-to expression is core::ops::Range { start: range_expression_low_bound, end: range_expression_high_bound }.",
            "fls_x67xo25n0qlz": "A range-full expression is a range expression that covers the whole range of a type.",
            "fls_m6n0gvg3ct1b": "The type of a range-full expression is core::ops::RangeFull.",
            "fls_yvh5cdgzevni": "The value of a range-full expression is core::ops::RangeFull {}.",
            "fls_lh9my7g8oflq": "A range-inclusive expression is a range expression that specifies an included range expression low bound and an included range expression high bound.",
            "fls_livflk52xaj9": "The type of a range-inclusive expression is core::ops::RangeInclusive.",
            "fls_vj213j9bj61y": "The value of a range-inclusive expression is core::ops::RangeInclusive::new(range_expression_low_bound, range_expression_high_bound).",
            "fls_5a1uivj19kob": "A range-to expression is a range expression that specifies an excluded range expression high bound.",
            "fls_k611yoc8hk0n": "The type of a range-to expression is core::ops::RangeTo.",
            "fls_m0slikrulnvd": "The value of a range-to expression is core::ops::RangeTo { end: range_expression_high_bound }.",
            "fls_1gc436ee1nzm": "A range-to-inclusive expression is a range expression that specifies an included range expression high bound.",
            "fls_8sfjw83irpre": "The type of a range-to-inclusive expression is core::ops::RangeToInclusive.",
            "fls_5xw4opkbxhsc": "The value of a range-to-inclusive expression is core::ops::RangeToInclusive { end: range_expression_high_bound }."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_ehseim1p479z": "The evaluation of a range expression evaluates its [operand]s in left-to-right order."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "RangeExpression ::=\n       RangeFromExpression\n     | RangeFromToExpression\n     | RangeFullExpression\n     | RangeInclusiveExpression\n     | RangeToExpression\n     | RangeToInclusiveExpression\n\n   RangeFromExpression ::=\n       RangeExpressionLowBound $$..$$\n\n   RangeFromToExpression ::=\n       RangeExpressionLowBound $$..$$ RangeExpressionHighBound\n\n   RangeFullExpression ::=\n       $$..$$\n\n   RangeInclusiveExpression ::=\n       RangeExpressionLowBound $$..=$$ RangeExpressionHighBound\n\n   Rang..."
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_nlzksiu8y3z9",
      "title": "If and If Let Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "If and If Let Expressions",
      "rubrics": {},
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_mkut7gut49gi",
      "title": "If Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "If Expressions\n\n ElseExpression ::=\n $$else$$ (BlockExpression | IfExpression | IfLetExpression)\n\nAn if expression is an expression that evaluates either a\nblock expression or an else expression depending on the value of\nits subject expression.\n\nAn else expression is an expression that represents either a\nblock expression, an if expression, or an if let expression.\n\nThe type of the subject expression of an if expression shall be\ntype bool.\n\nThe type of an if expression is the type of its\nblock expression.\n\nThe value of an if expression is the value of its\nblock expression.\n\nThe type of an else expression is the type of its\nblock expression, if expression, or if let expression.\n\nThe value of an else expression is the value of its\nblock expression, if expression, or if let expression.\n\nThe type of an if expression and the type of an\nelse expression shall be unifiable.\n\nThe evaluation of an if expression proceeds as follows:\n\n#. The subject expression is evaluated.\n\n#. If the subject expression evaluated to true, then the\n block expression is evaluated.\n\n#. If the subject expression evaluated to false and the\n if expression has an else expression, then the else expression\n is evaluated.\n\nThe evaluation of an else expression evaluates its\nblock expression, if expression, or if let expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_2i4fbxbbvpf1": "An if expression is an expression that evaluates either a block expression or an else expression depending on the value of its subject expression.",
            "fls_5azwlk7hav1k": "An else expression is an expression that represents either a block expression, an if expression, or an if let expression.",
            "fls_r7gzxo16esri": "The type of the subject expression of an if expression shall be type bool.",
            "fls_iv9t4nfs4f6w": "The type of an if expression is the type of its block expression.",
            "fls_i9sxf2q5jjqt": "The value of an if expression is the value of its block expression.",
            "fls_1e8qer6bh2f3": "The type of an else expression is the type of its block expression, if expression, or if let expression.",
            "fls_p5pjxk5xfcbx": "The value of an else expression is the value of its block expression, if expression, or if let expression.",
            "fls_mpq7gicosgkt": "The type of an if expression and the type of an else expression shall be unifiable."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_yhlyzef9h97q": "The evaluation of an if expression proceeds as follows: #.",
            "fls_w7lq4dkoyuf7": "The subject expression is evaluated. #.",
            "fls_5udx9zyeg5ga": "If the subject expression evaluated to true, then the block expression is evaluated. #.",
            "fls_67l4j48n6p7o": "If the subject expression evaluated to false and the if expression has an else expression, then the else expression is evaluated.",
            "fls_e8gd5lzcaifw": "The evaluation of an else expression evaluates its block expression, if expression, or if let expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "IfExpression ::=\n       $$if$$ SubjectExpression BlockExpression ElseExpression?\n\n   ElseExpression ::=\n       $$else$$ (BlockExpression | IfExpression | IfLetExpression)"
          }
        }
      },
      "parent_fls_id": "fls_nlzksiu8y3z9",
      "sibling_fls_ids": [
        "fls_p0t1ch115tra"
      ]
    },
    {
      "fls_id": "fls_p0t1ch115tra",
      "title": "If Let Expressions",
      "category": 0,
      "level": 3,
      "file": "expressions",
      "content": "If Let Expressions\n\nAn if let expression is an expression that evaluates either a\nblock expression or an else expression depending on whether its\npattern can be matched against its subject let expression.\n\nThe expected type of the pattern is the type of the subject let expression.\n\nThe type of an if let expression is the type of its\nblock expression.\n\nThe value of an if let expression is the value of its\nblock expression.\n\nThe type of an if let expression and the type of an\nelse expression shall be unifiable.\n\nThe evaluation of an if let expression of the form\n\nis equivalent to the evaluation of the following match expression:\n\nThe evaluation of an if let expression of the form\n\nis equivalent to the evaluation of the following match expression:",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_dsrjup2umr9": "An if let expression is an expression that evaluates either a block expression or an else expression depending on whether its pattern can be matched against its subject let expression.",
            "fls_okVOYzTT6fBK": "The expected type of the pattern is the type of the subject let expression.",
            "fls_4vyrufo4qdeg": "The type of an if let expression is the type of its block expression.",
            "fls_qfnwwvzxsl3": "The value of an if let expression is the value of its block expression.",
            "fls_lEr4iqwdBcbA": "The type of an if let expression and the type of an else expression shall be unifiable."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_ijo73wtz1sy": "The evaluation of an if let expression of the form .. code-block:: rust if let pattern = subject_let_expression { /* body */ }",
            "fls_qeho5iqiy59": "is equivalent to the evaluation of the following match expression: .. code-block:: rust match subject_let_expression { pattern => { /* body */ }, _ => () }",
            "fls_nhngr8y850dt": "The evaluation of an if let expression of the form .. code-block:: rust if let pattern = subject_let_expression { /* body */ } else { /* else */ }",
            "fls_8fg2ufaxjkv5": "is equivalent to the evaluation of the following match expression: .. code-block:: rust match subject_let_expression { pattern => { /* body */ }, _ => { /* else */ } }"
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "IfLetExpression ::=\n       $$if$$ $$let$$ Pattern $$=$$ SubjectLetExpression BlockExpression\n         ElseExpression?"
          }
        }
      },
      "parent_fls_id": "fls_nlzksiu8y3z9",
      "sibling_fls_ids": [
        "fls_mkut7gut49gi"
      ]
    },
    {
      "fls_id": "fls_e5td0fa92fay",
      "title": "Match Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Match Expressions\n\n MatchArmList ::=\n IntermediateMatchArm* FinalMatchArm\n\n IntermediateMatchArm ::=\n MatchArmMatcher $$=>$$\n $$($$ ExpressionWithBlock $$,$$? | ExpressionWithoutBlock $$,$$ $$)$$\n\n FinalMatchArm ::=\n MatchArmMatcher $$=>$$ Operand $$,$$?\n\n MatchArmMatcher ::=\n OuterAttributeOrDoc* Pattern MatchArmGuard?\n\n MatchArmGuard ::=\n $$if$$ Operand\n\nA match expression is an expression that tries to match one of its\nmultiple [pattern]s against its subject expression and if it succeeds,\nevaluates an operand.\n\nA match arm is a construct that consists of a match arm matcher\nand a match arm body.\n\nAn intermediate match arm is any non-[final match arm] of a\nmatch expression.\n\nA final match arm is the last match arm of a match expression.\n\nA match arm matcher is a construct that consists of a pattern and\na match arm guard.\n\nThe expected type of the pattern of the match arm matcher is the type of the subject expression.\n\nA match arm body is the operand of a match arm.\n\nA match arm guard is a construct that provides additional filtering to\na match arm matcher.\n\n[Binding]s introduced in the pattern of a match arm matcher are\nimmutable in the match arm guard.\n\nThe type of the subject expression and the [type]s of all\n[pattern]s of all [match arm matcher]s shall be unifiable.\n\nThe type of the operand of a match arm guard shall be type\nbool.\n\nThe [type]s of all match arm bodies <match arm body> shall be\nunifiable.\n\nThe type of a match expression is the unified type of the\n[type]s of the [operand]s of all [match arm]s.\n\nA match arm is selected when its pattern matches the\nvalue of the subject expression and its match arm guard (if any) evaluates to\ntrue.\n\nMatch arm selection happens in declarative order.\n\nThe [pattern]s of all [match arm]s taken together shall exhaustively\nmatch the [subject expression]'s type.\n\nThe value of a match expression is the value of the operand\nof the selected match arm.\n\nThe evaluation of a match expression proceeds as follows:\n\n#. The subject expression is evaluated.\n\n#. Each match arm is evaluated in declarative order as follows:\n\n #. The match arm matcher of the match arm is evaluated.\n\n #. If the match arm matcher succeeds, then\n\n #. The operand of the match arm is evaluated.\n\n #. Control stops the evaluation of the match expression.\n\n #. Otherwise control proceeds with the evaluation of the next\n match arm.\n\nThe evaluation of a match arm matcher proceeds as follows:\n\n#. The pattern of the match arm matcher is evaluated.\n\n#. If the pattern succeeds, then\n\n #. If the match arm matcher has a match arm guard, then\n\n #. The match arm guard is evaluated.\n\n #. If the match arm guard evaluates to true, then the\n match arm matcher succeeds.\n\n #. Otherwise the match arm matcher fails.\n\n#. Otherwise the match arm matcher fails.\n\nThe evaluation of a match arm guard evaluates its operand. A\nmatch arm guard evaluates to true when its operand evaluates to\ntrue, otherwise it evaluates to false.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_ei4pbeksd1v8": "A match expression is an expression that tries to match one of its multiple [pattern]s against its subject expression and if it succeeds, evaluates an operand.",
            "fls_l45i24ikfavm": "A match arm is a construct that consists of a match arm matcher and a match arm body.",
            "fls_d9gerg12hm2d": "An intermediate match arm is any non-[final match arm] of a match expression.",
            "fls_oj8dg28xw5yp": "A final match arm is the last match arm of a match expression.",
            "fls_lrdrtedyz28i": "A match arm matcher is a construct that consists of a pattern and a match arm guard.",
            "fls_zJQ4LecT1HYd": "The expected type of the pattern of the match arm matcher is the type of the subject expression.",
            "fls_8wjdichfxp0y": "A match arm body is the operand of a match arm.",
            "fls_hs1rr54hu18w": "A match arm guard is a construct that provides additional filtering to a match arm matcher.",
            "fls_RPMOAaZ6lflI": "[Binding]s introduced in the pattern of a match arm matcher are immutable in the match arm guard.",
            "fls_knv1affr2o8t": "The type of the subject expression and the [type]s of all [pattern]s of all [match arm matcher]s shall be unifiable.",
            "fls_bzhz5wjd90ii": "The type of the operand of a match arm guard shall be type bool.",
            "fls_17ag0wzdbxv6": "The [type]s of all match arm bodies <match arm body> shall be unifiable.",
            "fls_5w964phrru82": "The type of a match expression is the unified type of the [type]s of the [operand]s of all [match arm]s.",
            "fls_g6xyz0beps3o": "A match arm is selected when its pattern matches the value of the subject expression and its match arm guard (if any) evaluates to true.",
            "fls_8dba4o5qg8js": "Match arm selection happens in declarative order.",
            "fls_e02um1gb89d0": "The [pattern]s of all [match arm]s taken together shall exhaustively match the [subject expression]'s type.",
            "fls_4sh2yrslszvb": "The value of a match expression is the value of the operand of the selected match arm."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_g551l8r8yh6d": "The evaluation of a match expression proceeds as follows: #.",
            "fls_y44jzkbv74bv": "The subject expression is evaluated. #.",
            "fls_jwxykea99psw": "Each match arm is evaluated in declarative order as follows: #.",
            "fls_pgulnjeoxwtj": "The match arm matcher of the match arm is evaluated. #.",
            "fls_2dg7wl68z7ar": "If the match arm matcher succeeds, then #.",
            "fls_yv11febo0kyb": "The operand of the match arm is evaluated. #.",
            "fls_mvi9z1x836qu": "Control stops the evaluation of the match expression. #.",
            "fls_81nnizrxgrsm": "Otherwise control proceeds with the evaluation of the next match arm.",
            "fls_4dv7x9nh2h4e": "The evaluation of a match arm matcher proceeds as follows: #.",
            "fls_k7kliy101m0f": "The pattern of the match arm matcher is evaluated. #.",
            "fls_k68zkb6jv0vz": "If the pattern succeeds, then #.",
            "fls_gbb6wbmher5z": "If the match arm matcher has a match arm guard, then #.",
            "fls_jl4av757yx8j": "The match arm guard is evaluated. #.",
            "fls_wkh5wztauwhu": "If the match arm guard evaluates to true, then the match arm matcher succeeds. #.",
            "fls_f5f0x8jstp1g": "Otherwise the match arm matcher fails. #.",
            "fls_yk8l9zjh7i0d": "Otherwise the match arm matcher fails.",
            "fls_sbtx1l6n2tp2": "The evaluation of a match arm guard evaluates its operand. A match arm guard evaluates to true when its operand evaluates to true, otherwise it evaluates to false."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "MatchExpression ::=\n       $$match$$ SubjectExpression $${$$\n         InnerAttributeOrDoc*\n         MatchArmList?\n       $$}$$\n\n   MatchArmList ::=\n       IntermediateMatchArm* FinalMatchArm\n\n   IntermediateMatchArm ::=\n       MatchArmMatcher $$=>$$\n         $$($$ ExpressionWithBlock $$,$$? | ExpressionWithoutBlock $$,$$ $$)$$\n\n   FinalMatchArm ::=\n       MatchArmMatcher $$=>$$ Operand $$,$$?\n\n   MatchArmMatcher ::=\n       OuterAttributeOrDoc* Pattern MatchArmGuard?\n\n   MatchArmGuard ::=\n       ..."
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_8l74abhlxzdl",
      "title": "Return Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Return Expressions\n\nA return expression is an expression that optionally yields a\nvalue and causes control flow to return to the end of the enclosing\ncontrol flow boundary.\n\nA return expression shall appear within a control flow boundary.\n\nThe type of a return expression is the never type.\n\nThe value returned by a return expression is determined as follows:\n\n* If the return expression has an operand, then the value is the\n value of the operand.\n\n* If the return expression does not have an operand, then the\n value is the unit value.\n\nThe evaluation of a return expression proceeds as follows:\n\n#. If the return expression has an operand, then\n\n #. The operand is evaluated.\n\n #. The value of the operand is passed <passing convention>\n by move into the designated output location of the enclosing\n control flow boundary.\n\n#. Control destroys the current activation frame.\n\n#. Control is transferred to the caller frame.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_u7jk4j8gkho": "A return expression is an expression that optionally yields a value and causes control flow to return to the end of the enclosing control flow boundary.",
            "fls_5v3j5ghhw8j8": "A return expression shall appear within a control flow boundary.",
            "fls_7Ck4LMQMeQCv": "The type of a return expression is the never type.",
            "fls_r610t5vsi7bx": "The value returned by a return expression is determined as follows:",
            "fls_njndlx2rps2k": "If the return expression has an operand, then the value is the value of the operand.",
            "fls_tjksia7prao1": "If the return expression does not have an operand, then the value is the unit value."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_bqmwlona6l5w": "The evaluation of a return expression proceeds as follows: #.",
            "fls_d9avvfi548t7": "If the return expression has an operand, then #.",
            "fls_o3fc1z2mn8zc": "The operand is evaluated. #.",
            "fls_bbf54ukld7j9": "The value of the operand is passed <passing convention> by move into the designated output location of the enclosing control flow boundary. #.",
            "fls_99ea30a5mulj": "Control destroys the current activation frame. #.",
            "fls_ubwj8uj6sbgt": "Control is transferred to the caller frame."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "ReturnExpression ::=\n       $$return$$ Expression?"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_hyrbmfmf6r8g",
      "title": "Await Expressions",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Await Expressions\n\n FutureOperand ::=\n Operand\n\nAn await expression is an expression that polls a future,\nsuspending the execution of the future until the future is ready.\n\nA future operand is an operand whose future is being awaited by\nan await expression.\n\nAn await expression shall appear within an\nasync control flow boundary. Only the innermost control flow boundary\nshall be considered.\n\nThe type of a future operand shall implement the\ncore::future::IntoFuture trait.\n\nThe type of an await expression is\n<_ as core::future::IntoFuture>::Output.\n\nThe value of an await expression is the value held by\ncore::task::Poll::Ready.\n\nThe evaluation of an await expression proceeds as follows:\n\n#. The future operand is evaluated to a temporary by invoking\n core::future::IntoFuture::into_future with the future operand.\n\n#. The temporary is pinned using core::pin::Pin::new_unchecked.\n\n#. The pinned temporary is polled using core::future::Future::poll,\n passing in the core::task::Context of the current task.\n\n#. If core::future::Future::poll returns\n core::task::Poll::Pending, then the current future yields.\n\n#. If core::future::Future::poll returns core::task::Poll::Ready,\n then\n\n #. The value held within is unwrapped.\n\n #. Control stops the evaluation of the await expression.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_sjz5s71hwm7l": "An await expression is an expression that polls a future, suspending the execution of the future until the future is ready.",
            "fls_vhchgab59jvd": "A future operand is an operand whose future is being awaited by an await expression.",
            "fls_k9pncajmhgk1": "An await expression shall appear within an async control flow boundary. Only the innermost control flow boundary shall be considered.",
            "fls_9uw5pd7kbrx3": "The type of a future operand shall implement the core::future::IntoFuture trait.",
            "fls_c6mxfzef2qop": "The type of an await expression is <_ as core::future::IntoFuture>::Output.",
            "fls_l396mo6k9ox7": "The value of an await expression is the value held by core::task::Poll::Ready."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_1ppywe40s62c": "The evaluation of an await expression proceeds as follows: #.",
            "fls_eymcs2rgv3qw": "The future operand is evaluated to a temporary by invoking core::future::IntoFuture::into_future with the future operand. #.",
            "fls_qshnnpirkasz": "The temporary is pinned using core::pin::Pin::new_unchecked. #.",
            "fls_umevprl99y6c": "The pinned temporary is polled using core::future::Future::poll, passing in the core::task::Context of the current task. #.",
            "fls_k76d8ady623m": "If core::future::Future::poll returns core::task::Poll::Pending, then the current future yields. #.",
            "fls_frwtufwe8dya": "If core::future::Future::poll returns core::task::Poll::Ready, then #.",
            "fls_u72ylhlmqge3": "The value held within is unwrapped. #.",
            "fls_tn3vwidct3ks": "Control stops the evaluation of the await expression."
          }
        },
        "-8": {
          "paragraphs": {
            "syntax_1": "AwaitExpression ::=\n       FutureOperand $$.$$ $$await$$\n\n   FutureOperand ::=\n       Operand"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_kw25194gpael",
      "title": "Expression Precedence",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Expression Precedence\n\nCertain [expression]s are subject to precedence and\nassociativity.\n\nPrecedence is the order by which [expression]s are evaluated in the\npresence of other [expression]s.\n\nAssociativity is the order by which [operand]s are evaluated within a\nsingle expression.\n\nThe precedence and associativity of qualifying [expression]s are\nas follows:",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_cwt7afsbgs7w": "Certain [expression]s are subject to precedence and associativity.",
            "fls_ya23jjg5wjl": "Precedence is the order by which [expression]s are evaluated in the presence of other [expression]s.",
            "fls_bezkcuwp5qol": "Associativity is the order by which [operand]s are evaluated within a single expression.",
            "fls_48br7odx6nke": "The precedence and associativity of qualifying [expression]s are as follows: .. list-table:: -",
            "fls_mk2yk99p6nvp": "- **Expression** - **Precedence** - **Associativity** -",
            "fls_jtdnf0vmn6xt": "- Array expression Block expression Continue expression If expression If let expression Literal expression Loop expression Match expression Parenthesized expression Path expression Struct expression Tuple expression Underscore expression - highest - none -",
            "fls_qurz25skmryg": "- Method call expression - - none -",
            "fls_ywqn5nixelkz": "- Await expression Field access expression - - left-to-right -",
            "fls_k3ohh8k888c": "- Call expression Index expression - - none -",
            "fls_41n6z85h1z47": "- Error propagation expression - - none -",
            "fls_f39rzauxrlcl": "- Borrow expression Dereference expression Negation expression - - none -",
            "fls_djphr5mk0t6f": "- Type cast expression - - left-to-right -",
            "fls_sif2aqky96j6": "- Division expression Multiplication expression Remainder expression - - left-to-right -",
            "fls_d7x817v8xzea": "- Addition expression Subtraction expression - - left-to-right -",
            "fls_1f5ibdkz3l51": "- Shift left expression Shift right expression - - left-to-right -",
            "fls_t1zqnab8a752": "- Bit and expression - - left-to-right -",
            "fls_f6in3h5cj8i6": "- Bit xor expression - - left-to-right -",
            "fls_hxa1avitfvrq": "- Bit or expression - - left-to-right -",
            "fls_sy2xzzq06i0x": "- Comparison expression - - requires parentheses -",
            "fls_hish3qfmawd": "- Lazy and expression - - left-to-right -",
            "fls_ruy7e6yccsqk": "- Lazy or expression - - left-to-right -",
            "fls_9qcm0dx9rolw": "- Range expression - - requires parentheses -",
            "fls_1l3rgtm6o54s": "- Assignment expression Compound assignment expression - - right-to-left -",
            "fls_hr4kokysrjop": "- Break expression Closure expression Return expression - lowest - none"
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_jmjn8jkbzujm",
      "title": "Capturing",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Capturing\n\nA capturing expression is either an async block expression or a\nclosure expression.\n\nA capture target is either a variable or a field of a\nvariable.\n\nThe capturing environment of a capturing expression consists of the\n[value]s of all captured [capture target]s.\n\nCapturing is the process of saving the [capture target]s of a\n[capturing expression]'s capturing environment.\n\nA capture target requires capturing when it is used by\nthe capturing expression and it is defined outside of the\ncapturing expression. Such a capture target is said to be\ncaptured.\n\nCapture mode is the mechanism by which a capture target is captured.\n\nA captured capture target with capture mode by value capture\npasses <passing convention> the value of the capture target into\nthe capturing environment.\n\nA captured capture target with capture mode\nby immutable reference capture binds an immutable reference to the\ncapture target and passes the immutable reference into the\ncapturing environment.\n\nA captured capture target with capture mode\nby mutable reference capture binds a mutable reference to the\ncapture target and passes the mutable reference into the\ncapturing environment.\n\nA captured capture target with capture mode\nby unique immutable reference capture binds a\nunique immutable reference to the capture target and passes the\nmutable reference into the capturing environment.\n\nThe capture mode is determined based on the use of the capture target\nwithin the capturing expression, as follows:\n\n#. If the capturing expression is subject to keyword move, then\n the capture mode is by value capture.\n\n#. Otherwise the capture mode is determined based on the following\n precedence:\n\n #. By immutable reference capture.\n\n #. By unique immutable reference capture mode, if the\n capture target is a mutable reference that is being modified.\n\n #. By mutable reference capture mode.\n\n #. By value capture.\n\nA tool selects the first capture mode that is compatible with the use of\nthe capture target.",
      "rubrics": {
        "-2": {
          "paragraphs": {
            "fls_iamnzlm430ef": "A capturing expression is either an async block expression or a closure expression.",
            "fls_eca6tl7j0afx": "A capture target is either a variable or a field of a variable.",
            "fls_e70ywb8191h": "The capturing environment of a capturing expression consists of the [value]s of all captured [capture target]s.",
            "fls_1y2ttb466m9c": "Capturing is the process of saving the [capture target]s of a [capturing expression]'s capturing environment.",
            "fls_ip81lt2mm940": "A capture target requires capturing when it is used by the capturing expression and it is defined outside of the capturing expression. Such a capture target is said to be captured.",
            "fls_y9n1i4hbq8sf": "Capture mode is the mechanism by which a capture target is captured.",
            "fls_O6WYL8AUyPje": "A captured capture target with capture mode by value capture passes <passing convention> the value of the capture target into the capturing environment.",
            "fls_aCxt2Ovmb5He": "A captured capture target with capture mode by immutable reference capture binds an immutable reference to the capture target and passes the immutable reference into the capturing environment.",
            "fls_xTNFfkxHm5yy": "A captured capture target with capture mode by mutable reference capture binds a mutable reference to the capture target and passes the mutable reference into the capturing environment.",
            "fls_8HLaLAIZgYfs": "A captured capture target with capture mode by unique immutable reference capture binds a unique immutable reference to the capture target and passes the mutable reference into the capturing environment.",
            "fls_t695ps4lfh6z": "The capture mode is determined based on the use of the capture target within the capturing expression, as follows: #.",
            "fls_6j8cr7d5zs1l": "If the capturing expression is subject to keyword move, then the capture mode is by value capture. #.",
            "fls_l8e98pyhm08g": "Otherwise the capture mode is determined based on the following precedence: #.",
            "fls_33hfay24hx8u": "By immutable reference capture. #.",
            "fls_wmxsd0i2yemf": "By unique immutable reference capture mode, if the capture target is a mutable reference that is being modified. #.",
            "fls_lu779ufqhggl": "By mutable reference capture mode. #.",
            "fls_uqy5w9uc8gla": "By value capture.",
            "fls_wvob7114tfat": "A tool selects the first capture mode that is compatible with the use of the capture target."
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_ZfIBiJMf8qE1",
      "title": "Arithmetic Overflow",
      "category": 0,
      "level": 2,
      "file": "expressions",
      "content": "Arithmetic Overflow\n\nAn arithmetic overflow occurs when an operator expression computes a\nvalue of a scalar type that lies outside of the range of valid\n[value]s for the scalar type or when one or more operand of an\noperator expression lies outside of the range of valid [value]s for\nthe operation.\n\nThere are two allowed behaviors for arithmetic overflow:\n\n#. Evaluation of the expression may result in a panic.\n\n#. The resulting value of the expression may be truncated, discarding\n the most significant bits that do not fit in the target type.",
      "rubrics": {
        "-1": {
          "paragraphs": {
            "fls_oFIRXBPXu6Zv": "An arithmetic overflow occurs when an operator expression computes a value of a scalar type that lies outside of the range of valid [value]s for the scalar type or when one or more operand of an operator expression lies outside of the range of valid [value]s for the operation."
          }
        },
        "-3": {
          "paragraphs": {
            "fls_8fU3h8PLasqA": "There are two allowed behaviors for arithmetic overflow: #.",
            "fls_R48VKcEIbfXC": "Evaluation of the expression may result in a panic. #.",
            "fls_QMpI8K43K2yU": "The resulting value of the expression may be truncated, discarding the most significant bits that do not fit in the target type."
          }
        }
      },
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm"
      ]
    }
  ]
}